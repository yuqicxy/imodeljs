/*---------------------------------------------------------------------------------------------
* Copyright (c) Bentley Systems, Incorporated. All rights reserved.
* See LICENSE.md in the project root for license terms and full copyright notice.
*--------------------------------------------------------------------------------------------*/
const fs = require("fs-extra");
const path = require("path");
const paths = require("../../config/paths");
const webpack = require("webpack");
const WebpackDevServer = require("webpack-dev-server");
const { printFrontendInstructions, createCompiler } = require("./createCompiler");
const isInteractive = process.stdout.isTTY;
const { prepareProxy, prepareUrls } = require("react-dev-utils/WebpackDevServerUtils");

async function watchBackend(config) {
  await new Promise((resolve, reject) => {
    const compiler = createCompiler(webpack, config, ` BACKEND `, "Starting development build...", resolve);
    compiler.watch({}, (err, stats) => {
      if (err) {
        reject(err);
      }
    });
  });
}

async function startFrontendDevServer(config, host, port) {
  const protocol = process.env.HTTPS === "true" ? "https" : "http";
  const appName = require(paths.appPackageJson).name;
  const urls = prepareUrls(protocol, host, port);

  // Load proxy config
  const proxySetting = require(paths.appPackageJson).proxy;
  const proxyConfig = prepareProxy(proxySetting, paths.appPublic);

  // NEEDSWORK: prepareProxy will only ignore files in appPublic, but because we copy files into appLibPublic, we need to monkey-patch this
  // proxy config to ignore those as well.  Maybe we should just skip prepareProxy and setup the proxy config ourselves?
  const currentContext = proxyConfig[0].context;
  proxyConfig[0].context = (p, r) => (!fs.existsSync(path.resolve(paths.appLibPublic, p.slice(1))) && currentContext(p, r));

  // Serve webpack assets generated by the compiler over a web sever.
  const createDevServerConfig = require("../../config/webpackDevServer.config");
  const serverConfig = createDevServerConfig(
    proxyConfig,
    urls.lanUrlForConfig
  );

  const devServerInfo = { urls };
  return await new Promise((resolve) => {
    const compiler = createCompiler(webpack, config, " FRONTEND ", "Starting the webpack development server...", (count) => {
      if (isInteractive || count === 1) {
        printFrontendInstructions(appName, urls);
      }

      if (count === 1) {
        resolve(devServerInfo);
      }
    });

    devServerInfo.instance = new WebpackDevServer(compiler, serverConfig);
    devServerInfo.instance.listen(port, host, err => {
      if (err) {
        return console.log(err);
      }
    });
  });
}

function runWebpackAsync(compiler) {
  return new Promise((resolve, reject) => {
    compiler.run((err, stats) => (err) ? reject(err) : resolve(stats))
  });
}

async function runWebpackBuild(config, name) {
  const compiler = createCompiler(webpack, config, ` ${name} `, "Starting build...");
  const stats = await runWebpackAsync(compiler);
  return stats;
}

function buildBackend(config) {
  return runWebpackBuild(config, "BACKEND");
}

function buildFrontend(config) {
  return runWebpackBuild(config, "FRONTEND");
}

async function saveJsonStats(stats, outputPath) {
  await fs.writeFile(outputPath, JSON.stringify(stats.toJson({ all: true })));
  return outputPath;
}

module.exports = {
  buildBackend,
  buildFrontend,
  watchBackend,
  startFrontendDevServer,
  saveJsonStats,
};