## API Report File for "@bentley/imodeljs-common"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Angle } from '@bentley/geometry-core';
import { AngleProps } from '@bentley/geometry-core';
import { AnyGeometryQuery } from '@bentley/geometry-core';
import { AuthorizedClientRequestContext } from '@bentley/imodeljs-clients';
import { AuthStatus } from '@bentley/bentleyjs-core';
import { BeEvent } from '@bentley/bentleyjs-core';
import { BentleyError } from '@bentley/bentleyjs-core';
import { BentleyStatus } from '@bentley/bentleyjs-core';
import { BriefcaseStatus } from '@bentley/bentleyjs-core';
import { ByteStream } from '@bentley/bentleyjs-core';
import { ChangeSetStatus } from '@bentley/bentleyjs-core';
import { ClientRequestContext } from '@bentley/bentleyjs-core';
import { ClipPlane } from '@bentley/geometry-core';
import { ConvexClipPlaneSet } from '@bentley/geometry-core';
import { DbResult } from '@bentley/bentleyjs-core';
import { GeometryQuery } from '@bentley/geometry-core';
import { GetMetaDataFunction } from '@bentley/bentleyjs-core';
import { GuidString } from '@bentley/bentleyjs-core';
import { Id64 } from '@bentley/bentleyjs-core';
import { Id64Array } from '@bentley/bentleyjs-core';
import { Id64String } from '@bentley/bentleyjs-core';
import { IDisposable } from '@bentley/bentleyjs-core';
import { IModelClient } from '@bentley/imodeljs-clients';
import { IModelJson } from '@bentley/geometry-core';
import { IModelStatus } from '@bentley/bentleyjs-core';
import { IndexedPolyfaceVisitor } from '@bentley/geometry-core';
import { IndexedValue } from '@bentley/bentleyjs-core';
import { IndexMap } from '@bentley/bentleyjs-core';
import { LogFunction } from '@bentley/bentleyjs-core';
import { LogLevel } from '@bentley/bentleyjs-core';
import { LowAndHighXY } from '@bentley/geometry-core';
import { LowAndHighXYZ } from '@bentley/geometry-core';
import { Map4d } from '@bentley/geometry-core';
import { Matrix3d } from '@bentley/geometry-core';
import { Matrix4dProps } from '@bentley/geometry-core';
import { OpenMode } from '@bentley/bentleyjs-core';
import { Point2d } from '@bentley/geometry-core';
import { Point3d } from '@bentley/geometry-core';
import { PolyfaceVisitor } from '@bentley/geometry-core';
import { Range1d } from '@bentley/geometry-core';
import { Range1dProps } from '@bentley/geometry-core';
import { Range2d } from '@bentley/geometry-core';
import { Range3d } from '@bentley/geometry-core';
import { Range3dProps } from '@bentley/geometry-core';
import { Readable } from 'stream';
import { RepositoryStatus } from '@bentley/bentleyjs-core';
import { RpcInterfaceStatus } from '@bentley/bentleyjs-core';
import { SerializedClientRequestContext } from '@bentley/bentleyjs-core';
import { Transform } from '@bentley/geometry-core';
import { TransformProps } from '@bentley/geometry-core';
import { Vector3d } from '@bentley/geometry-core';
import { Writable } from 'stream';
import { XYAndZ } from '@bentley/geometry-core';
import { XYProps } from '@bentley/geometry-core';
import { XYZProps } from '@bentley/geometry-core';
import { YawPitchRollAngles } from '@bentley/geometry-core';
import { YawPitchRollProps } from '@bentley/geometry-core';

// @beta
export namespace AmbientOcclusion {
    export interface Props {
        readonly bias?: number;
        readonly blurDelta?: number;
        readonly blurSigma?: number;
        // (undocumented)
        readonly blurTexelStepSize?: number;
        readonly intensity?: number;
        readonly maxDistance?: number;
        readonly texelStepSize?: number;
        readonly zLengthCap?: number;
    }
    export class Settings implements Props {
        // (undocumented)
        readonly bias: number;
        // (undocumented)
        readonly blurDelta: number;
        // (undocumented)
        readonly blurSigma: number;
        // (undocumented)
        readonly blurTexelStepSize: number;
        // (undocumented)
        static defaults: Settings;
        // (undocumented)
        static fromJSON(json?: Props): Settings;
        // (undocumented)
        readonly intensity: number;
        // (undocumented)
        readonly maxDistance: number;
        // (undocumented)
        readonly texelStepSize: number;
        // (undocumented)
        toJSON(): Props;
        // (undocumented)
        readonly zLengthCap: number;
    }
}

// @alpha (undocumented)
export class AnalysisStyle implements AnalysisStyleProps {
    // (undocumented)
    clone(out?: AnalysisStyle): AnalysisStyle;
    // (undocumented)
    copyFrom(source: AnalysisStyle): void;
    // (undocumented)
    displacementChannelName?: string;
    // (undocumented)
    displacementScale?: number;
    // (undocumented)
    static fromJSON(json?: AnalysisStyleProps): AnalysisStyle;
    // (undocumented)
    inputName?: string;
    // (undocumented)
    inputRange?: Range1d;
    // (undocumented)
    normalChannelName?: string;
    // (undocumented)
    scalarChannelName?: string;
    // (undocumented)
    scalarRange?: Range1d;
    // (undocumented)
    scalarThematicSettings?: Gradient.ThematicSettings;
    // (undocumented)
    scalarThematicTexture?: RenderTexture;
}

// @alpha
export interface AnalysisStyleProps {
    // (undocumented)
    displacementChannelName?: string;
    // (undocumented)
    displacementScale?: number;
    // (undocumented)
    inputName?: string;
    // (undocumented)
    inputRange?: Range1dProps;
    // (undocumented)
    normalChannelName?: string;
    // (undocumented)
    scalarChannelName?: string;
    // (undocumented)
    scalarRange?: Range1dProps;
    // (undocumented)
    scalarThematicSettings?: Gradient.ThematicSettingsProps;
}

// @internal (undocumented)
export const enum AntiAliasPref {
    // (undocumented)
    Detect = 0,
    // (undocumented)
    Off = 2,
    // (undocumented)
    On = 1
}

// @public
export interface AreaFillProps {
    backgroundFill?: BackgroundFill;
    color?: ColorDefProps;
    display: FillDisplay;
    // @beta
    gradient?: Gradient.SymbProps;
    transparency?: number;
}

// @public (undocumented)
export namespace AreaPattern {
    // (undocumented)
    export class HatchDefLine implements HatchDefLineProps {
        constructor(json: HatchDefLineProps);
        // (undocumented)
        angle?: Angle;
        // (undocumented)
        dashes?: number[];
        // (undocumented)
        offset?: Point2d;
        // (undocumented)
        through?: Point2d;
    }
    export interface HatchDefLineProps {
        angle?: AngleProps;
        dashes?: number[];
        offset?: XYProps;
        through?: XYProps;
    }
    export class Params implements ParamsProps {
        // (undocumented)
        angle1?: Angle;
        // (undocumented)
        angle2?: Angle;
        // (undocumented)
        applyTransform(transform: Transform): boolean;
        // (undocumented)
        clone(): Params;
        // (undocumented)
        color?: ColorDef;
        // (undocumented)
        defLines?: HatchDefLine[];
        // (undocumented)
        equals(other: Params): boolean;
        static fromJSON(json?: ParamsProps): Params;
        // (undocumented)
        static getTransformPatternScale(transform: Transform): number;
        // (undocumented)
        invisibleBoundary?: boolean;
        // (undocumented)
        origin?: Point3d;
        // (undocumented)
        rotation?: YawPitchRollAngles;
        // (undocumented)
        scale?: number;
        // (undocumented)
        snappable?: boolean;
        // (undocumented)
        space1?: number;
        // (undocumented)
        space2?: number;
        // (undocumented)
        symbolId?: Id64String;
        // (undocumented)
        static transformPatternSpace(transform: Transform, oldSpace: number, patRot: Matrix3d, angle?: Angle): number;
        // (undocumented)
        weight?: number;
    }
    export interface ParamsProps {
        angle1?: AngleProps;
        angle2?: AngleProps;
        color?: ColorDefProps;
        defLines?: HatchDefLineProps[];
        invisibleBoundary?: boolean;
        origin?: XYZProps;
        rotation?: YawPitchRollProps;
        scale?: number;
        snappable?: boolean;
        space1?: number;
        space2?: number;
        symbolId?: Id64String;
        weight?: number;
    }
}

export { AuthStatus }

// @public
export interface AuxCoordSystem2dProps extends AuxCoordSystemProps {
    angle?: AngleProps;
    origin?: XYProps;
}

// @public
export interface AuxCoordSystem3dProps extends AuxCoordSystemProps {
    origin?: XYZProps;
    pitch?: AngleProps;
    roll?: AngleProps;
    yaw?: AngleProps;
}

// @public (undocumented)
export interface AuxCoordSystemProps extends ElementProps {
    // (undocumented)
    description?: string;
    // (undocumented)
    type?: number;
}

// @public
export type AxisAlignedBox3d = Range3d;

// @public
export type AxisAlignedBox3dProps = Range3dProps;

// @internal
export class B3dmHeader extends TileHeader {
    constructor(stream: ByteStream);
    // (undocumented)
    readonly batchTableBinaryLength: number;
    // (undocumented)
    readonly batchTableJson: any;
    // (undocumented)
    readonly batchTableJsonLength: number;
    // (undocumented)
    readonly featureTableBinaryLength: number;
    // (undocumented)
    readonly featureTableJson: any;
    // (undocumented)
    readonly featureTableJsonLength: number;
    // (undocumented)
    get isValid(): boolean;
    // (undocumented)
    readonly length: number;
}

// @public (undocumented)
export class BackendError extends IModelError {
    constructor(errorNumber: number, name: string, message: string, log?: LogFunction, category?: string, getMetaData?: GetMetaDataFunction);
}

// @public
export enum BackgroundFill {
    None = 0,
    Outline = 2,
    Solid = 1
}

// @public
export interface BackgroundMapProps {
    applyTerrain?: boolean;
    groundBias?: number;
    providerData?: {
        mapType?: BackgroundMapType;
    };
    providerName?: string;
    // @alpha
    terrainSettings?: TerrainProps;
    transparency?: number | false;
    useDepthBuffer?: boolean;
}

// @beta
export type BackgroundMapProviderName = "BingProvider" | "MapBoxProvider";

// @beta
export class BackgroundMapSettings {
    readonly applyTerrain: boolean;
    clone(changedProps?: BackgroundMapProps): BackgroundMapSettings;
    // (undocumented)
    equals(other: BackgroundMapSettings): boolean;
    equalsJSON(json?: BackgroundMapProps): boolean;
    static fromJSON(json?: BackgroundMapProps): BackgroundMapSettings;
    readonly groundBias: number;
    readonly mapType: BackgroundMapType;
    readonly providerName: BackgroundMapProviderName;
    // @alpha
    readonly terrainSettings: TerrainSettings;
    // (undocumented)
    toJSON(): BackgroundMapProps;
    readonly transparency: number | false;
    get transparencyOverride(): number | undefined;
    readonly useDepthBuffer: boolean;
}

// @public
export enum BackgroundMapType {
    // (undocumented)
    Aerial = 2,
    // (undocumented)
    Hybrid = 3,
    // (undocumented)
    Street = 1
}

// @beta
export enum BatchType {
    PlanarClassifier = 2,
    Primary = 0,
    VolumeClassifier = 1
}

// @public
export abstract class BentleyCloudRpcConfiguration extends RpcConfiguration {
    abstract readonly protocol: BentleyCloudRpcProtocol;
}

// @public
export class BentleyCloudRpcManager extends RpcManager {
    static initializeClient(params: BentleyCloudRpcParams, interfaces: RpcInterfaceDefinition[]): BentleyCloudRpcConfiguration;
    static initializeImpl(params: BentleyCloudRpcParams, interfaces: RpcInterfaceDefinition[]): BentleyCloudRpcConfiguration;
    }

// @public
export interface BentleyCloudRpcParams {
    info: OpenAPIInfo;
    pendingRequestListener?: RpcRequestEventHandler;
    protocol?: typeof BentleyCloudRpcProtocol;
    uriPrefix?: string;
}

// @public
export abstract class BentleyCloudRpcProtocol extends WebAppRpcProtocol {
    // (undocumented)
    checkToken: boolean;
    getOperationFromPath(path: string): SerializedRpcOperation;
    inflateToken(tokenFromBody: IModelTokenProps, request: SerializedRpcRequest): IModelTokenProps;
    serializedClientRequestContextHeaderNames: SerializedClientRequestContext;
    supplyPathForOperation(operation: RpcOperation, request: RpcRequest | undefined): string;
    // @internal
    supplyPathParametersForOperation(_operation: RpcOperation): OpenAPIParameter[];
}

export { BentleyError }

export { BentleyStatus }

// @public
export enum BisCodeSpec {
    // (undocumented)
    annotationFrameStyle = "bis:AnnotationFrameStyle",
    // (undocumented)
    annotationLeaderStyle = "bis:AnnotationLeaderStyle",
    // (undocumented)
    annotationTextStyle = "bis:AnnotationTextStyle",
    // (undocumented)
    auxCoordSystem2d = "bis:AuxCoordSystem2d",
    // (undocumented)
    auxCoordSystem3d = "bis:AuxCoordSystem3d",
    // (undocumented)
    auxCoordSystemSpatial = "bis:AuxCoordSystemSpatial",
    // (undocumented)
    categorySelector = "bis:CategorySelector",
    // (undocumented)
    colorBook = "bis:ColorBook",
    // (undocumented)
    displayStyle = "bis:DisplayStyle",
    // (undocumented)
    drawing = "bis:Drawing",
    // (undocumented)
    drawingCategory = "bis:DrawingCategory",
    // (undocumented)
    geometryPart = "bis:GeometryPart",
    // (undocumented)
    graphicalType2d = "bis:GraphicalType2d",
    // (undocumented)
    informationPartitionElement = "bis:InformationPartitionElement",
    // (undocumented)
    lineStyle = "bis:LineStyle",
    // (undocumented)
    linkElement = "bis:LinkElement",
    // (undocumented)
    modelSelector = "bis:ModelSelector",
    // (undocumented)
    nullCodeSpec = "bis:NullCodeSpec",
    // (undocumented)
    physicalMaterial = "bis:PhysicalMaterial",
    // (undocumented)
    physicalType = "bis:PhysicalType",
    // (undocumented)
    renderMaterial = "bis:RenderMaterial",
    // (undocumented)
    sheet = "bis:Sheet",
    // (undocumented)
    spatialCategory = "bis:SpatialCategory",
    // (undocumented)
    spatialLocationType = "bis:SpatialLocationType",
    // (undocumented)
    subCategory = "bis:SubCategory",
    // (undocumented)
    subject = "bis:Subject",
    // (undocumented)
    templateRecipe2d = "bis:TemplateRecipe2d",
    // (undocumented)
    templateRecipe3d = "bis:TemplateRecipe3d",
    // (undocumented)
    textAnnotationSeed = "bis:TextAnnotationSeed",
    // (undocumented)
    texture = "bis:Texture",
    // (undocumented)
    viewDefinition = "bis:ViewDefinition"
}

// @internal (undocumented)
export function bisectTileRange2d(range: Range3d, takeUpper: boolean): void;

// @internal (undocumented)
export function bisectTileRange3d(range: Range3d, takeUpper: boolean): void;

// @internal
export class BoundingSphere {
    constructor(center?: Point3d, radius?: number);
    // (undocumented)
    center: Point3d;
    // (undocumented)
    init(center: Point3d, radius: number): void;
    // (undocumented)
    radius: number;
    // (undocumented)
    transformBy(transform: Transform, result: BoundingSphere): BoundingSphere;
}

// @beta (undocumented)
export namespace BRepEntity {
    export interface DataProps {
        data?: string;
        faceSymbology?: FaceSymbologyProps[];
        transform?: TransformProps;
        type?: Type;
    }
    export interface FaceSymbologyProps {
        color?: ColorDefProps;
        materialId?: Id64String;
        transparency?: number;
    }
    export enum Type {
        Sheet = 1,
        Solid = 0,
        Wire = 2
    }
}

export { BriefcaseStatus }

// @public (undocumented)
export interface CalloutProps extends GeometricElement2dProps {
    // (undocumented)
    drawingModel?: RelatedElementProps;
}

// @public
export class Camera implements CameraProps {
    constructor(props?: CameraProps);
    // (undocumented)
    clone(): Camera;
    // (undocumented)
    equals(other: Camera): boolean;
    // (undocumented)
    readonly eye: Point3d;
    // (undocumented)
    focusDist: number;
    // (undocumented)
    getEyePoint(): Point3d;
    // (undocumented)
    getFocusDistance(): number;
    // (undocumented)
    getLensAngle(): Angle;
    // (undocumented)
    invalidateFocus(): void;
    // (undocumented)
    get isFocusValid(): boolean;
    // (undocumented)
    get isLensValid(): boolean;
    // (undocumented)
    get isValid(): boolean;
    // (undocumented)
    static isValidLensAngle(val: Angle): boolean;
    // (undocumented)
    readonly lens: Angle;
    // (undocumented)
    setEyePoint(pt: XYAndZ): void;
    // (undocumented)
    setFocusDistance(dist: number): void;
    // (undocumented)
    setFrom(rhs: Camera): void;
    // (undocumented)
    setLensAngle(angle: Angle): void;
    // (undocumented)
    validateLens(): void;
    // (undocumented)
    static validateLensAngle(val: Angle): void;
}

// @public
export interface CameraProps {
    // (undocumented)
    eye: XYZProps;
    // (undocumented)
    focusDist: number;
    // (undocumented)
    lens: AngleProps;
}

// @public
export class Cartographic implements LatLongAndHeight {
    constructor(longitude?: number, latitude?: number, height?: number);
    clone(result?: Cartographic): Cartographic;
    equals(right: LatLongAndHeight): boolean;
    equalsEpsilon(right: LatLongAndHeight, epsilon: number): boolean;
    static fromAngles(longitude: Angle, latitude: Angle, height: number, result?: Cartographic): Cartographic;
    static fromDegrees(longitude: number, latitude: number, height: number, result?: Cartographic): Cartographic;
    static fromEcef(cartesian: Point3d, result?: Cartographic): Cartographic | undefined;
    static fromRadians(longitude: number, latitude: number, height?: number, result?: Cartographic): Cartographic;
    // (undocumented)
    height: number;
    // (undocumented)
    latitude: number;
    // (undocumented)
    longitude: number;
    toEcef(result?: Point3d): Point3d;
    toString(): string;
    }

// @public
export class CartographicRange {
    constructor(spatialRange: Range3d, spatialToEcef: Transform);
    getLongitudeLatitudeBoundingBox(): Range2d;
    // (undocumented)
    intersectsRange(other: CartographicRange): boolean;
    }

// @public
export interface CategoryProps extends DefinitionElementProps {
    // (undocumented)
    description?: string;
    // (undocumented)
    rank?: Rank;
}

// @public
export interface CategorySelectorProps extends DefinitionElementProps {
    // (undocumented)
    categories: Id64Array;
}

// @internal (undocumented)
export interface ChangeData {
    // (undocumented)
    changedElements: ChangedElements;
    // (undocumented)
    changedModels: ChangedModels;
}

// @internal (undocumented)
export interface ChangedElements {
    // (undocumented)
    classIds: Id64String[];
    // (undocumented)
    elements: Id64String[];
    // (undocumented)
    modelIds?: Id64String[];
    // (undocumented)
    opcodes: number[];
}

// @internal (undocumented)
export interface ChangedModels {
    // (undocumented)
    bboxes: AxisAlignedBox3dProps[];
    // (undocumented)
    modelIds: Id64String[];
}

// @public
export enum ChangedValueState {
    // (undocumented)
    AfterInsert = 1,
    // (undocumented)
    AfterUpdate = 3,
    // (undocumented)
    BeforeDelete = 4,
    // (undocumented)
    BeforeUpdate = 2
}

// @public
export enum ChangeOpCode {
    // (undocumented)
    Delete = 4,
    // (undocumented)
    Insert = 1,
    // (undocumented)
    Update = 2
}

export { ChangeSetStatus }

// @internal (undocumented)
export const CHANNEL = "@bentley/imodeljs-mobilegateway";

// @internal
export interface ClassifierTileTreeId {
    // (undocumented)
    animationId?: Id64String;
    // (undocumented)
    expansion: number;
    // (undocumented)
    type: BatchType.VolumeClassifier | BatchType.PlanarClassifier;
}

// @beta (undocumented)
export abstract class CloudStorageCache<TContentId, TContentType> {
    constructor();
    // (undocumented)
    protected formContainerKey(id: TContentId): string;
    // (undocumented)
    abstract formContainerName(id: TContentId): string;
    // (undocumented)
    abstract formResourceName(id: TContentId): string;
    // (undocumented)
    protected getContainer(id: TContentId): Promise<CloudStorageContainerUrl>;
    // (undocumented)
    protected abstract instantiateResource(response: Response): Promise<TContentType | undefined>;
    // (undocumented)
    protected abstract obtainContainerUrl(id: TContentId, descriptor: CloudStorageContainerDescriptor): Promise<CloudStorageContainerUrl>;
    // (undocumented)
    provider: CloudStorageProvider;
    // (undocumented)
    protected requestResource(container: CloudStorageContainerUrl, id: TContentId): Promise<Response>;
    // (undocumented)
    retrieve(id: TContentId): Promise<TContentType | undefined>;
    // (undocumented)
    protected supplyUrlBase(_container: CloudStorageContainerUrl, _id: TContentId): string | undefined;
}

// @beta (undocumented)
export interface CloudStorageContainerDescriptor {
    // (undocumented)
    name: string;
    // (undocumented)
    provider?: CloudStorageProvider;
    // (undocumented)
    resource?: string;
}

// @beta (undocumented)
export interface CloudStorageContainerUrl {
    // (undocumented)
    bound?: boolean;
    // (undocumented)
    descriptor: CloudStorageContainerDescriptor;
    // (undocumented)
    expires: number;
    // (undocumented)
    headers?: Record<string, string>;
    // (undocumented)
    method?: string;
    // (undocumented)
    url: string;
    // (undocumented)
    valid: number;
}

// @beta (undocumented)
export namespace CloudStorageContainerUrl {
    // (undocumented)
    export function empty(): CloudStorageContainerUrl;
}

// @beta (undocumented)
export enum CloudStorageProvider {
    // (undocumented)
    AliCloud = 2,
    // (undocumented)
    Amazon = 1,
    // (undocumented)
    Azure = 0,
    // (undocumented)
    External = 3,
    // (undocumented)
    Unknown = 4
}

// @beta (undocumented)
export class CloudStorageTileCache extends CloudStorageCache<TileContentIdentifier, Uint8Array> {
    protected constructor();
    // (undocumented)
    protected formContainerKey(id: TileContentIdentifier): string;
    // (undocumented)
    formContainerName(id: TileContentIdentifier): string;
    // (undocumented)
    formResourceName(id: TileContentIdentifier): string;
    // (undocumented)
    static getCache(): CloudStorageTileCache;
    // (undocumented)
    protected instantiateResource(response: Response): Promise<Uint8Array | undefined>;
    // (undocumented)
    protected obtainContainerUrl(id: TileContentIdentifier, descriptor: CloudStorageContainerDescriptor): Promise<CloudStorageContainerUrl>;
    // (undocumented)
    supplyExpiryForContainerUrl(_id: CloudStorageContainerDescriptor): Date;
}

// @public
export class Code implements CodeProps {
    constructor(val: CodeProps);
    static createEmpty(): Code;
    // (undocumented)
    equals(other: Code): boolean;
    // (undocumented)
    static fromJSON(json?: any): Code;
    // (undocumented)
    getValue(): string;
    scope: string;
    spec: Id64String;
    value?: string;
}

// @public
export interface CodeProps {
    // (undocumented)
    scope: CodeScopeProps;
    // (undocumented)
    spec: Id64String;
    // (undocumented)
    value?: string;
}

// @public
export type CodeScopeProps = Id64String | GuidString;

// @public
export namespace CodeScopeSpec {
    export enum ScopeRequirement {
        ElementId = 1,
        FederationGuid = 2
    }
    export enum Type {
        Model = 2,
        ParentElement = 3,
        RelatedElement = 4,
        Repository = 1
    }
}

// @public
export class CodeSpec {
    // @internal @deprecated
    constructor(iModel: IModel, id: Id64String, name: string, scopeType?: CodeScopeSpec.Type, scopeReq?: CodeScopeSpec.ScopeRequirement, properties?: any);
    static create(iModel: IModel, name: string, scopeType: CodeScopeSpec.Type, scopeReq?: CodeScopeSpec.ScopeRequirement): CodeSpec;
    // @internal
    static createFromJson(iModel: IModel, id: Id64String, name: string, properties: any): CodeSpec;
    id: Id64String;
    iModel: IModel;
    // @beta
    get isManagedWithIModel(): boolean;
    set isManagedWithIModel(value: boolean);
    get isValid(): boolean;
    name: string;
    // @internal
    properties: any;
    get scopeReq(): CodeScopeSpec.ScopeRequirement;
    set scopeReq(req: CodeScopeSpec.ScopeRequirement);
    get scopeType(): CodeScopeSpec.Type;
    set scopeType(scopeType: CodeScopeSpec.Type);
    // @deprecated
    get specScopeType(): CodeScopeSpec.Type;
    set specScopeType(scopeType: CodeScopeSpec.Type);
}

// @public
export enum ColorByName {
    // (undocumented)
    aliceBlue = 16775408,
    // (undocumented)
    amber = 49151,
    // (undocumented)
    antiqueWhite = 14150650,
    // (undocumented)
    aqua = 16776960,
    // (undocumented)
    aquamarine = 13959039,
    // (undocumented)
    azure = 16777200,
    // (undocumented)
    beige = 14480885,
    // (undocumented)
    bisque = 12903679,
    // (undocumented)
    black = 0,
    // (undocumented)
    blanchedAlmond = 13495295,
    // (undocumented)
    blue = 16711680,
    // (undocumented)
    blueViolet = 14822282,
    // (undocumented)
    brown = 2763429,
    // (undocumented)
    burlyWood = 8894686,
    // (undocumented)
    cadetBlue = 10526303,
    // (undocumented)
    chartreuse = 65407,
    // (undocumented)
    chocolate = 1993170,
    // (undocumented)
    coral = 5275647,
    // (undocumented)
    cornflowerBlue = 15570276,
    // (undocumented)
    cornSilk = 14481663,
    // (undocumented)
    crimson = 3937500,
    // (undocumented)
    cyan = 16776960,
    // (undocumented)
    darkBlue = 9109504,
    // (undocumented)
    darkBrown = 2179941,
    // (undocumented)
    darkCyan = 9145088,
    // (undocumented)
    darkGoldenrod = 755384,
    // (undocumented)
    darkGray = 11119017,
    // (undocumented)
    darkGreen = 25600,
    // (undocumented)
    darkGrey = 11119017,
    // (undocumented)
    darkKhaki = 7059389,
    // (undocumented)
    darkMagenta = 9109643,
    // (undocumented)
    darkOliveGreen = 3107669,
    // (undocumented)
    darkOrange = 36095,
    // (undocumented)
    darkOrchid = 13382297,
    // (undocumented)
    darkRed = 139,
    // (undocumented)
    darkSalmon = 8034025,
    // (undocumented)
    darkSeagreen = 9419919,
    // (undocumented)
    darkSlateBlue = 9125192,
    // (undocumented)
    darkSlateGray = 5197615,
    // (undocumented)
    darkSlateGrey = 5197615,
    // (undocumented)
    darkTurquoise = 13749760,
    // (undocumented)
    darkViolet = 13828244,
    // (undocumented)
    deepPink = 9639167,
    // (undocumented)
    deepSkyBlue = 16760576,
    // (undocumented)
    dimGray = 6908265,
    // (undocumented)
    dimGrey = 6908265,
    // (undocumented)
    dodgerBlue = 16748574,
    // (undocumented)
    fireBrick = 2237106,
    // (undocumented)
    floralWhite = 15792895,
    // (undocumented)
    forestGreen = 2263842,
    // (undocumented)
    fuchsia = 16711935,
    // (undocumented)
    gainsboro = 14474460,
    // (undocumented)
    ghostWhite = 16775416,
    // (undocumented)
    gold = 55295,
    // (undocumented)
    goldenrod = 2139610,
    // (undocumented)
    gray = 8421504,
    // (undocumented)
    green = 32768,
    // (undocumented)
    greenYellow = 3145645,
    // (undocumented)
    grey = 8421504,
    // (undocumented)
    honeydew = 15794160,
    // (undocumented)
    hotPink = 11823615,
    // (undocumented)
    indianRed = 6053069,
    // (undocumented)
    indigo = 8519755,
    // (undocumented)
    ivory = 15794175,
    // (undocumented)
    khaki = 9234160,
    // (undocumented)
    lavender = 16443110,
    // (undocumented)
    lavenderBlush = 16118015,
    // (undocumented)
    lawnGreen = 64636,
    // (undocumented)
    lemonChiffon = 13499135,
    // (undocumented)
    lightBlue = 15128749,
    // (undocumented)
    lightCoral = 8421616,
    // (undocumented)
    lightCyan = 16777184,
    // (undocumented)
    lightGoldenrodYellow = 13826810,
    // (undocumented)
    lightGray = 13882323,
    // (undocumented)
    lightGreen = 9498256,
    // (undocumented)
    lightGrey = 13882323,
    // (undocumented)
    lightPink = 12695295,
    // (undocumented)
    lightSalmon = 8036607,
    // (undocumented)
    lightSeagreen = 11186720,
    // (undocumented)
    lightSkyBlue = 16436871,
    // (undocumented)
    lightSlateGray = 10061943,
    // (undocumented)
    lightSlateGrey = 10061943,
    // (undocumented)
    lightSteelBlue = 14599344,
    // (undocumented)
    lightyellow = 14745599,
    // (undocumented)
    lime = 65280,
    // (undocumented)
    limeGreen = 3329330,
    // (undocumented)
    linen = 15134970,
    // (undocumented)
    magenta = 16711935,
    // (undocumented)
    maroon = 128,
    // (undocumented)
    mediumAquamarine = 11193702,
    // (undocumented)
    mediumBlue = 13434880,
    // (undocumented)
    mediumOrchid = 13850042,
    // (undocumented)
    mediumPurple = 14381203,
    // (undocumented)
    mediumSeaGreen = 7451452,
    // (undocumented)
    mediumSlateBlue = 15624315,
    // (undocumented)
    mediumSpringGreen = 10156544,
    // (undocumented)
    mediumTurquoise = 13422920,
    // (undocumented)
    mediumVioletRed = 8721863,
    // (undocumented)
    midnightBlue = 7346457,
    // (undocumented)
    mintCream = 16449525,
    // (undocumented)
    mistyRose = 14804223,
    // (undocumented)
    moccasin = 11920639,
    // (undocumented)
    navajoWhite = 11394815,
    // (undocumented)
    navy = 8388608,
    // (undocumented)
    oldLace = 15136253,
    // (undocumented)
    olive = 32896,
    // (undocumented)
    oliveDrab = 2330219,
    // (undocumented)
    orange = 42495,
    // (undocumented)
    orangeRed = 17919,
    // (undocumented)
    orchid = 14053594,
    // (undocumented)
    paleGoldenrod = 11200750,
    // (undocumented)
    paleGreen = 10025880,
    // (undocumented)
    paleTurquoise = 15658671,
    // (undocumented)
    paleVioletRed = 9662683,
    // (undocumented)
    papayaWhip = 14020607,
    // (undocumented)
    peachPuff = 12180223,
    // (undocumented)
    peru = 4163021,
    // (undocumented)
    pink = 13353215,
    // (undocumented)
    plum = 14524637,
    // (undocumented)
    powderBlue = 15130800,
    // (undocumented)
    purple = 8388736,
    // (undocumented)
    rebeccaPurple = 10040166,
    // (undocumented)
    red = 255,
    // (undocumented)
    rosyBrown = 9408444,
    // (undocumented)
    royalBlue = 14772545,
    // (undocumented)
    saddleBrown = 1262987,
    // (undocumented)
    salmon = 7504122,
    // (undocumented)
    sandyBrown = 6333684,
    // (undocumented)
    seaGreen = 5737262,
    // (undocumented)
    seaShell = 15660543,
    // (undocumented)
    sienna = 2970272,
    // (undocumented)
    silver = 12632256,
    // (undocumented)
    skyBlue = 15453831,
    // (undocumented)
    slateBlue = 13458026,
    // (undocumented)
    slateGray = 9470064,
    // (undocumented)
    slateGrey = 9470064,
    // (undocumented)
    snow = 16448255,
    // (undocumented)
    springGreen = 8388352,
    // (undocumented)
    steelBlue = 11829830,
    // (undocumented)
    tan = 9221330,
    // (undocumented)
    teal = 8421376,
    // (undocumented)
    thistle = 14204888,
    // (undocumented)
    tomato = 4678655,
    // (undocumented)
    turquoise = 13688896,
    // (undocumented)
    violet = 15631086,
    // (undocumented)
    wheat = 11788021,
    // (undocumented)
    white = 16777215,
    // (undocumented)
    whiteSmoke = 16119285,
    // (undocumented)
    yellow = 65535,
    // (undocumented)
    yellowGreen = 3329434
}

// @public
export class ColorDef {
    constructor(val?: string | ColorDefProps);
    adjustForContrast(other: ColorDef, alpha?: number): ColorDef;
    static readonly black: ColorDef;
    static readonly blue: ColorDef;
    clone(result?: ColorDef): ColorDef;
    get colors(): {
        b: number;
        g: number;
        r: number;
        t: number;
    };
    equals(other: ColorDef): boolean;
    static from(red: number, green: number, blue: number, transparency?: number, result?: ColorDef): ColorDef;
    static fromHSL(h: number, s: number, l: number, out?: ColorDef): ColorDef;
    static fromHSV(hsv: HSVColor, out?: ColorDef): ColorDef;
    static fromJSON(json?: any): ColorDef;
    getAbgr(): number;
    getAlpha(): number;
    getRgb(): number;
    getTransparency(): number;
    static readonly green: ColorDef;
    invert(): ColorDef;
    get isOpaque(): boolean;
    lerp(color2: ColorDef, weight: number, result?: ColorDef): ColorDef;
    get name(): string | undefined;
    static readonly red: ColorDef;
    static rgb2bgr(val: number): number;
    setAlpha(alpha: number): void;
    setFrom(other: ColorDef): void;
    setTransparency(transparency: number): void;
    get tbgr(): number;
    set tbgr(tbgr: number);
    toHexString(): string;
    toHSL(opt?: HSLColor): HSLColor;
    toHSV(out?: HSVColor): HSVColor;
    toJSON(): ColorDefProps;
    toRgbString(): string;
    static readonly white: ColorDef;
}

// @public
export type ColorDefProps = number | ColorDef;

// @internal (undocumented)
export class ColorIndex {
    constructor();
    // (undocumented)
    get hasAlpha(): boolean;
    // (undocumented)
    initNonUniform(colors: Uint32Array, indices: number[], hasAlpha: boolean): void;
    // (undocumented)
    initUniform(color: ColorDef | number): void;
    // (undocumented)
    get isUniform(): boolean;
    // (undocumented)
    get nonUniform(): NonUniformColor | undefined;
    // (undocumented)
    get numColors(): number;
    // (undocumented)
    reset(): void;
    // (undocumented)
    get uniform(): ColorDef | undefined;
}

// @public
export enum CommonLoggerCategory {
    ElementProps = "imodeljs-common.ElementProps",
    Geometry = "imodeljs-common.Geometry",
    RpcInterfaceBackend = "imodeljs-backend.RpcInterface",
    RpcInterfaceFrontend = "imodeljs-frontend.RpcInterface"
}

// @internal
export function compareIModelTileTreeIds(lhs: IModelTileTreeId, rhs: IModelTileTreeId): number;

// @beta
export enum ComparisonOption {
    // (undocumented)
    Exclusive = 1,
    // (undocumented)
    Inclusive = 0
}

// @internal
export class CompositeTileHeader extends TileHeader {
    constructor(stream: ByteStream);
    // (undocumented)
    get isValid(): boolean;
    // (undocumented)
    readonly length: number;
    // (undocumented)
    readonly tileCount: number;
    // (undocumented)
    readonly tilePosition: number;
}

// @internal
export function computeChildTileProps(parent: TileMetadata, idProvider: ContentIdProvider, root: TileTreeMetadata): {
    children: TileProps[];
    numEmpty: number;
};

// @internal
export function computeChildTileRanges(tile: TileMetadata, root: TileTreeMetadata): Array<{
    range: Range3d;
    isEmpty: boolean;
}>;

// @internal
export abstract class ContentIdProvider {
    // (undocumented)
    protected abstract computeId(depth: number, i: number, j: number, k: number, mult: number): string;
    static create(allowInstancing: boolean, options: TileOptions, formatVersion?: number): ContentIdProvider;
    // (undocumented)
    idFromParentAndMultiplier(parentId: string, multiplier: number): string;
    // (undocumented)
    idFromSpec(spec: ContentIdSpec): string;
    // (undocumented)
    protected join(depth: number, i: number, j: number, k: number, mult: number): string;
    // (undocumented)
    get rootContentId(): string;
    // (undocumented)
    protected abstract get _separator(): string;
    // (undocumented)
    specFromId(id: string): ContentIdSpec;
}

// @public
export interface ContextRealityModelProps {
    // @beta (undocumented)
    classifiers?: SpatialClassificationProps.Properties[];
    // (undocumented)
    description?: string;
    // (undocumented)
    name?: string;
    // (undocumented)
    tilesetUrl: string;
}

// @public
export interface CreateIModelProps extends IModelProps {
    client?: string;
    guid?: GuidString;
    // @alpha
    thumbnail?: ThumbnailProps;
}

// @internal (undocumented)
export const CURRENT_INVOCATION: unique symbol;

// @internal (undocumented)
export const CURRENT_REQUEST: unique symbol;

// @internal
export const enum CurrentImdlVersion {
    Combined = 458752,
    Major = 7,
    Minor = 0
}

// @beta
export interface CustomAttribute {
    ecclass: string;
    properties: {
        [propName: string]: any;
    };
}

export { DbResult }

// @beta
export interface DecorationGeometryProps {
    // (undocumented)
    readonly geometryStream: GeometryStreamProps;
    // (undocumented)
    readonly id: Id64String;
}

// @alpha
export const defaultOidcDesktopClientExpiryBuffer: number;

// @public
export interface DefinitionElementProps extends ElementProps {
    // (undocumented)
    isPrivate?: boolean;
}

// @internal
export abstract class DevToolsRpcInterface extends RpcInterface {
    static getClient(): DevToolsRpcInterface;
    static readonly interfaceName = "DevToolsRpcInterface";
    static interfaceVersion: string;
    // (undocumented)
    ping(_iModelToken: IModelTokenProps): Promise<boolean>;
    // (undocumented)
    setLogLevel(_iModelToken: IModelTokenProps, _loggerCategory: string, _logLevel: LogLevel): Promise<LogLevel | undefined>;
    // (undocumented)
    stats(_iModelToken: IModelTokenProps, _options: DevToolsStatsOptions): Promise<any>;
    // (undocumented)
    versions(_iModelToken: IModelTokenProps): Promise<any>;
}

// @internal
export enum DevToolsStatsOptions {
    FormatUnits = 1,
    // (undocumented)
    None = 0
}

// @public
export interface DisplayStyle3dProps extends DisplayStyleProps {
    jsonProperties?: {
        styles?: DisplayStyle3dSettingsProps;
    };
}

// @beta
export class DisplayStyle3dSettings extends DisplayStyleSettings {
    constructor(jsonProperties: {
        styles?: DisplayStyle3dSettingsProps;
    });
    get ambientOcclusionSettings(): AmbientOcclusion.Settings;
    set ambientOcclusionSettings(ao: AmbientOcclusion.Settings);
    // @internal (undocumented)
    get environment(): EnvironmentProps;
    set environment(environment: EnvironmentProps);
    // @alpha (undocumented)
    getPlanProjectionSettings(modelId: Id64String): PlanProjectionSettings | undefined;
    get hiddenLineSettings(): HiddenLine.Settings;
    set hiddenLineSettings(hline: HiddenLine.Settings);
    // @alpha (undocumented)
    get planProjectionSettings(): Iterable<[Id64String, PlanProjectionSettings]> | undefined;
    // @alpha (undocumented)
    setPlanProjectionSettings(modelId: Id64String, settings: PlanProjectionSettings | undefined): void;
    get solarShadowsSettings(): SolarShadows.Settings;
    set solarShadowsSettings(solarShadows: SolarShadows.Settings);
    // @internal (undocumented)
    get sunDir(): Vector3d | undefined;
    set sunDir(dir: Vector3d | undefined);
    // @internal (undocumented)
    toJSON(): DisplayStyle3dSettingsProps;
}

// @public
export interface DisplayStyle3dSettingsProps extends DisplayStyleSettingsProps {
    // @beta
    ao?: AmbientOcclusion.Props;
    environment?: EnvironmentProps;
    // @beta
    hline?: HiddenLine.SettingsProps;
    // @alpha
    planProjections?: {
        [modelId: string]: PlanProjectionSettingsProps;
    };
    // @alpha
    sceneLights?: SceneLightsProps;
    // @beta
    solarShadows?: SolarShadows.Props;
}

// @public
export interface DisplayStyleProps extends DefinitionElementProps {
    jsonProperties?: {
        styles?: DisplayStyleSettingsProps;
    };
}

// @beta
export class DisplayStyleSettings {
    constructor(jsonProperties: {
        styles?: DisplayStyleSettingsProps;
    });
    addExcludedElements(id: Id64String): void;
    get backgroundColor(): ColorDef;
    set backgroundColor(color: ColorDef);
    // @alpha (undocumented)
    get backgroundMap(): BackgroundMapSettings;
    set backgroundMap(map: BackgroundMapSettings);
    dropExcludedElement(id: Id64String): void;
    dropSubCategoryOverride(id: Id64String): void;
    // @internal (undocumented)
    equalSubCategoryOverrides(other: DisplayStyleSettings): boolean;
    get excludedElements(): Set<Id64String>;
    getSubCategoryOverride(id: Id64String): SubCategoryOverride | undefined;
    get hasSubCategoryOverride(): boolean;
    // (undocumented)
    protected readonly _json: DisplayStyleSettingsProps;
    get monochromeColor(): ColorDef;
    set monochromeColor(color: ColorDef);
    overrideSubCategory(id: Id64String, ovr: SubCategoryOverride): void;
    get subCategoryOverrides(): Map<Id64String, SubCategoryOverride>;
    // @internal (undocumented)
    toJSON(): DisplayStyleSettingsProps;
    get viewFlags(): ViewFlags;
    set viewFlags(flags: ViewFlags);
    }

// @public
export interface DisplayStyleSettingsProps {
    // @alpha
    analysisStyle?: AnalysisStyleProps;
    backgroundColor?: ColorDefProps;
    backgroundMap?: BackgroundMapProps;
    contextRealityModels?: ContextRealityModelProps[];
    excludedElements?: Id64String[];
    monochromeColor?: ColorDefProps;
    // @beta
    scheduleScript?: RenderSchedule.ModelTimelineProps[];
    subCategoryOvr?: DisplayStyleSubCategoryProps[];
    // (undocumented)
    viewflags?: ViewFlagProps;
}

// @public
export interface DisplayStyleSubCategoryProps extends SubCategoryAppearance.Props {
    subCategory?: Id64String;
}

// @beta
export interface DistanceExpressionProps {
    // (undocumented)
    distanceAlongFromReferent?: number;
    // (undocumented)
    distanceAlongFromStart: number;
    // (undocumented)
    lateralOffsetFromILinearElement?: number;
    // (undocumented)
    verticalOffsetFromILinearElement?: number;
}

// @beta
export type DPoint2dProps = number[];

// @beta
export const Easing: {
    Linear: {
        None: (k: number) => number;
    };
    Quadratic: {
        In: (k: number) => number;
        Out: (k: number) => number;
        InOut: (k: number) => number;
    };
    Cubic: {
        In: (k: number) => number;
        Out: (k: number) => number;
        InOut: (k: number) => number;
    };
    Quartic: {
        In: (k: number) => number;
        Out: (k: number) => number;
        InOut: (k: number) => number;
    };
    Quintic: {
        In: (k: number) => number;
        Out: (k: number) => number;
        InOut: (k: number) => number;
    };
    Sinusoidal: {
        In: (k: number) => number;
        Out: (k: number) => number;
        InOut: (k: number) => number;
    };
    Exponential: {
        In: (k: number) => number;
        Out: (k: number) => number;
        InOut: (k: number) => number;
    };
    Circular: {
        In: (k: number) => number;
        Out: (k: number) => number;
        InOut: (k: number) => number;
    };
    Elastic: {
        In: (k: number) => number;
        Out: (k: number) => number;
        InOut: (k: number) => number;
    };
    Back: {
        In: (k: number) => number;
        Out: (k: number) => number;
        InOut: (k: number) => number;
    };
    Bounce: {
        In: (k: number) => number;
        Out: (k: number) => number;
        InOut: (k: number) => number;
    };
};

// @beta (undocumented)
export type EasingFunction = (k: number) => number;

// @public
export class EcefLocation implements EcefLocationProps {
    constructor(props: EcefLocationProps);
    static createFromCartographicOrigin(origin: Cartographic, point?: Point3d, angle?: Angle): EcefLocation;
    getTransform(): Transform;
    readonly orientation: YawPitchRollAngles;
    readonly origin: Point3d;
}

// @public
export interface EcefLocationProps {
    orientation: YawPitchRollProps;
    origin: XYZProps;
}

// @public
export class ECJsNames {
    static systemPropertyToJsName(systemPropertyType: ECSqlSystemProperty): string;
    static toJsName(propName: string, isSystemProperty?: boolean): string;
}

// @public
export enum ECSqlSystemProperty {
    // (undocumented)
    ECClassId = 1,
    // (undocumented)
    ECInstanceId = 0,
    // (undocumented)
    NavigationId = 6,
    // (undocumented)
    NavigationRelClassId = 7,
    // (undocumented)
    PointX = 8,
    // (undocumented)
    PointY = 9,
    // (undocumented)
    PointZ = 10,
    // (undocumented)
    SourceECClassId = 3,
    // (undocumented)
    SourceECInstanceId = 2,
    // (undocumented)
    TargetECClassId = 5,
    // (undocumented)
    TargetECInstanceId = 4
}

// @public
export enum ECSqlValueType {
    // (undocumented)
    Blob = 1,
    // (undocumented)
    Boolean = 2,
    // (undocumented)
    DateTime = 3,
    // (undocumented)
    Double = 4,
    // (undocumented)
    Geometry = 5,
    // (undocumented)
    Guid = 16,
    // (undocumented)
    Id = 6,
    // (undocumented)
    Int = 7,
    // (undocumented)
    Int64 = 8,
    // (undocumented)
    Navigation = 12,
    // (undocumented)
    Point2d = 9,
    // (undocumented)
    Point3d = 10,
    // (undocumented)
    PrimitiveArray = 14,
    // (undocumented)
    String = 11,
    // (undocumented)
    Struct = 13,
    // (undocumented)
    StructArray = 15
}

// @internal (undocumented)
export class EdgeArgs {
    // (undocumented)
    clear(): void;
    // (undocumented)
    edges?: MeshEdge[];
    // (undocumented)
    init(meshEdges?: MeshEdges): boolean;
    // (undocumented)
    get isValid(): boolean;
    // (undocumented)
    get numEdges(): number;
}

// @beta
export abstract class ElectronRpcConfiguration extends RpcConfiguration {
    // (undocumented)
    static get isElectron(): boolean;
    abstract protocol: ElectronRpcProtocol;
}

// @beta
export class ElectronRpcManager extends RpcManager {
    static initializeClient(params: ElectronRpcParams, interfaces: RpcInterfaceDefinition[]): ElectronRpcConfiguration;
    static initializeImpl(params: ElectronRpcParams, interfaces: RpcInterfaceDefinition[]): ElectronRpcConfiguration;
    }

// @beta
export interface ElectronRpcParams {
    // (undocumented)
    protocol?: typeof ElectronRpcProtocol;
}

// @beta
export class ElectronRpcProtocol extends RpcProtocol {
    constructor(configuration: ElectronRpcConfiguration);
    // (undocumented)
    static instances: Map<string, ElectronRpcProtocol>;
    // @internal (undocumented)
    onRpcClientInitialized(definition: RpcInterfaceDefinition, _client: RpcInterface): void;
    // @internal (undocumented)
    onRpcClientTerminated(definition: RpcInterfaceDefinition, _client: RpcInterface): void;
    // @internal (undocumented)
    onRpcImplInitialized(definition: RpcInterfaceDefinition, _impl: RpcInterface): void;
    // @internal (undocumented)
    onRpcImplTerminated(definition: RpcInterfaceDefinition, _impl: RpcInterface): void;
    // @internal (undocumented)
    requests: Map<string, ElectronRpcRequest>;
    readonly requestType: typeof ElectronRpcRequest;
    transferChunkThreshold: number;
    // @internal (undocumented)
    readonly transport: ElectronIpcTransport<IpcTransportMessage, IpcTransportMessage>;
}

// @beta (undocumented)
export class ElectronRpcRequest extends RpcRequest {
    protected load(): Promise<import("../core/RpcMarshaling").RpcSerializedValue>;
    // @internal (undocumented)
    notifyResponse(fulfillment: RpcRequestFulfillment): void;
    readonly protocol: ElectronRpcProtocol;
    protected send(): Promise<number>;
    protected setHeader(_name: string, _value: string): void;
}

// @public
export type ElementAlignedBox2d = Range2d;

// @public
export type ElementAlignedBox3d = Range3d;

// @public
export interface ElementAspectProps extends EntityProps {
    // (undocumented)
    element: RelatedElementProps;
}

// @public
export interface ElementLoadProps {
    // (undocumented)
    code?: CodeProps;
    // (undocumented)
    federationGuid?: GuidString;
    // (undocumented)
    id?: Id64String;
    wantBRepData?: boolean;
    wantGeometry?: boolean;
}

// @public
export interface ElementProps extends EntityProps {
    code: CodeProps;
    federationGuid?: GuidString;
    jsonProperties?: any;
    model: Id64String;
    parent?: RelatedElementProps;
    userLabel?: string;
}

// @beta
export class EntityMetaData implements EntityMetaDataProps {
    constructor(jsonObj: EntityMetaDataProps);
    readonly baseClasses: string[];
    readonly customAttributes?: CustomAttribute[];
    // (undocumented)
    readonly description?: string;
    // (undocumented)
    readonly displayLabel?: string;
    readonly ecclass: string;
    // (undocumented)
    readonly modifier?: string;
    readonly properties: {
        [propName: string]: PropertyMetaData;
    };
}

// @beta (undocumented)
export interface EntityMetaDataProps {
    baseClasses: string[];
    customAttributes?: CustomAttribute[];
    // (undocumented)
    description?: string;
    // (undocumented)
    displayLabel?: string;
    // (undocumented)
    ecclass: string;
    // (undocumented)
    modifier?: string;
    properties: {
        [propName: string]: PropertyMetaData;
    };
}

// @public
export interface EntityProps {
    classFullName: string;
    id?: Id64String;
    jsonProperties?: {
        [key: string]: any;
    };
}

// @public
export interface EntityQueryParams {
    from?: string;
    limit?: number;
    offset?: number;
    only?: boolean;
    orderBy?: string;
    where?: string;
}

// @public
export interface EnvironmentProps {
    // (undocumented)
    ground?: GroundPlaneProps;
    // (undocumented)
    sky?: SkyBoxProps;
}

// @public
export interface ExternalSourceAspectProps extends ElementAspectProps {
    checksum?: string;
    identifier: string;
    jsonProperties?: any;
    kind: string;
    scope: RelatedElementProps;
    version?: string;
}

// @public
export class Feature {
    constructor(elementId?: Id64String, subCategoryId?: Id64String, geometryClass?: GeometryClass);
    compare(rhs: Feature): number;
    // (undocumented)
    readonly elementId: string;
    equals(other: Feature): boolean;
    // (undocumented)
    readonly geometryClass: GeometryClass;
    // (undocumented)
    get isDefined(): boolean;
    // (undocumented)
    get isUndefined(): boolean;
    // (undocumented)
    readonly subCategoryId: string;
}

// @internal
export class FeatureGates {
    addMonitor(feature: string, monitor: (val: GateValue) => void): () => void;
    check(feature: string, defaultVal?: GateValue): GateValue;
    readonly gates: Map<string, GateValue>;
    onChanged: BeEvent<(feature: string, val: GateValue) => void>;
    setGate(feature: string, val: GateValue): void;
}

// @internal (undocumented)
export class FeatureIndex {
    constructor();
    // (undocumented)
    featureID: number;
    // (undocumented)
    featureIDs?: Uint32Array;
    // (undocumented)
    get isEmpty(): boolean;
    // (undocumented)
    get isUniform(): boolean;
    // (undocumented)
    reset(): void;
    // (undocumented)
    type: FeatureIndexType;
}

// @internal (undocumented)
export enum FeatureIndexType {
    // (undocumented)
    Empty = 0,
    // (undocumented)
    NonUniform = 2,
    // (undocumented)
    Uniform = 1
}

// @beta
export class FeatureTable extends IndexMap<Feature> {
    constructor(maxFeatures: number, modelId?: Id64String, type?: BatchType);
    // @internal (undocumented)
    get anyDefined(): boolean;
    findFeature(index: number): Feature | undefined;
    // @internal (undocumented)
    getArray(): Array<IndexedValue<Feature>>;
    // @internal (undocumented)
    insertWithIndex(feature: Feature, index: number): void;
    get isPlanarClassifier(): boolean;
    get isUniform(): boolean;
    get isVolumeClassifier(): boolean;
    get maxFeatures(): number;
    // (undocumented)
    readonly modelId: Id64String;
    // (undocumented)
    readonly type: BatchType;
    get uniform(): Feature | undefined;
}

// @internal
export class FeatureTableHeader {
    // (undocumented)
    readonly count: number;
    // (undocumented)
    readonly length: number;
    // (undocumented)
    readonly maxFeatures: number;
    // (undocumented)
    static readFrom(stream: ByteStream): FeatureTableHeader | undefined;
    // (undocumented)
    static sizeInBytes: number;
}

// @public (undocumented)
export interface FilePropertyProps {
    // (undocumented)
    id?: number | string;
    // (undocumented)
    name: string;
    // (undocumented)
    namespace: string;
    // (undocumented)
    subId?: number | string;
}

// @public
export enum FillDisplay {
    Always = 2,
    Blanking = 3,
    ByView = 1,
    Never = 0
}

// @public
export enum FillFlags {
    Always = 2,
    Background = 8,
    Behind = 4,
    Blanking = 6,
    ByView = 1,
    None = 0
}

// @public
export class FontMap {
    constructor(props?: FontMapProps);
    // (undocumented)
    addFonts(fonts: FontProps[]): void;
    // (undocumented)
    readonly fonts: Map<number, FontProps>;
    getFont(arg: string | number): FontProps | undefined;
    // (undocumented)
    toJSON(): FontMapProps;
}

// @public
export interface FontMapProps {
    // (undocumented)
    fonts: FontProps[];
}

// @public
export interface FontProps {
    // (undocumented)
    id: number;
    // (undocumented)
    name: string;
    // (undocumented)
    type: FontType;
}

// @public
export enum FontType {
    // (undocumented)
    Rsc = 2,
    // (undocumented)
    Shx = 3,
    // (undocumented)
    TrueType = 1
}

// @internal (undocumented)
export interface FormDataCommon {
    // (undocumented)
    append(name: string, value: string | Blob | Buffer, fileName?: string): void;
}

// @public
export class Frustum {
    constructor();
    clone(result?: Frustum): Frustum;
    distance(corner1: number, corner2: number): number;
    equals(rhs: Frustum): boolean;
    fixPointOrder(): void;
    static fromRange(range: LowAndHighXYZ | LowAndHighXY, out?: Frustum): Frustum;
    getCenter(): Point3d;
    getCorner(i: number): Point3d;
    getFraction(): number;
    getRangePlanes(clipFront: boolean, clipBack: boolean, expandPlaneDistance: number): ConvexClipPlaneSet;
    get hasMirror(): boolean;
    initFromRange(range: LowAndHighXYZ | LowAndHighXY): void;
    initNpc(): this;
    invalidate(): void;
    isSame(other: Frustum): boolean;
    multiply(trans: Transform): void;
    readonly points: Point3d[];
    scaleAboutCenter(scale: number): void;
    setFrom(other: Frustum): void;
    toMap4d(): Map4d | undefined;
    toRange(range?: Range3d): Range3d;
    transformBy(trans: Transform, result?: Frustum): Frustum;
    translate(offset: XYAndZ): void;
}

// @internal
export class FrustumPlanes {
    constructor(frustum?: Frustum);
    // (undocumented)
    computeContainment(points: Point3d[], sphere?: BoundingSphere, tolerance?: number): FrustumPlanes.Containment;
    // (undocumented)
    computeFrustumContainment(box: Frustum, sphere?: BoundingSphere): FrustumPlanes.Containment;
    // (undocumented)
    containsPoint(point: Point3d, tolerance?: number): boolean;
    // (undocumented)
    init(frustum: Frustum): void;
    // (undocumented)
    intersectsFrustum(box: Frustum): boolean;
    // (undocumented)
    intersectsRay(origin: Point3d, direction: Vector3d): boolean;
    // (undocumented)
    get isValid(): boolean;
    // (undocumented)
    get planes(): ClipPlane[] | undefined;
    }

// @internal (undocumented)
export namespace FrustumPlanes {
    // (undocumented)
    export function addPlaneFromPoints(planes: ClipPlane[], points: Point3d[], i0: number, i1: number, i2: number, expandPlaneDistance?: number): void;
    // (undocumented)
    export const enum Containment {
        // (undocumented)
        Inside = 2,
        // (undocumented)
        Outside = 0,
        // (undocumented)
        Partial = 1
    }
}

// @public (undocumented)
export interface FunctionalElementProps extends ElementProps {
    // (undocumented)
    typeDefinition?: RelatedElementProps;
}

// @internal (undocumented)
export type GateValue = number | boolean | string | undefined;

// @beta
export interface GeoCoordinatesRequestProps {
    // (undocumented)
    iModelCoords: XYZProps[];
    // (undocumented)
    targetDatum: string;
}

// @beta
export interface GeoCoordinatesResponseProps {
    // (undocumented)
    fromCache: number;
    // (undocumented)
    geoCoords: PointWithStatus[];
}

// @public (undocumented)
export enum GeoCoordStatus {
    // (undocumented)
    CSMapError = 4096,
    // (undocumented)
    NoDatumConverter = 25,
    // (undocumented)
    NoGCSDefined = 100,
    // (undocumented)
    OutOfMathematicalDomain = 2,
    // (undocumented)
    OutOfUsefulRange = 1,
    // (undocumented)
    Pending = -41556,
    // (undocumented)
    Success = 0,
    // (undocumented)
    VerticalDatumConvertError = 26
}

// @public
export interface GeometricElement2dProps extends GeometricElementProps {
    // (undocumented)
    placement?: Placement2dProps;
    // (undocumented)
    typeDefinition?: RelatedElementProps;
}

// @public
export interface GeometricElement3dProps extends GeometricElementProps {
    // (undocumented)
    placement?: Placement3dProps;
    // (undocumented)
    typeDefinition?: RelatedElementProps;
}

// @public
export interface GeometricElementProps extends ElementProps {
    category: Id64String;
    // (undocumented)
    geom?: GeometryStreamProps;
}

// @public
export interface GeometricModel2dProps extends GeometricModelProps {
    globalOrigin?: XYProps;
}

// @public
export interface GeometricModel3dProps extends GeometricModelProps {
    isNotSpatiallyLocated?: boolean;
    isPlanProjection?: boolean;
}

// @public
export interface GeometricModelProps extends ModelProps {
    geometryGuid?: GuidString;
}

// @public
export interface GeometryAppearanceProps {
    color?: ColorDefProps;
    displayPriority?: number;
    // @alpha
    geometryClass?: GeometryClass;
    style?: Id64String;
    subCategory?: Id64String;
    transparency?: number;
    weight?: number;
}

// @public
export enum GeometryClass {
    Construction = 1,
    Dimension = 2,
    Pattern = 3,
    Primary = 0
}

// @public
export class GeometryParams {
    constructor(categoryId: Id64String, subCategoryId?: string);
    backgroundFill?: BackgroundFill;
    // (undocumented)
    categoryId: Id64String;
    // (undocumented)
    clone(): GeometryParams;
    elmPriority?: number;
    elmTransparency?: number;
    fillColor?: ColorDef;
    fillDisplay?: FillDisplay;
    fillTransparency?: number;
    geometryClass?: GeometryClass;
    // @beta
    gradient?: Gradient.Symb;
    isEquivalent(other: GeometryParams): boolean;
    lineColor?: ColorDef;
    materialId?: Id64String;
    pattern?: AreaPattern.Params;
    resetAppearance(): void;
    setCategoryId(categoryId: Id64String, clearAppearanceOverrides?: boolean): void;
    setSubCategoryId(subCategoryId: Id64String, clearAppearanceOverrides?: boolean): void;
    styleInfo?: LineStyle.Info;
    // (undocumented)
    subCategoryId: string;
    weight?: number;
}

// @public
export interface GeometryPartInstanceProps {
    origin?: XYZProps;
    part: Id64String;
    rotation?: YawPitchRollProps;
    scale?: number;
}

// @public
export interface GeometryPartProps extends ElementProps {
    // (undocumented)
    bbox?: LowAndHighXYZ;
    // (undocumented)
    geom?: GeometryStreamProps;
}

// @public
export class GeometryStreamBuilder {
    // @beta
    appendBRepData(brep: BRepEntity.DataProps): boolean;
    appendGeometry(geometry: GeometryQuery): boolean;
    appendGeometryParamsChange(geomParams: GeometryParams): boolean;
    appendGeometryPart2d(partId: Id64String, instanceOrigin?: Point2d, instanceRotation?: Angle, instanceScale?: number): boolean;
    appendGeometryPart3d(partId: Id64String, instanceOrigin?: Point3d, instanceRotation?: YawPitchRollAngles, instanceScale?: number): boolean;
    appendGeometryRanges(): void;
    // @beta
    appendImage(image: ImageGraphic): boolean;
    appendSubCategoryChange(subCategoryId: Id64String): boolean;
    appendTextString(textString: TextString): boolean;
    readonly geometryStream: GeometryStreamProps;
    // @internal (undocumented)
    getHeader(): GeometryStreamHeaderProps | undefined;
    get isViewIndependent(): boolean;
    set isViewIndependent(viewIndependent: boolean);
    // @internal (undocumented)
    obtainHeader(): GeometryStreamHeaderProps;
    setLocalToWorld(localToWorld?: Transform): void;
    setLocalToWorld2d(origin: Point2d, angle?: Angle): void;
    setLocalToWorld3d(origin: Point3d, angles?: YawPitchRollAngles): void;
    }

// @public
export interface GeometryStreamEntryProps extends IModelJson.GeometryProps {
    // (undocumented)
    appearance?: GeometryAppearanceProps;
    // @beta (undocumented)
    brep?: BRepEntity.DataProps;
    // (undocumented)
    fill?: AreaFillProps;
    // (undocumented)
    geomPart?: GeometryPartInstanceProps;
    // (undocumented)
    header?: GeometryStreamHeaderProps;
    // @beta (undocumented)
    image?: ImageGraphicProps;
    // (undocumented)
    material?: MaterialProps;
    // (undocumented)
    pattern?: AreaPattern.ParamsProps;
    // (undocumented)
    styleMod?: LineStyle.ModifierProps;
    // (undocumented)
    subRange?: LowAndHighXYZ;
    // (undocumented)
    textString?: TextStringProps;
}

// @public
export enum GeometryStreamFlags {
    None = 0,
    ViewIndependent = 1
}

// @public
export interface GeometryStreamHeaderProps {
    flags: GeometryStreamFlags;
}

// @public
export class GeometryStreamIterator implements IterableIterator<GeometryStreamIteratorEntry> {
    // (undocumented)
    [Symbol.iterator](): IterableIterator<GeometryStreamIteratorEntry>;
    constructor(geometryStream: GeometryStreamProps, category?: Id64String);
    entry: GeometryStreamIteratorEntry;
    readonly flags: GeometryStreamFlags;
    static fromGeometricElement2d(element: GeometricElement2dProps): GeometryStreamIterator;
    static fromGeometricElement3d(element: GeometricElement3dProps): GeometryStreamIterator;
    static fromGeometryPart(geomPart: GeometryPartProps, geomParams?: GeometryParams, partTransform?: Transform): GeometryStreamIterator;
    geometryStream: GeometryStreamProps;
    // @internal (undocumented)
    get isViewIndependent(): boolean;
    next(): IteratorResult<GeometryStreamIteratorEntry>;
    partToWorld(): Transform | undefined;
    setLocalToWorld(localToWorld?: Transform): void;
    setLocalToWorld2d(origin: Point2d, angle?: Angle): void;
    setLocalToWorld3d(origin: Point3d, angles?: YawPitchRollAngles): void;
}

// @public
export class GeometryStreamIteratorEntry {
    constructor(category?: Id64String);
    // @beta
    brep?: BRepEntity.DataProps;
    geometryQuery?: AnyGeometryQuery;
    geomParams: GeometryParams;
    // @beta
    image?: ImageGraphic;
    localRange?: Range3d;
    localToWorld?: Transform;
    partId?: Id64String;
    partToLocal?: Transform;
    get primitive(): GeometryStreamIteratorEntry.Primitive;
    textString?: TextString;
}

// @public (undocumented)
export namespace GeometryStreamIteratorEntry {
    export interface BRepPrimitive {
        // @beta (undocumented)
        readonly brep: BRepEntity.DataProps;
        // (undocumented)
        type: "brep";
    }
    export interface GeometryPrimitive {
        // (undocumented)
        readonly geometry: AnyGeometryQuery;
        // (undocumented)
        type: "geometryQuery";
    }
    export interface ImagePrimitive {
        // @beta (undocumented)
        readonly image: ImageGraphic;
        // (undocumented)
        type: "image";
    }
    export interface PartReference {
        // (undocumented)
        part: {
            id: Id64String;
            readonly toLocal?: Transform;
        };
        // (undocumented)
        type: "partReference";
    }
    export type Primitive = TextStringPrimitive | PartReference | BRepPrimitive | GeometryPrimitive | ImagePrimitive;
    export interface TextStringPrimitive {
        // (undocumented)
        readonly textString: TextString;
        // (undocumented)
        type: "textString";
    }
}

// @public
export type GeometryStreamProps = GeometryStreamEntryProps[];

// @alpha
export interface GeometrySummaryOptions {
    geometryVerbosity?: GeometrySummaryVerbosity;
    includePartReferences?: "2d" | "3d";
    includePlacement?: boolean;
    verboseSymbology?: boolean;
}

// @alpha
export interface GeometrySummaryRequestProps {
    elementIds: Id64Array;
    options?: GeometrySummaryOptions;
}

// @alpha
export enum GeometrySummaryVerbosity {
    Basic = 10,
    Detailed = 20,
    Full = 30
}

// @internal (undocumented)
export function getMaximumMajorTileFormatVersion(maxMajorVersion: number, formatVersion?: number): number;

export { GetMetaDataFunction }

// @internal
export class GltfBufferData {
    constructor(buffer: GltfDataBuffer, count: number);
    // (undocumented)
    readonly buffer: GltfDataBuffer;
    // (undocumented)
    readonly count: number;
    static create(bytes: Uint8Array, actualType: GltfDataType, expectedType: GltfDataType, count: number): GltfBufferData | undefined;
    }

// @internal
export class GltfBufferView {
    constructor(data: Uint8Array, count: number, type: GltfDataType, accessor: any);
    // (undocumented)
    readonly accessor: any;
    // (undocumented)
    get byteLength(): number;
    // (undocumented)
    readonly count: number;
    // (undocumented)
    readonly data: Uint8Array;
    // (undocumented)
    toBufferData(desiredType: GltfDataType): GltfBufferData | undefined;
    // (undocumented)
    readonly type: GltfDataType;
}

// @internal (undocumented)
export const enum GltfConstants {
    // (undocumented)
    ArrayBuffer = 34962,
    // (undocumented)
    ClampToEdge = 33071,
    // (undocumented)
    CullFace = 2884,
    // (undocumented)
    DepthTest = 2929,
    // (undocumented)
    ElementArrayBuffer = 34963,
    // (undocumented)
    FragmentShader = 35632,
    // (undocumented)
    Linear = 9729,
    // (undocumented)
    LinearMipmapLinear = 9987,
    // (undocumented)
    Nearest = 9728,
    // (undocumented)
    VertexShader = 35633
}

// @internal (undocumented)
export type GltfDataBuffer = Uint8Array | Uint16Array | Uint32Array | Float32Array;

// @internal (undocumented)
export const enum GltfDataType {
    // (undocumented)
    Float = 5126,
    // (undocumented)
    UInt32 = 5125,
    // (undocumented)
    UnsignedByte = 5121,
    // (undocumented)
    UnsignedShort = 5123
}

// @internal
export class GltfHeader extends TileHeader {
    constructor(stream: ByteStream);
    // (undocumented)
    readonly binaryPosition: number;
    // (undocumented)
    readonly gltfLength: number;
    // (undocumented)
    get isValid(): boolean;
    // (undocumented)
    readonly scenePosition: number;
    // (undocumented)
    readonly sceneStrLength: number;
}

// @internal (undocumented)
export const enum GltfMeshMode {
    // (undocumented)
    Lines = 1,
    // (undocumented)
    LineStrip = 3,
    // (undocumented)
    Triangles = 4
}

// @internal (undocumented)
export const enum GltfV2ChunkTypes {
    // (undocumented)
    Binary = 5130562,
    // (undocumented)
    JSON = 1313821514
}

// @internal
export const enum GltfVersions {
    // (undocumented)
    CurrentVersion = 1,
    // (undocumented)
    Gltf1SceneFormat = 0,
    // (undocumented)
    Version1 = 1,
    // (undocumented)
    Version2 = 2
}

// @beta (undocumented)
export namespace Gradient {
    export enum Flags {
        Invert = 1,
        None = 0,
        Outline = 2
    }
    export class KeyColor implements KeyColorProps {
        constructor(json: KeyColorProps);
        // (undocumented)
        color: ColorDef;
        // (undocumented)
        value: number;
    }
    export interface KeyColorProps {
        color: ColorDefProps;
        value: number;
    }
    export enum Mode {
        // (undocumented)
        Curved = 2,
        // (undocumented)
        Cylindrical = 3,
        // (undocumented)
        Hemispherical = 5,
        // (undocumented)
        Linear = 1,
        // (undocumented)
        None = 0,
        // (undocumented)
        Spherical = 4,
        // (undocumented)
        Thematic = 6
    }
    export class Symb implements SymbProps {
        // (undocumented)
        angle?: Angle;
        // (undocumented)
        clone(): Symb;
        compare(other: Symb): number;
        static compareSymb(lhs: Gradient.Symb, rhs: Gradient.Symb): number;
        // (undocumented)
        static createThematic(settings: ThematicSettings): Symb;
        equals(other: Symb): boolean;
        // (undocumented)
        flags: Flags;
        static fromJSON(json?: SymbProps): Symb;
        getImage(width: number, height: number): ImageBuffer;
        // (undocumented)
        get hasTranslucency(): boolean;
        get isOutlined(): boolean;
        // (undocumented)
        keys: KeyColor[];
        mapColor(value: number): ColorDef;
        // (undocumented)
        mode: Mode;
        // (undocumented)
        shift: number;
        // (undocumented)
        thematicSettings?: ThematicSettings;
        // (undocumented)
        tint?: number;
    }
    export interface SymbProps {
        angle?: AngleProps;
        flags?: Flags;
        keys: KeyColorProps[];
        mode: Mode;
        shift?: number;
        thematicSettings?: ThematicSettingsProps;
        tint?: number;
    }
    // @internal (undocumented)
    export enum ThematicColorScheme {
        // (undocumented)
        BlueRed = 0,
        // (undocumented)
        Custom = 5,
        // (undocumented)
        Monochrome = 2,
        // (undocumented)
        RedBlue = 1,
        // (undocumented)
        SeaMountain = 4,
        // (undocumented)
        Topographic = 3
    }
    // (undocumented)
    export enum ThematicMode {
        // (undocumented)
        IsoLines = 3,
        // (undocumented)
        Smooth = 0,
        // (undocumented)
        Stepped = 1,
        // (undocumented)
        SteppedWithDelimiter = 2
    }
    export class ThematicSettings implements ThematicSettingsProps {
        // (undocumented)
        clone(out?: ThematicSettings): ThematicSettings;
        // (undocumented)
        colorScheme: number;
        // (undocumented)
        static get contentMax(): number;
        // (undocumented)
        static get contentRange(): number;
        // (undocumented)
        copyFrom(other: ThematicSettingsProps): void;
        // (undocumented)
        static defaults: ThematicSettings;
        // (undocumented)
        static fromJSON(json: ThematicSettingsProps): ThematicSettings;
        // (undocumented)
        static get margin(): number;
        // (undocumented)
        marginColor: ColorDef;
        // (undocumented)
        mode: ThematicMode;
        // (undocumented)
        get range(): Range1d;
        set range(range: Range1d);
        // (undocumented)
        rangeHigh: number;
        // (undocumented)
        rangeLow: number;
        // (undocumented)
        stepCount: number;
    }
    // (undocumented)
    export interface ThematicSettingsProps {
        // (undocumented)
        colorScheme: number;
        // (undocumented)
        marginColor: ColorDefProps;
        // (undocumented)
        mode: ThematicMode;
        // (undocumented)
        rangeHigh: number;
        // (undocumented)
        rangeLow: number;
        // (undocumented)
        stepCount: number;
    }
}

// @beta
export class GraphicParams {
    // (undocumented)
    readonly fillColor: ColorDef;
    // (undocumented)
    fillFlags: FillFlags;
    // (undocumented)
    static fromBlankingFill(fillColor: ColorDef): GraphicParams;
    // (undocumented)
    static fromSymbology(lineColor: ColorDef, fillColor: ColorDef, lineWidth: number, linePixels?: LinePixels): GraphicParams;
    // (undocumented)
    gradient?: Gradient.Symb;
    // (undocumented)
    readonly lineColor: ColorDef;
    // (undocumented)
    linePixels: LinePixels;
    // (undocumented)
    lineTexture?: RenderTexture;
    // (undocumented)
    material?: RenderMaterial;
    // (undocumented)
    rasterWidth: number;
    setFillColor(fillColor: ColorDef): void;
    // (undocumented)
    setFillTransparency(transparency: number): void;
    setLineColor(lineColor: ColorDef): void;
    setLinePixels(code: LinePixels): void;
    // (undocumented)
    setLineTransparency(transparency: number): void;
    // (undocumented)
    trueWidthEnd: number;
    // (undocumented)
    trueWidthStart: number;
}

// @public
export class GroundPlane implements GroundPlaneProps {
    constructor(ground?: GroundPlaneProps);
    aboveColor: ColorDef;
    belowColor: ColorDef;
    display: boolean;
    elevation: number;
    // @internal
    getGroundPlaneGradient(aboveGround: boolean): Gradient.Symb;
    // (undocumented)
    toJSON(): GroundPlaneProps;
}

// @public
export interface GroundPlaneProps {
    aboveColor?: ColorDefProps;
    belowColor?: ColorDefProps;
    display?: boolean;
    elevation?: number;
}

// @beta
export namespace HiddenLine {
    export class Settings {
        static defaults: Settings;
        static fromJSON(json?: SettingsProps): Settings;
        readonly hidden: Style;
        override(props: SettingsProps): Settings;
        // (undocumented)
        toJSON(): SettingsProps;
        readonly transparencyThreshold: number;
        // (undocumented)
        get transThreshold(): number;
        readonly visible: Style;
    }
    export interface SettingsProps {
        readonly hidden?: StyleProps;
        readonly transThreshold?: number;
        readonly visible?: StyleProps;
    }
    export class Style implements StyleProps {
        readonly color?: ColorDef;
        // (undocumented)
        static readonly defaultHidden: Style;
        // (undocumented)
        static readonly defaultVisible: Style;
        equals(other: Style): boolean;
        // (undocumented)
        static fromJSON(json?: StyleProps, hidden?: true): Style;
        overrideColor(color: ColorDef | undefined): Style;
        overridePattern(pattern: LinePixels | undefined): Style;
        overrideWidth(width: number | undefined): Style;
        // @internal (undocumented)
        get ovrColor(): boolean;
        readonly pattern?: LinePixels;
        // (undocumented)
        toJSON(): StyleProps;
        readonly width?: number;
    }
    export interface StyleProps {
        readonly color?: ColorDefProps;
        // @internal
        readonly ovrColor?: boolean;
        readonly pattern?: LinePixels;
        readonly width?: number;
    }
}

// @public
export namespace Hilite {
    export function cloneSettings(settings: Settings): Settings;
    export function equalSettings(lhs: Settings, rhs: Settings): boolean;
    export class Settings {
        constructor(color?: ColorDef, visibleRatio?: number, hiddenRatio?: number, silhouette?: Silhouette);
        readonly color: ColorDef;
        readonly hiddenRatio: number;
        silhouette: Silhouette;
        readonly visibleRatio: number;
    }
    export enum Silhouette {
        None = 0,
        Thick = 2,
        Thin = 1
    }
}

// @public
export class HSLColor {
    // (undocumented)
    clone(): HSLColor;
    // (undocumented)
    static fromColorDef(val: ColorDef, out?: HSLColor): HSLColor;
    h: number;
    l: number;
    s: number;
    // (undocumented)
    toColorDef(out?: ColorDef): ColorDef;
}

// @public
export class HSVColor {
    // (undocumented)
    adjustColor(darkenColor: boolean, delta: number): void;
    // (undocumented)
    clone(): HSVColor;
    // (undocumented)
    static fromColorDef(val: ColorDef, out?: HSVColor): HSVColor;
    h: number;
    s: number;
    // (undocumented)
    toColorDef(out?: ColorDef): ColorDef;
    v: number;
}

// @public (undocumented)
export type HttpMethod_T = "get" | "put" | "post" | "delete" | "options" | "head" | "patch" | "trace";

// @public
export interface HttpServerRequest extends Readable {
    // (undocumented)
    body: string | Buffer;
    // (undocumented)
    connection: any;
    // (undocumented)
    destroy(error?: Error): void;
    // (undocumented)
    header: (field: string) => string | undefined;
    // (undocumented)
    headers: {
        [header: string]: string | string[] | undefined;
    };
    // (undocumented)
    httpVersion: string;
    // (undocumented)
    httpVersionMajor: number;
    // (undocumented)
    httpVersionMinor: number;
    // (undocumented)
    ip?: string;
    // (undocumented)
    method: string;
    // (undocumented)
    path: string;
    // (undocumented)
    rawHeaders: string[];
    // (undocumented)
    rawTrailers: string[];
    // (undocumented)
    setTimeout(msecs: number, callback: () => void): this;
    // (undocumented)
    socket: any;
    // (undocumented)
    statusCode?: number;
    // (undocumented)
    statusMessage?: string;
    // (undocumented)
    trailers: {
        [key: string]: string | undefined;
    };
    // (undocumented)
    url?: string;
}

// @public
export interface HttpServerResponse extends Writable {
    // (undocumented)
    send(body?: any): HttpServerResponse;
    // (undocumented)
    set(field: string, value: string): void;
    // (undocumented)
    status(code: number): HttpServerResponse;
}

// @internal
export class I3dmHeader extends TileHeader {
    constructor(stream: ByteStream);
    // (undocumented)
    readonly batchTableBinaryLength: number;
    // (undocumented)
    readonly batchTableJson: any;
    // (undocumented)
    readonly batchTableJsonLength: number;
    // (undocumented)
    readonly featureTableBinaryLength: number;
    // (undocumented)
    readonly featureTableJsonLength: number;
    // (undocumented)
    readonly featureTableJsonPosition: number;
    // (undocumented)
    readonly gltfVersion: number;
    // (undocumented)
    get isValid(): boolean;
    // (undocumented)
    readonly length: number;
}

// @beta
export interface ILinearElementProps extends GeometricElement3dProps {
    // (undocumented)
    lengthValue: number;
    // (undocumented)
    source: RelatedElementProps;
    // (undocumented)
    startValue: number;
}

// @beta
export interface ILinearlyLocatedAttributionProps {
    // (undocumented)
    attributedElement?: RelatedElementProps;
}

// @public
export class ImageBuffer {
    // @internal
    protected constructor(data: Uint8Array, format: ImageBufferFormat, width: number);
    // @internal (undocumented)
    protected static computeHeight(data: Uint8Array, format: ImageBufferFormat, width: number): number;
    static create(data: Uint8Array, format: ImageBufferFormat, width: number): ImageBuffer | undefined;
    readonly data: Uint8Array;
    readonly format: ImageBufferFormat;
    static getNumBytesPerPixel(format: ImageBufferFormat): number;
    get height(): number;
    // @internal (undocumented)
    protected static isValidData(data: Uint8Array, format: ImageBufferFormat, width: number): boolean;
    get numBytesPerPixel(): number;
    readonly width: number;
}

// @public
export enum ImageBufferFormat {
    Alpha = 5,
    Rgb = 2,
    Rgba = 0
}

// @beta
export class ImageGraphic {
    constructor(corners: ImageGraphicCorners, textureId: Id64String, hasBorder?: boolean);
    // (undocumented)
    clone(): ImageGraphic;
    // (undocumented)
    cloneTransformed(transform: Transform): ImageGraphic;
    computeRange(result?: Range3d): Range3d;
    readonly corners: ImageGraphicCorners;
    // (undocumented)
    static fromJSON(props: ImageGraphicProps): ImageGraphic;
    readonly hasBorder: boolean;
    readonly textureId: Id64String;
    // (undocumented)
    toJSON(): ImageGraphicProps;
    transformInPlace(transform: Transform): void;
}

// @beta
export class ImageGraphicCorners {
    // (undocumented)
    readonly 0: Point3d;
    // (undocumented)
    readonly 1: Point3d;
    // (undocumented)
    readonly 2: Point3d;
    // (undocumented)
    readonly 3: Point3d;
    constructor(p0: Point3d, p1: Point3d, p2: Point3d, p3: Point3d);
    // (undocumented)
    clone(): ImageGraphicCorners;
    // (undocumented)
    static from4Points(points: [Point3d, Point3d, Point3d, Point3d]): ImageGraphicCorners;
    // (undocumented)
    static fromJSON(props: ImageGraphicCornersProps): ImageGraphicCorners;
    // (undocumented)
    toJSON(): ImageGraphicCornersProps;
}

// @beta
export type ImageGraphicCornersProps = [XYZProps, XYZProps, XYZProps, XYZProps];

// @beta
export interface ImageGraphicProps {
    corners: ImageGraphicCornersProps;
    hasBorder: boolean;
    textureId: Id64String;
}

// @internal (undocumented)
export namespace ImageLight {
    // (undocumented)
    export class Solar {
        constructor(direction?: Vector3d, color?: ColorDef, intensity?: number);
        // (undocumented)
        color: ColorDef;
        // (undocumented)
        direction: Vector3d;
        // (undocumented)
        intensity: number;
    }
}

// @public
export class ImageSource {
    constructor(data: Uint8Array | string, format: ImageSourceFormat);
    readonly data: Uint8Array | string;
    readonly format: ImageSourceFormat;
}

// @public
export enum ImageSourceFormat {
    Jpeg = 0,
    Png = 2,
    Svg = 3
}

// @internal
export const enum ImdlFlags {
    ContainsCurves = 1,
    Incomplete = 4,
    None = 0
}

// @internal
export class ImdlHeader extends TileHeader {
    constructor(stream: ByteStream);
    readonly contentRange: ElementAlignedBox3d;
    readonly emptySubRanges: number;
    readonly flags: ImdlFlags;
    readonly headerLength: number;
    // (undocumented)
    get isReadableVersion(): boolean;
    // (undocumented)
    get isValid(): boolean;
    readonly numElementsExcluded: number;
    readonly numElementsIncluded: number;
    readonly tileLength: number;
    readonly tolerance: number;
    // (undocumented)
    get versionMajor(): number;
    // (undocumented)
    get versionMinor(): number;
}

// @public
export abstract class IModel implements IModelProps {
    // @internal
    protected constructor(iModelToken?: IModelToken);
    cartographicToSpatialFromEcef(cartographic: Cartographic, result?: Point3d): Point3d;
    static readonly dictionaryId: Id64String;
    get ecefLocation(): EcefLocation | undefined;
    ecefToSpatial(ecef: XYAndZ, result?: Point3d): Point3d;
    static getDefaultSubCategoryId(categoryId: Id64String): Id64String;
    getEcefTransform(): Transform;
    get globalOrigin(): Point3d;
    set globalOrigin(org: Point3d);
    get iModelToken(): IModelToken;
    // @internal (undocumented)
    protected initialize(name: string, props: IModelProps): void;
    get isGeoLocated(): boolean;
    name: string;
    get projectExtents(): AxisAlignedBox3d;
    set projectExtents(extents: AxisAlignedBox3d);
    static readonly repositoryModelId: Id64String;
    rootSubject: RootSubjectProps;
    static readonly rootSubjectId: Id64String;
    setEcefLocation(ecef: EcefLocationProps): void;
    spatialToCartographicFromEcef(spatial: XYAndZ, result?: Cartographic): Cartographic;
    spatialToEcef(spatial: XYAndZ, result?: Point3d): Point3d;
    // @internal (undocumented)
    toJSON(): IModelProps;
    // @internal (undocumented)
    protected _token?: IModelToken;
}

// @beta
export interface IModelCoordinatesRequestProps {
    // (undocumented)
    geoCoords: XYZProps[];
    // (undocumented)
    sourceDatum: string;
}

// @beta (undocumented)
export interface IModelCoordinatesResponseProps {
    // (undocumented)
    fromCache: number;
    // (undocumented)
    iModelCoords: PointWithStatus[];
}

// @public
export class IModelError extends BentleyError {
    constructor(errorNumber: number | IModelStatus | DbResult | BentleyStatus | BriefcaseStatus | RepositoryStatus | ChangeSetStatus | RpcInterfaceStatus | AuthStatus, message: string, log?: LogFunction, category?: string, getMetaData?: GetMetaDataFunction);
}

// @public
export class IModelNotFoundResponse extends RpcNotFoundResponse {
}

// @public
export interface IModelProps {
    ecefLocation?: EcefLocationProps;
    globalOrigin?: XYZProps;
    iModelToken?: IModelTokenProps;
    name?: string;
    projectExtents?: Range3dProps;
    rootSubject: RootSubjectProps;
}

// @public
export abstract class IModelReadRpcInterface extends RpcInterface {
    // @beta (undocumented)
    cancelSnap(_iModelToken: IModelTokenProps, _sessionId: string): Promise<void>;
    // (undocumented)
    close(_iModelToken: IModelTokenProps): Promise<boolean>;
    // (undocumented)
    getAllCodeSpecs(_iModelToken: IModelTokenProps): Promise<any[]>;
    // (undocumented)
    getClassHierarchy(_iModelToken: IModelTokenProps, _startClassName: string): Promise<string[]>;
    static getClient(): IModelReadRpcInterface;
    // (undocumented)
    getDefaultViewId(_iModelToken: IModelTokenProps): Promise<Id64String>;
    // (undocumented)
    getElementProps(_iModelToken: IModelTokenProps, _elementIds: Id64String[]): Promise<ElementProps[]>;
    // @beta (undocumented)
    getGeoCoordinatesFromIModelCoordinates(_iModelToken: IModelTokenProps, _props: string): Promise<GeoCoordinatesResponseProps>;
    // @alpha (undocumented)
    getGeometrySummary(_iModelToken: IModelTokenProps, _props: GeometrySummaryRequestProps): Promise<string>;
    // @beta (undocumented)
    getIModelCoordinatesFromGeoCoordinates(_iModelToken: IModelTokenProps, _props: string): Promise<IModelCoordinatesResponseProps>;
    // @beta (undocumented)
    getMassProperties(_iModelToken: IModelTokenProps, _props: MassPropertiesRequestProps): Promise<MassPropertiesResponseProps>;
    // (undocumented)
    getModelProps(_iModelToken: IModelTokenProps, _modelIds: Id64String[]): Promise<ModelProps[]>;
    // (undocumented)
    getToolTipMessage(_iModelToken: IModelTokenProps, _elementId: string): Promise<string[]>;
    // (undocumented)
    getViewStateData(_iModelToken: IModelTokenProps, _viewDefinitionId: string): Promise<ViewStateProps>;
    // (undocumented)
    getViewThumbnail(_iModelToken: IModelTokenProps, _viewId: string): Promise<Uint8Array>;
    static readonly interfaceName = "IModelReadRpcInterface";
    static interfaceVersion: string;
    // (undocumented)
    openForRead(_iModelToken: IModelTokenProps): Promise<IModelProps>;
    // (undocumented)
    queryElementProps(_iModelToken: IModelTokenProps, _params: EntityQueryParams): Promise<ElementProps[]>;
    // (undocumented)
    queryEntityIds(_iModelToken: IModelTokenProps, _params: EntityQueryParams): Promise<Id64String[]>;
    // (undocumented)
    queryModelProps(_iModelToken: IModelTokenProps, _params: EntityQueryParams): Promise<ModelProps[]>;
    // (undocumented)
    queryModelRanges(_iModelToken: IModelTokenProps, _modelIds: Id64String[]): Promise<Range3dProps[]>;
    // (undocumented)
    queryRows(_iModelToken: IModelTokenProps, _ecsql: string, _bindings?: any[] | object, _limit?: QueryLimit, _quota?: QueryQuota, _priority?: QueryPriority): Promise<QueryResponse>;
    // (undocumented)
    readFontJson(_iModelToken: IModelTokenProps): Promise<any>;
    // @beta (undocumented)
    requestSnap(_iModelToken: IModelTokenProps, _sessionId: string, _props: SnapRequestProps): Promise<SnapResponseProps>;
}

export { IModelStatus }

// @public (undocumented)
export abstract class IModelTileRpcInterface extends RpcInterface {
    // (undocumented)
    static getClient(): IModelTileRpcInterface;
    // @beta (undocumented)
    getTileCacheContainerUrl(_tokenProps: IModelTokenProps, _id: CloudStorageContainerDescriptor): Promise<CloudStorageContainerUrl>;
    static readonly interfaceName = "IModelTileRpcInterface";
    static interfaceVersion: string;
    // @internal
    purgeTileTrees(_tokenProps: IModelTokenProps, _modelIds: Id64Array | undefined): Promise<void>;
    // @internal (undocumented)
    requestTileContent(iModelToken: IModelTokenProps, treeId: string, contentId: string, isCanceled?: () => boolean, guid?: string): Promise<Uint8Array>;
    // @internal (undocumented)
    requestTileTreeProps(_tokenProps: IModelTokenProps, _id: string): Promise<TileTreeProps>;
}

// @internal
export type IModelTileTreeId = PrimaryTileTreeId | ClassifierTileTreeId;

// @internal
export function iModelTileTreeIdToString(modelId: Id64String, treeId: IModelTileTreeId, options: TileOptions): string;

// @public
export class IModelToken implements IModelTokenProps {
    constructor(key?: string, contextId?: string, iModelid?: string, changesetId?: string, openMode?: OpenMode);
    changeSetId?: string;
    readonly contextId?: string;
    static fromJSON(props: IModelTokenProps): IModelToken;
    readonly iModelId?: string;
    readonly key?: string;
    openMode?: OpenMode;
    toJSON(): IModelTokenProps;
}

// @public
export interface IModelTokenProps {
    changeSetId?: string;
    readonly contextId?: string;
    readonly iModelId?: string;
    readonly key?: string;
    openMode?: OpenMode;
}

// @public
export class IModelVersion {
    static asOfChangeSet(changeSetId: GuidString): IModelVersion;
    evaluateChangeSet(requestContext: AuthorizedClientRequestContext, iModelId: GuidString, imodelClient: IModelClient): Promise<GuidString>;
    static first(): IModelVersion;
    static fromJson(jsonObj: any): IModelVersion;
    getAsOfChangeSet(): GuidString | undefined;
    getName(): string | undefined;
    get isFirst(): boolean;
    get isLatest(): boolean;
    static latest(): IModelVersion;
    static named(versionName: string): IModelVersion;
    }

// @alpha
export abstract class IModelWriteRpcInterface extends RpcInterface {
    static getClient(): IModelWriteRpcInterface;
    static readonly interfaceName = "IModelWriteRpcInterface";
    static interfaceVersion: string;
    // (undocumented)
    openForWrite(_iModelToken: IModelTokenProps): Promise<IModelProps>;
    // (undocumented)
    saveChanges(_iModelToken: IModelTokenProps, _description?: string): Promise<void>;
    // (undocumented)
    saveThumbnail(_iModelToken: IModelTokenProps, _val: Uint8Array): Promise<void>;
    // (undocumented)
    updateProjectExtents(_iModelToken: IModelTokenProps, _newExtents: AxisAlignedBox3dProps): Promise<void>;
}

// @public
export interface InformationPartitionElementProps extends DefinitionElementProps {
    // (undocumented)
    description?: string;
}

// @internal (undocumented)
export const initializeRpcRequest: () => void;

// @internal (undocumented)
export const INSTANCE: unique symbol;

// @internal (undocumented)
export const interop: any;

// @beta
export const Interpolation: {
    Linear: (v: any, k: number) => number;
    Bezier: (v: any, k: number) => number;
    CatmullRom: (v: any, k: number) => number;
    Utils: {
        Linear: (p0: number, p1: number, t: number) => number;
        Bernstein: (n: number, i: number) => number;
        Factorial: (n: number) => number;
        CatmullRom: (p0: number, p1: number, p2: number, p3: number, t: number) => number;
    };
};

// @beta (undocumented)
export type InterpolationFunction = (v: any, k: number) => number;

// @beta
export interface IReferentProps {
    // (undocumented)
    referencedElement?: RelatedElementProps;
}

// @internal
export function isKnownTileFormat(format: number): boolean;

// @public
export function isPowerOfTwo(num: number): boolean;

// @internal (undocumented)
export function isValidImageSourceFormat(format: ImageSourceFormat): boolean;

// @public (undocumented)
export interface LatAndLong {
    // (undocumented)
    latitude: number;
    // (undocumented)
    longitude: number;
}

// @public (undocumented)
export interface LatLongAndHeight extends LatAndLong {
    // (undocumented)
    height: number;
}

// @internal
export class Light {
    constructor(opts?: LightProps);
    // (undocumented)
    bulbs: number;
    // (undocumented)
    color: ColorDef;
    // (undocumented)
    color2?: ColorDef;
    // (undocumented)
    intensity: number;
    // (undocumented)
    intensity2?: number;
    // (undocumented)
    get isValid(): boolean;
    // (undocumented)
    get isVisible(): boolean;
    // (undocumented)
    kelvin: number;
    // (undocumented)
    lightType: LightType;
    // (undocumented)
    lumens: number;
    // (undocumented)
    shadows: number;
}

// @internal
export interface LightLocationProps extends GeometricElement3dProps {
    // (undocumented)
    enabled?: boolean;
}

// @internal
export interface LightProps {
    // (undocumented)
    bulbs?: number;
    // (undocumented)
    color?: ColorDefProps;
    // (undocumented)
    color2?: ColorDefProps;
    // (undocumented)
    intensity?: number;
    // (undocumented)
    intensity2?: number;
    // (undocumented)
    kelvin?: number;
    // (undocumented)
    lightType?: LightType;
    // (undocumented)
    lumens?: number;
    // (undocumented)
    shadows?: number;
}

// @internal
export enum LightType {
    // (undocumented)
    Ambient = 2,
    // (undocumented)
    Area = 7,
    // (undocumented)
    Distant = 8,
    // (undocumented)
    Flash = 3,
    // (undocumented)
    Invalid = 0,
    // (undocumented)
    Point = 5,
    // (undocumented)
    Portrait = 4,
    // (undocumented)
    SkyOpening = 9,
    // (undocumented)
    Solar = 1,
    // (undocumented)
    Spot = 6
}

// @beta
export interface LinearLocationReference {
    // (undocumented)
    linearlyLocatedClassFullName: string;
    // (undocumented)
    linearlyLocatedId: Id64String;
    // (undocumented)
    locationAspectId: Id64String;
    // (undocumented)
    startDistanceAlong: number;
    // (undocumented)
    stopDistanceAlong: number;
}

// @beta
export interface LinearlyLocatedAttributionProps extends GeometricElement3dProps, ILinearlyLocatedAttributionProps {
}

// @beta
export interface LinearlyReferencedAtLocationAspectProps extends LinearlyReferencedAtLocationProps, ElementAspectProps {
}

// @beta
export interface LinearlyReferencedAtLocationProps {
    // (undocumented)
    atPosition: DistanceExpressionProps;
    // (undocumented)
    fromReferent?: RelatedElementProps;
}

// @beta
export interface LinearlyReferencedFromToLocationAspectProps extends LinearlyReferencedFromToLocationProps, ElementAspectProps {
}

// @beta
export interface LinearlyReferencedFromToLocationProps {
    // (undocumented)
    fromPosition: DistanceExpressionProps;
    // (undocumented)
    fromPositionFromReferent?: RelatedElementProps;
    // (undocumented)
    toPosition: DistanceExpressionProps;
    // (undocumented)
    toPositionFromReferent?: RelatedElementProps;
}

// @beta
export enum LinearlyReferencedLocationType {
    // (undocumented)
    Any = 2,
    // (undocumented)
    At = 0,
    // (undocumented)
    FromTo = 1
}

// @public
export enum LinePixels {
    Code0 = 0,
    Code1 = 2155905152,
    Code2 = 4177066232,
    Code3 = 4292935648,
    Code4 = 4262526480,
    Code5 = 3772834016,
    Code6 = 4169726088,
    Code7 = 4279828248,
    HiddenLine = 3435973836,
    Invalid = -1,
    Invisible = 1,
    Solid = 0
}

// @public (undocumented)
export namespace LineStyle {
    export class Info {
        constructor(styleId: Id64String, styleMod?: Modifier);
        clone(): Info;
        // (undocumented)
        equals(other: Info): boolean;
        // (undocumented)
        styleId: Id64String;
        // (undocumented)
        styleMod?: Modifier;
    }
    export class Modifier implements ModifierProps {
        constructor(props: ModifierProps);
        // (undocumented)
        applyTransform(transform: Transform): boolean;
        // (undocumented)
        centerPhase?: boolean;
        clone(): Modifier;
        // (undocumented)
        dashScale?: number;
        // (undocumented)
        distPhase?: number;
        // (undocumented)
        endWidth?: number;
        equals(other: Modifier): boolean;
        // (undocumented)
        fractPhase?: number;
        // (undocumented)
        gapScale?: number;
        // (undocumented)
        normal?: Vector3d;
        // (undocumented)
        physicalWidth?: boolean;
        // (undocumented)
        rotation?: YawPitchRollAngles;
        // (undocumented)
        scale?: number;
        // (undocumented)
        segmentMode?: boolean;
        // (undocumented)
        startWidth?: number;
    }
    export interface ModifierProps {
        centerPhase?: boolean;
        dashScale?: number;
        distPhase?: number;
        endWidth?: number;
        fractPhase?: number;
        gapScale?: number;
        normal?: XYZProps;
        physicalWidth?: boolean;
        rotation?: YawPitchRollProps;
        scale?: number;
        segmentMode?: boolean;
        startWidth?: number;
    }
}

// @beta
export interface LineStyleProps extends DefinitionElementProps {
    // (undocumented)
    data: string;
    // (undocumented)
    description?: string;
}

// @public
export type LocalAlignedBox3d = Range3d;

export { LogFunction }

// @internal (undocumented)
export interface MarshalingBinaryMarker {
    // (undocumented)
    chunks: number;
    // (undocumented)
    index: number;
    // (undocumented)
    isBinary: true;
    // (undocumented)
    size: number;
}

// @internal (undocumented)
export namespace MarshalingBinaryMarker {
    // (undocumented)
    export function createDefault(): MarshalingBinaryMarker;
}

// @beta
export enum MassPropertiesOperation {
    AccumulateAreas = 1,
    AccumulateLengths = 0,
    AccumulateVolumes = 2
}

// @beta
export interface MassPropertiesRequestProps {
    // (undocumented)
    candidates?: Id64Array;
    // (undocumented)
    operation: MassPropertiesOperation;
}

// @beta
export interface MassPropertiesResponseProps {
    // (undocumented)
    area?: number;
    // (undocumented)
    centroid?: XYZProps;
    // (undocumented)
    ixy?: number;
    // (undocumented)
    ixz?: number;
    // (undocumented)
    iyz?: number;
    // (undocumented)
    length?: number;
    // (undocumented)
    moments?: XYZProps;
    // (undocumented)
    perimeter?: number;
    // (undocumented)
    status: BentleyStatus;
    // (undocumented)
    volume?: number;
}

// @public
export interface MaterialProps {
    materialId?: Id64String;
    // @internal (undocumented)
    origin?: XYZProps;
    // @internal (undocumented)
    rotation?: YawPitchRollProps;
    // @internal (undocumented)
    size?: XYZProps;
}

// @internal (undocumented)
export class MeshEdge {
    constructor(index0?: number, index1?: number);
    // (undocumented)
    indices: number[];
}

// @internal (undocumented)
export class MeshEdges {
    constructor();
    // (undocumented)
    polylines: MeshPolylineList;
    // (undocumented)
    silhouette: MeshEdge[];
    // (undocumented)
    silhouetteNormals: OctEncodedNormalPair[];
    // (undocumented)
    visible: MeshEdge[];
}

// @internal (undocumented)
export class MeshPolyline {
    constructor(indices?: number[]);
    // (undocumented)
    addIndex(index: number): void;
    // (undocumented)
    clear(): void;
    // (undocumented)
    readonly indices: number[];
}

// @internal (undocumented)
export class MeshPolylineList extends Array<MeshPolyline> {
    constructor(...args: MeshPolyline[]);
}

// @beta (undocumented)
export type MobileRpcChunks = Array<string | Uint8Array>;

// @beta
export abstract class MobileRpcConfiguration extends RpcConfiguration {
    static readonly args: any;
    static get isIOSFrontend(): any;
    static get isMobileBackend(): boolean;
    static get isMobileFrontend(): boolean;
    static readonly platform: RpcMobilePlatform;
    // (undocumented)
    abstract protocol: MobileRpcProtocol;
}

// @beta
export class MobileRpcManager {
    static initializeClient(interfaces: RpcInterfaceDefinition[]): MobileRpcConfiguration;
    static initializeImpl(interfaces: RpcInterfaceDefinition[]): MobileRpcConfiguration;
    }

// @beta
export class MobileRpcProtocol extends RpcProtocol {
    constructor(configuration: MobileRpcConfiguration, endPoint: RpcEndpoint);
    // (undocumented)
    static encodeRequest(request: MobileRpcRequest): Promise<MobileRpcChunks>;
    // (undocumented)
    requests: Map<string, MobileRpcRequest>;
    // (undocumented)
    readonly requestType: typeof MobileRpcRequest;
    // (undocumented)
    sendToBackend(message: MobileRpcChunks): void;
    // (undocumented)
    socket: WebSocket;
    }

// @beta (undocumented)
export class MobileRpcRequest extends RpcRequest {
    protected load(): Promise<RpcSerializedValue>;
    // @internal (undocumented)
    notifyResponse(fulfillment: RpcRequestFulfillment): void;
    readonly protocol: MobileRpcProtocol;
    protected send(): Promise<number>;
    protected setHeader(_name: string, _value: string): void;
}

// @public
export interface ModelProps extends EntityProps {
    // (undocumented)
    isPrivate?: boolean;
    // (undocumented)
    isTemplate?: boolean;
    // (undocumented)
    jsonProperties?: any;
    // (undocumented)
    modeledElement: RelatedElementProps;
    // (undocumented)
    name?: string;
    // (undocumented)
    parentModel?: Id64String;
}

// @public
export interface ModelQueryParams extends EntityQueryParams {
    // (undocumented)
    wantPrivate?: boolean;
    // (undocumented)
    wantTemplate?: boolean;
}

// @public
export interface ModelSelectorProps extends DefinitionElementProps {
    // (undocumented)
    models: Id64Array;
}

// @internal
export abstract class NativeAppRpcInterface extends RpcInterface {
    cancelTileContentRequests(_iModelToken: IModelTokenProps, _contentIds: TileTreeContentIds[]): Promise<void>;
    fetchEvents(_iModelToken: IModelTokenProps, _maxToFetch: number): Promise<QueuedEvent[]>;
    static getClient(): NativeAppRpcInterface;
    static readonly interfaceName = "NativeAppRpcInterface";
    static interfaceVersion: string;
}

// @public
export interface NavigationBindingValue {
    id: Id64String;
    relClassName?: string;
    relClassTableSpace?: string;
}

// @public
export interface NavigationValue {
    id: Id64String;
    relClassName?: string;
}

// @public
export function nextHighestPowerOfTwo(num: number): number;

// @internal
export function nextPoint3d64FromByteStream(stream: ByteStream, result?: Point3d): Point3d;

// @internal (undocumented)
export class NonUniformColor {
    constructor(colors: Uint32Array, indices: number[], hasAlpha: boolean);
    // (undocumented)
    readonly colors: Uint32Array;
    // (undocumented)
    readonly indices: Uint16Array;
    // (undocumented)
    readonly isOpaque: boolean;
}

// @public
export enum Npc {
    _000 = 0,
    _001 = 4,
    _010 = 2,
    _011 = 6,
    _100 = 1,
    _101 = 5,
    _110 = 3,
    _111 = 7,
    CORNER_COUNT = 8,
    // (undocumented)
    LeftBottomFront = 4,
    // (undocumented)
    LeftBottomRear = 0,
    // (undocumented)
    LeftTopFront = 6,
    // (undocumented)
    LeftTopRear = 2,
    // (undocumented)
    RightBottomFront = 5,
    // (undocumented)
    RightBottomRear = 1,
    // (undocumented)
    RightTopFront = 7,
    // (undocumented)
    RightTopRear = 3
}

// @public
export const NpcCenter: Point3d;

// @public
export const NpcCorners: Point3d[];

// @internal (undocumented)
export class OctEncodedNormal {
    constructor(val: number);
    // (undocumented)
    decode(): Vector3d | undefined;
    // (undocumented)
    static decodeValue(val: number, result?: Vector3d): Vector3d;
    // (undocumented)
    static encode(vec: XYAndZ): number;
    // (undocumented)
    static fromVector(val: XYAndZ): OctEncodedNormal;
    // (undocumented)
    readonly value: number;
}

// @internal (undocumented)
export class OctEncodedNormalPair {
    constructor(first: OctEncodedNormal, second: OctEncodedNormal);
    // (undocumented)
    first: OctEncodedNormal;
    // (undocumented)
    second: OctEncodedNormal;
}

// @alpha
export interface OidcDesktopClientConfiguration {
    clientId: string;
    expiryBuffer?: number;
    redirectUri: string;
    scope: string;
}

// @internal
export interface OpenAPIContentMap {
    // (undocumented)
    [index: string]: OpenAPIMediaType;
}

// @internal
export interface OpenAPIDocument {
    // (undocumented)
    info: OpenAPIInfo;
    // (undocumented)
    openapi: "3.0.0";
    // (undocumented)
    paths: OpenAPIPaths;
}

// @internal
export interface OpenAPIEncoding {
    // (undocumented)
    allowReserved?: boolean;
    // (undocumented)
    contentType?: string;
    // (undocumented)
    explode?: boolean;
    // (undocumented)
    style?: string;
}

// @public
export interface OpenAPIInfo {
    // (undocumented)
    title: string;
    // (undocumented)
    version: string;
}

// @internal
export interface OpenAPIMediaType {
    // (undocumented)
    schema?: OpenAPISchema;
}

// @internal
export interface OpenAPIOperation {
    // (undocumented)
    operationId?: string;
    // (undocumented)
    parameters?: OpenAPIParameter[];
    // (undocumented)
    requestBody?: OpenAPIRequestBody;
    // (undocumented)
    responses: OpenAPIResponses;
    // (undocumented)
    summary?: string;
}

// @internal
export interface OpenAPIParameter {
    // (undocumented)
    allowEmptyValue?: boolean;
    // (undocumented)
    allowReserved?: boolean;
    // (undocumented)
    content?: OpenAPIContentMap;
    // (undocumented)
    description?: string;
    // (undocumented)
    explode?: boolean;
    // (undocumented)
    in: "query" | "header" | "path" | "cookie";
    // (undocumented)
    name: string;
    // (undocumented)
    required?: boolean;
    // (undocumented)
    schema?: OpenAPISchema;
    // (undocumented)
    style?: "matrix" | "label" | "form" | "simple" | "spaceDelimited" | "pipeDelimited" | "deepObject";
}

// @internal
export interface OpenAPIPathItem {
    // (undocumented)
    delete?: OpenAPIOperation;
    // (undocumented)
    get?: OpenAPIOperation;
    // (undocumented)
    head?: OpenAPIOperation;
    // (undocumented)
    options?: OpenAPIOperation;
    // (undocumented)
    parameters?: OpenAPIParameter[];
    // (undocumented)
    patch?: OpenAPIOperation;
    // (undocumented)
    post?: OpenAPIOperation;
    // (undocumented)
    put?: OpenAPIOperation;
    // (undocumented)
    summary?: string;
    // (undocumented)
    trace?: OpenAPIOperation;
}

// @internal
export interface OpenAPIPaths {
    // (undocumented)
    [index: string]: OpenAPIPathItem;
}

// @internal
export interface OpenAPIRequestBody {
    // (undocumented)
    content: OpenAPIContentMap;
    // (undocumented)
    description?: string;
    // (undocumented)
    required?: boolean;
}

// @internal
export interface OpenAPIResponse {
    // (undocumented)
    content?: {
        [index: string]: OpenAPIMediaType;
    };
    // (undocumented)
    description: string;
}

// @internal
export interface OpenAPIResponses {
    // (undocumented)
    "200"?: OpenAPIResponse;
    // (undocumented)
    "301"?: OpenAPIResponse;
    // (undocumented)
    "302"?: OpenAPIResponse;
    // (undocumented)
    "400"?: OpenAPIResponse;
    // (undocumented)
    "404"?: OpenAPIResponse;
    // (undocumented)
    "500"?: OpenAPIResponse;
    // (undocumented)
    default?: OpenAPIResponse;
}

// @internal
export interface OpenAPISchema {
    // (undocumented)
    description?: string;
    // (undocumented)
    nullable?: boolean;
    // (undocumented)
    type?: "boolean" | "object" | "array" | "number" | "string";
}

// @internal (undocumented)
export const OPERATION: unique symbol;

// @internal (undocumented)
export interface PackedFeature {
    // (undocumented)
    animationNodeId: number;
    // (undocumented)
    elementId: Id64.Uint32Pair;
    // (undocumented)
    geometryClass: GeometryClass;
    // (undocumented)
    subCategoryId: Id64.Uint32Pair;
}

// @internal
export class PackedFeatureTable {
    constructor(data: Uint32Array, modelId: Id64String, numFeatures: number, maxFeatures: number, type: BatchType, animationNodeIds?: Uint8Array | Uint16Array | Uint32Array);
    // (undocumented)
    readonly anyDefined: boolean;
    // (undocumented)
    get byteLength(): number;
    findElementId(featureIndex: number): Id64String | undefined;
    findFeature(featureIndex: number): Feature | undefined;
    // (undocumented)
    getAnimationNodeId(featureIndex: number): number;
    // (undocumented)
    getElementIdPair(featureIndex: number): Id64.Uint32Pair;
    getFeature(featureIndex: number): Feature;
    // (undocumented)
    getPackedFeature(featureIndex: number): PackedFeature;
    // (undocumented)
    getSubCategoryIdPair(featureIndex: number): Id64.Uint32Pair;
    // (undocumented)
    get isClassifier(): boolean;
    // (undocumented)
    get isPlanarClassifier(): boolean;
    get isUniform(): boolean;
    // (undocumented)
    get isVolumeClassifier(): boolean;
    // (undocumented)
    readonly maxFeatures: number;
    // (undocumented)
    readonly modelId: Id64String;
    // (undocumented)
    readonly numFeatures: number;
    static pack(featureTable: FeatureTable): PackedFeatureTable;
    // (undocumented)
    readonly type: BatchType;
    get uniform(): Feature | undefined;
    unpack(): FeatureTable;
}

// @public
export class Placement2d implements Placement2dProps {
    constructor(origin: Point2d, angle: Angle, bbox: ElementAlignedBox2d);
    // (undocumented)
    angle: Angle;
    // (undocumented)
    bbox: ElementAlignedBox2d;
    calculateRange(): AxisAlignedBox3d;
    static fromJSON(json?: Placement2dProps): Placement2d;
    getWorldCorners(out?: Frustum): Frustum;
    get isValid(): boolean;
    multiplyTransform(other: Transform): void;
    // (undocumented)
    origin: Point2d;
    get rotation(): Matrix3d;
    setFrom(other: Placement2d): void;
    get transform(): Transform;
}

// @public
export interface Placement2dProps {
    // (undocumented)
    angle: AngleProps;
    // (undocumented)
    bbox?: LowAndHighXY;
    // (undocumented)
    origin: XYProps;
}

// @public
export class Placement3d implements Placement3dProps {
    constructor(origin: Point3d, angles: YawPitchRollAngles, bbox: ElementAlignedBox3d);
    // (undocumented)
    angles: YawPitchRollAngles;
    // (undocumented)
    bbox: ElementAlignedBox3d;
    calculateRange(): AxisAlignedBox3d;
    static fromJSON(json?: Placement3dProps): Placement3d;
    getWorldCorners(out?: Frustum): Frustum;
    get isValid(): boolean;
    multiplyTransform(other: Transform): void;
    // (undocumented)
    origin: Point3d;
    get rotation(): Matrix3d;
    setFrom(other: Placement3d): void;
    get transform(): Transform;
}

// @public
export interface Placement3dProps {
    // (undocumented)
    angles: YawPitchRollProps;
    // (undocumented)
    bbox?: LowAndHighXYZ;
    // (undocumented)
    origin: XYZProps;
}

// @public (undocumented)
export type PlacementProps = Placement2dProps | Placement3dProps;

// @alpha
export class PlanProjectionSettings {
    constructor(props: PlanProjectionSettingsProps);
    clone(changedProps?: PlanProjectionSettingsProps): PlanProjectionSettings;
    readonly elevation?: number;
    // (undocumented)
    static fromJSON(props: PlanProjectionSettingsProps | undefined): PlanProjectionSettings | undefined;
    readonly overlay: boolean;
    readonly priority?: number;
    // (undocumented)
    toJSON(): PlanProjectionSettingsProps;
    readonly transparency?: number;
}

// @alpha
export interface PlanProjectionSettingsProps {
    elevation?: number;
    overlay?: boolean;
    priority?: number;
    transparency?: number;
}

// @internal
export class PntsHeader extends TileHeader {
    constructor(stream: ByteStream);
    // (undocumented)
    readonly batchTableBinaryLength: number;
    // (undocumented)
    readonly batchTableJsonLength: number;
    // (undocumented)
    readonly featureTableBinaryLength: number;
    // (undocumented)
    readonly featureTableJsonLength: number;
    // (undocumented)
    get isValid(): boolean;
    // (undocumented)
    readonly length: number;
}

// @beta
export interface PointWithStatus {
    // (undocumented)
    p: XYZProps;
    // (undocumented)
    s: GeoCoordStatus;
}

// @internal (undocumented)
export const POLICY: unique symbol;

// @internal (undocumented)
export class PolylineData {
    constructor(vertIndices?: number[], numIndices?: number);
    // (undocumented)
    init(polyline: MeshPolyline): boolean;
    // (undocumented)
    get isValid(): boolean;
    // (undocumented)
    numIndices: number;
    // (undocumented)
    reset(): void;
    // (undocumented)
    vertIndices: number[];
}

// @internal (undocumented)
export class PolylineEdgeArgs {
    constructor(lines?: PolylineData[]);
    // (undocumented)
    clear(): void;
    // (undocumented)
    init(lines?: PolylineData[]): boolean;
    // (undocumented)
    get isValid(): boolean;
    // (undocumented)
    lines?: PolylineData[];
    // (undocumented)
    get numLines(): number;
}

// @internal
export class PolylineFlags {
    constructor(is2d?: boolean, isPlanar?: boolean, isDisjoint?: boolean, type?: PolylineTypeFlags);
    // (undocumented)
    clone(): PolylineFlags;
    // (undocumented)
    equals(other: PolylineFlags): boolean;
    // (undocumented)
    initDefaults(): void;
    // (undocumented)
    is2d: boolean;
    // (undocumented)
    get isAnyEdge(): boolean;
    // (undocumented)
    isDisjoint: boolean;
    // (undocumented)
    get isNormalEdge(): boolean;
    // (undocumented)
    get isOutlineEdge(): boolean;
    // (undocumented)
    isPlanar: boolean;
    pack(): number;
    // (undocumented)
    setIsNormalEdge(): void;
    // (undocumented)
    setIsOutlineEdge(): void;
    // (undocumented)
    type: PolylineTypeFlags;
    static unpack(value: number): PolylineFlags;
}

// @internal (undocumented)
export enum PolylineTypeFlags {
    // (undocumented)
    Edge = 1,
    // (undocumented)
    Normal = 0,
    // (undocumented)
    Outline = 2
}

// @internal
export interface PrimaryTileTreeId {
    // (undocumented)
    animationId?: Id64String;
    // (undocumented)
    edgesRequired: boolean;
    // (undocumented)
    type: BatchType.Primary;
}

// @beta
export enum PrimitiveTypeCode {
    // (undocumented)
    Binary = 257,
    // (undocumented)
    Boolean = 513,
    // (undocumented)
    DateTime = 769,
    // (undocumented)
    Double = 1025,
    // (undocumented)
    Integer = 1281,
    // (undocumented)
    Long = 1537,
    // (undocumented)
    Point2d = 1793,
    // (undocumented)
    Point3d = 2049,
    // (undocumented)
    String = 2305,
    // (undocumented)
    Uninitialized = 0
}

// @beta
export type PropertyCallback = (name: string, meta: PropertyMetaData) => void;

// @beta
export class PropertyMetaData implements PropertyMetaDataProps {
    constructor(jsonObj: PropertyMetaDataProps);
    createProperty(jsonObj: any): any;
    // (undocumented)
    customAttributes?: CustomAttribute[];
    // (undocumented)
    description?: string;
    // (undocumented)
    direction?: string;
    // (undocumented)
    displayLabel?: string;
    // (undocumented)
    extendedType?: string;
    // (undocumented)
    isCustomHandled?: boolean;
    // (undocumented)
    isCustomHandledOrphan?: boolean;
    get isNavigation(): boolean;
    // (undocumented)
    kindOfQuantity?: string;
    // (undocumented)
    maximumLength?: number;
    // (undocumented)
    maximumValue?: any;
    // (undocumented)
    maxOccurs?: number;
    // (undocumented)
    minimumLength?: number;
    // (undocumented)
    minimumValue?: any;
    // (undocumented)
    minOccurs?: number;
    // (undocumented)
    primitiveType?: PrimitiveTypeCode;
    // (undocumented)
    readOnly?: boolean;
    // (undocumented)
    relationshipClass?: string;
    // (undocumented)
    structName?: string;
}

// @beta (undocumented)
export interface PropertyMetaDataProps {
    // (undocumented)
    customAttributes?: CustomAttribute[];
    // (undocumented)
    description?: string;
    // (undocumented)
    direction?: string;
    // (undocumented)
    displayLabel?: string;
    // (undocumented)
    extendedType?: string;
    // (undocumented)
    isCustomHandled?: boolean;
    // (undocumented)
    isCustomHandledOrphan?: boolean;
    // (undocumented)
    kindOfQuantity?: string;
    // (undocumented)
    maximumLength?: number;
    // (undocumented)
    maximumValue?: any;
    // (undocumented)
    maxOccurs?: number;
    // (undocumented)
    minimumLength?: number;
    // (undocumented)
    minimumValue?: any;
    // (undocumented)
    minOccurs?: number;
    // (undocumented)
    primitiveType?: number;
    // (undocumented)
    readOnly?: boolean;
    // (undocumented)
    relationshipClass?: string;
    // (undocumented)
    structName?: string;
}

// @internal
export class QParams2d {
    // (undocumented)
    clone(out?: QParams2d): QParams2d;
    // (undocumented)
    copyFrom(src: QParams2d): void;
    static fromNormalizedRange(): QParams2d;
    static fromRange(range: Range2d, out?: QParams2d): QParams2d;
    static fromZeroToOne(): QParams2d;
    // (undocumented)
    readonly origin: Point2d;
    // (undocumented)
    readonly scale: Point2d;
    setFromRange(range: Range2d): void;
}

// @internal
export class QParams3d {
    // (undocumented)
    clone(out?: QParams3d): QParams3d;
    // (undocumented)
    copyFrom(src: QParams3d): void;
    static fromNormalizedRange(): QParams3d;
    static fromOriginAndScale(origin: Point3d, scale: Point3d, out?: QParams3d): QParams3d;
    static fromRange(range: Range3d, out?: QParams3d): QParams3d;
    static fromZeroToOne(): QParams3d;
    // (undocumented)
    readonly origin: Point3d;
    // (undocumented)
    readonly scale: Point3d;
    setFromOriginAndScale(origin: Point3d, scale: Point3d): void;
    setFromRange(range: Range3d): void;
}

// @internal
export class QPoint2d {
    constructor();
    // (undocumented)
    clone(out?: QPoint2d): QPoint2d;
    // (undocumented)
    copyFrom(src: QPoint2d): void;
    static create(pos: Point2d, params: QParams2d): QPoint2d;
    static fromScalars(x: number, y: number): QPoint2d;
    init(pos: Point2d, params: QParams2d): void;
    setFromScalars(x: number, y: number): void;
    unquantize(params: QParams2d, out?: Point2d): Point2d;
    // (undocumented)
    get x(): number;
    set x(x: number);
    // (undocumented)
    get y(): number;
    set y(y: number);
    }

// @internal
export class QPoint2dList {
    constructor(params: QParams2d);
    add(pt: Point2d): void;
    clear(): void;
    static fromPoints(points: Point2d[], out?: QPoint2dList): QPoint2dList;
    get length(): number;
    // (undocumented)
    readonly params: QParams2d;
    push(qpt: QPoint2d): void;
    requantize(params: QParams2d): void;
    reset(params: QParams2d): void;
    toTypedArray(): Uint16Array;
    unquantize(index: number, out?: Point2d): Point2d;
}

// @internal
export class QPoint3d {
    // (undocumented)
    clone(out?: QPoint3d): QPoint3d;
    // (undocumented)
    compare(rhs: QPoint3d): number;
    // (undocumented)
    copyFrom(src: QPoint3d): void;
    static create(pos: Point3d, params: QParams3d): QPoint3d;
    // (undocumented)
    equals(other: QPoint3d): boolean;
    static fromScalars(x: number, y: number, z: number, out?: QPoint3d): QPoint3d;
    init(pos: Point3d, params: QParams3d): void;
    setFromScalars(x: number, y: number, z: number): void;
    unquantize(params: QParams3d, out?: Point3d): Point3d;
    // (undocumented)
    get x(): number;
    set x(x: number);
    // (undocumented)
    get y(): number;
    set y(y: number);
    // (undocumented)
    get z(): number;
    set z(z: number);
    }

// @internal
export class QPoint3dList {
    // (undocumented)
    [Symbol.iterator](): IterableIterator<QPoint3d>;
    constructor(paramsIn?: QParams3d);
    add(pt: Point3d): void;
    clear(): void;
    // (undocumented)
    static createFrom(points: Point3d[], params: QParams3d): QPoint3dList;
    static fromPoints(points: Point3d[], out?: QPoint3dList): QPoint3dList;
    get length(): number;
    // (undocumented)
    get list(): QPoint3d[];
    // (undocumented)
    readonly params: QParams3d;
    push(qpt: QPoint3d): void;
    requantize(params: QParams3d): void;
    reset(params: QParams3d): void;
    toTypedArray(): Uint16Array;
    unquantize(index: number, out?: Point3d): Point3d;
}

// @internal
export namespace Quantization {
    // (undocumented)
    export function computeScale(extent: number): number;
    // (undocumented)
    export function isInRange(qpos: number): boolean;
    // (undocumented)
    export function isQuantizable(pos: number, origin: number, scale: number): boolean;
    // (undocumented)
    export function isQuantized(qpos: number): boolean;
    // (undocumented)
    export function quantize(pos: number, origin: number, scale: number): number;
    // (undocumented)
    export function unquantize(qpos: number, origin: number, scale: number): number;
}

// @public
export interface QueryLimit {
    maxRowAllowed?: number;
    startRowOffset?: number;
}

// @beta
export interface QueryParams {
    // (undocumented)
    fromComparisonOption?: ComparisonOption;
    // (undocumented)
    fromDistanceAlong?: number;
    // (undocumented)
    linearlyLocatedClassFullNames?: string[];
    // (undocumented)
    linearlyReferencedLocationTypeFilter?: LinearlyReferencedLocationType;
    // (undocumented)
    toComparisonOption?: ComparisonOption;
    // (undocumented)
    toDistanceAlong?: number;
}

// @public
export enum QueryPriority {
    // (undocumented)
    High = 2,
    // (undocumented)
    Low = 0,
    // (undocumented)
    Normal = 1
}

// @public
export interface QueryQuota {
    maxMemoryAllowed?: number;
    maxTimeAllowed?: number;
}

// @public
export interface QueryResponse {
    // (undocumented)
    rows: any[];
    // (undocumented)
    status: QueryResponseStatus;
}

// @public
export enum QueryResponseStatus {
    // (undocumented)
    Done = 2,
    // (undocumented)
    Error = 5,
    // (undocumented)
    Partial = 3,
    // (undocumented)
    PostError = 6,
    // (undocumented)
    Timeout = 4
}

// @internal
export interface QueuedEvent {
    // (undocumented)
    data: any;
    // (undocumented)
    eventId: number;
    // (undocumented)
    eventName: string;
    // (undocumented)
    namespace: string;
}

// @public
export enum Rank {
    Application = 2,
    Domain = 1,
    System = 0,
    User = 3
}

// @internal (undocumented)
export interface ReadableFormData extends Readable {
    // (undocumented)
    getHeaders(): {
        [key: string]: any;
    };
}

// @internal
export function readTileContentDescription(stream: ByteStream, sizeMultiplier: number | undefined, is2d: boolean, options: TileOptions, isVolumeClassifier: boolean): TileContentDescription;

// @beta
export interface ReferentElementProps extends GeometricElement3dProps, IReferentProps {
}

// @internal (undocumented)
export const REGISTRY: unique symbol;

// @public
export class RelatedElement implements RelatedElementProps {
    constructor(props: RelatedElementProps);
    // (undocumented)
    static fromJSON(json?: RelatedElementProps): RelatedElement | undefined;
    readonly id: Id64String;
    static idFromJson(json: any): Id64String;
    static readonly none: RelatedElement;
    readonly relClassName?: string;
}

// @public
export interface RelatedElementProps {
    id: Id64String;
    relClassName?: string;
}

// @beta
export abstract class RenderMaterial {
    protected constructor(params: RenderMaterial.Params);
    // (undocumented)
    get hasTexture(): boolean;
    readonly key?: string;
    readonly textureMapping?: TextureMapping;
}

// @beta
export namespace RenderMaterial {
    export class Params {
        constructor(key?: string);
        get alpha(): number | undefined;
        set alpha(alpha: number | undefined);
        ambient: number;
        static readonly defaults: Params;
        diffuse: number;
        diffuseColor?: ColorDef;
        emissiveColor?: ColorDef;
        static fromColors(key?: string, diffuseColor?: ColorDef, specularColor?: ColorDef, emissiveColor?: ColorDef, reflectColor?: ColorDef, textureMap?: TextureMapping): Params;
        key?: string;
        reflect: number;
        reflectColor?: ColorDef;
        refract: number;
        shadows: boolean;
        specular: number;
        specularColor?: ColorDef;
        // (undocumented)
        specularExponent: number;
        textureMapping?: TextureMapping;
    }
}

// @beta
export interface RenderMaterialProps extends DefinitionElementProps {
    description?: string;
    // (undocumented)
    jsonProperties?: {
        materialAssets?: {
            renderMaterial?: {
                HasBaseColor?: boolean;
                color?: RgbFactorProps;
                HasSpecularColor?: boolean;
                specular_color?: RgbFactorProps;
                HasFinish?: boolean;
                finish?: number;
                HasTransmit?: boolean;
                transmit?: number;
                HasDiffuse?: boolean;
                diffuse?: number;
                HasSpecular?: boolean;
                specular?: number;
                HasReflect?: boolean;
                reflect?: number;
                HasReflectColor?: boolean;
                reflect_color?: RgbFactorProps;
                Map?: {
                    Pattern?: TextureMapProps;
                };
            };
        };
    };
    paletteName: string;
}

// @public
export enum RenderMode {
    HiddenLine = 3,
    SmoothShade = 6,
    SolidFill = 4,
    Wireframe = 0
}

// @beta
export namespace RenderSchedule {
    export interface ColorEntryProps extends TimelineEntryProps {
        // (undocumented)
        value: {
            red: number;
            green: number;
            blue: number;
        };
    }
    export interface CuttingPlaneEntryProps extends TimelineEntryProps {
        // (undocumented)
        value: CuttingPlaneProps;
    }
    export interface CuttingPlaneProps {
        direction: number[];
        hidden?: boolean;
        position: number[];
        visible?: boolean;
    }
    export interface ElementTimelineProps extends TimelineProps {
        // (undocumented)
        batchId: number;
        // (undocumented)
        elementIds: Id64String[];
    }
    export interface ModelTimelineProps extends TimelineProps {
        // (undocumented)
        elementTimelines: ElementTimelineProps[];
        // (undocumented)
        modelId: Id64String;
        // (undocumented)
        realityModelUrl?: string;
    }
    export interface TimelineEntryProps {
        interpolation: number;
        time: number;
    }
    export interface TimelineProps {
        // (undocumented)
        colorTimeline?: ColorEntryProps[];
        // (undocumented)
        cuttingPlaneTimeline?: CuttingPlaneEntryProps[];
        // (undocumented)
        transformTimeline?: TransformEntryProps[];
        // (undocumented)
        visibilityTimeline?: VisibilityEntryProps[];
    }
    export interface TransformEntryProps extends TimelineEntryProps {
        // (undocumented)
        value: TransformProps;
    }
    export interface TransformProps {
        orientation: number[];
        pivot: number[];
        position: number[];
        transform: number[][];
    }
    export interface VisibilityEntryProps extends TimelineEntryProps {
        // (undocumented)
        value: number;
    }
}

// @beta
export abstract class RenderTexture implements IDisposable {
    protected constructor(params: RenderTexture.Params);
    abstract dispose(): void;
    // (undocumented)
    get isGlyph(): boolean;
    readonly isOwned: boolean;
    // (undocumented)
    get isSkyBox(): boolean;
    // (undocumented)
    get isTileSection(): boolean;
    readonly key: string | undefined;
    readonly type: RenderTexture.Type;
}

// @beta
export namespace RenderTexture {
    export class Params {
        constructor(key?: string, type?: Type, isOwned?: boolean);
        static readonly defaults: Params;
        // (undocumented)
        get isGlyph(): boolean;
        readonly isOwned: boolean;
        // (undocumented)
        get isSkyBox(): boolean;
        // (undocumented)
        get isTileSection(): boolean;
        readonly key?: string;
        readonly type: Type;
    }
    export const enum Type {
        FilteredTileSection = 4,
        Glyph = 1,
        Normal = 0,
        SkyBox = 3,
        TileSection = 2
    }
}

export { RepositoryStatus }

// @public (undocumented)
export class ResponseLike implements Response {
    constructor(data: any);
    // (undocumented)
    arrayBuffer(): Promise<ArrayBuffer>;
    // (undocumented)
    blob(): Promise<Blob>;
    // (undocumented)
    get body(): null;
    // (undocumented)
    get bodyUsed(): boolean;
    // (undocumented)
    clone(): {} & this;
    // (undocumented)
    formData(): Promise<FormData>;
    // (undocumented)
    get headers(): Headers;
    // (undocumented)
    json(): Promise<any>;
    // (undocumented)
    get ok(): boolean;
    // (undocumented)
    get redirected(): boolean;
    // (undocumented)
    get status(): number;
    // (undocumented)
    get statusText(): string;
    // (undocumented)
    text(): Promise<string>;
    // (undocumented)
    get trailer(): Promise<Headers>;
    // (undocumented)
    get type(): ResponseType;
    // (undocumented)
    get url(): string;
}

// @public
export class RgbColor {
    constructor(r: number, g: number, b: number);
    // (undocumented)
    readonly b: number;
    // (undocumented)
    equals(other: RgbColor): boolean;
    static fromColorDef(colorDef: ColorDef): RgbColor;
    // (undocumented)
    static fromJSON(json: RgbColorProps | undefined): RgbColor;
    // (undocumented)
    readonly g: number;
    // (undocumented)
    readonly r: number;
    // (undocumented)
    toJSON(): RgbColorProps;
}

// @public
export type RgbColorProps = {
    r: number;
    g: number;
    b: number;
} | RgbColor;

// @beta
export type RgbFactorProps = number[];

// @public
export interface RootSubjectProps {
    description?: string;
    name: string;
}

// @public
export abstract class RpcConfiguration {
    static assign<T extends RpcInterface>(definition: RpcInterfaceDefinition<T>, supplier: RpcConfigurationSupplier): void;
    // @internal
    readonly controlChannel: RpcControlChannel;
    static developmentMode: boolean;
    static initializeInterfaces(configuration: RpcConfiguration): void;
    abstract readonly interfaces: () => RpcInterfaceDefinition[];
    static obtain<T extends RpcConfiguration>(configurationConstructor: {
        new (): T;
    }): T;
    // @internal (undocumented)
    onRpcClientInitialized(definition: RpcInterfaceDefinition, client: RpcInterface): void;
    // @internal (undocumented)
    onRpcClientTerminated(definition: RpcInterfaceDefinition, client: RpcInterface): void;
    // @internal (undocumented)
    onRpcImplInitialized(definition: RpcInterfaceDefinition, impl: RpcInterface): void;
    // @internal (undocumented)
    onRpcImplTerminated(definition: RpcInterfaceDefinition, impl: RpcInterface): void;
    pendingOperationRetryInterval: number;
    abstract readonly protocol: RpcProtocol;
    static requestContext: RpcRequestContext;
    static strictMode: boolean;
    // @internal (undocumented)
    static supply(definition: RpcInterface): RpcConfiguration;
    static throwOnTokenMismatch: boolean;
}

// @public (undocumented)
export type RpcConfigurationSupplier = () => {
    new (): RpcConfiguration;
};

// @public
export enum RpcContentType {
    // (undocumented)
    Binary = 2,
    // (undocumented)
    Multipart = 3,
    // (undocumented)
    Stream = 4,
    // (undocumented)
    Text = 1,
    // (undocumented)
    Unknown = 0
}

// @internal
export class RpcControlChannel {
    // (undocumented)
    static channels: RpcControlChannel[];
    // (undocumented)
    describeEndpoints(): Promise<RpcInterfaceEndpoints[]>;
    // (undocumented)
    handleUnknownOperation(invocation: RpcInvocation, _error: any): boolean;
    // (undocumented)
    initialize(): void;
    // (undocumented)
    static obtain(configuration: RpcConfiguration): RpcControlChannel;
    }

// @public
export abstract class RpcControlResponse {
}

// @internal
export class RpcDefaultConfiguration extends RpcConfiguration {
    // (undocumented)
    interfaces: () => never[];
    // (undocumented)
    protocol: RpcProtocol;
}

// @internal
export class RpcDirectProtocol extends RpcProtocol {
    // (undocumented)
    readonly requestType: typeof RpcDirectRequest;
}

// @internal
export class RpcDirectRequest extends RpcRequest {
    // (undocumented)
    fulfillment: RpcRequestFulfillment | undefined;
    // (undocumented)
    headers: Map<string, string>;
    // (undocumented)
    protected load(): Promise<import("./RpcMarshaling").RpcSerializedValue>;
    // (undocumented)
    protected send(): Promise<number>;
    // (undocumented)
    protected setHeader(name: string, value: string): void;
}

// @public
export enum RpcEndpoint {
    // (undocumented)
    Backend = 1,
    // (undocumented)
    Frontend = 0
}

// @public
export abstract class RpcInterface {
    readonly configuration: RpcConfiguration;
    // @internal (undocumented)
    configurationSupplier: RpcConfigurationSupplier | undefined;
    forward<T = any>(parameters: IArguments): Promise<T>;
    static isVersionCompatible(backend: string, frontend: string): boolean;
}

// @public (undocumented)
export interface RpcInterfaceDefinition<T extends RpcInterface = RpcInterface> {
    // (undocumented)
    interfaceName: string;
    // (undocumented)
    interfaceVersion: string;
    // (undocumented)
    prototype: T;
}

// @public
export interface RpcInterfaceEndpoints {
    // (undocumented)
    compatible: boolean;
    // (undocumented)
    interfaceName: string;
    // (undocumented)
    interfaceVersion: string;
    // (undocumented)
    operationNames: string[];
}

// @public (undocumented)
export type RpcInterfaceImplementation<T extends RpcInterface = RpcInterface> = new () => T;

export { RpcInterfaceStatus }

// @public
export class RpcInvocation {
    constructor(protocol: RpcProtocol, request: SerializedRpcRequest);
    static current(rpcImpl: RpcInterface): RpcInvocation;
    get elapsed(): number;
    readonly fulfillment: Promise<RpcRequestFulfillment>;
    readonly operation: RpcOperation;
    readonly protocol: RpcProtocol;
    readonly request: SerializedRpcRequest;
    readonly result: Promise<any>;
    get status(): RpcRequestStatus;
    }

// @public
export type RpcInvocationCallback_T = (invocation: RpcInvocation) => void;

// @public
export class RpcManager {
    static describeAvailableEndpoints(): Promise<RpcInterfaceEndpoints[]>;
    static getClientForInterface<T extends RpcInterface>(definition: RpcInterfaceDefinition<T>): T;
    static initializeInterface<T extends RpcInterface>(definition: RpcInterfaceDefinition<T>): void;
    static registerImpl<TDefinition extends RpcInterface, TImplementation extends TDefinition>(definition: RpcInterfaceDefinition<TDefinition>, implementation: RpcInterfaceImplementation<TImplementation>): void;
    static supplyImplInstance<TDefinition extends RpcInterface, TImplementation extends TDefinition>(definition: RpcInterfaceDefinition<TDefinition>, instance: TImplementation): void;
    static terminateInterface<T extends RpcInterface>(definition: RpcInterfaceDefinition<T>): void;
    static unregisterImpl<TDefinition extends RpcInterface>(definition: RpcInterfaceDefinition<TDefinition>): void;
}

// @internal (undocumented)
export class RpcMarshaling {
    static deserialize(protocol: RpcProtocol | undefined, value: RpcSerializedValue): any;
    static serialize(protocol: RpcProtocol | undefined, value: any): Promise<RpcSerializedValue>;
}

// @beta
export enum RpcMobilePlatform {
    // (undocumented)
    Android = 1,
    // (undocumented)
    iOS = 2,
    // (undocumented)
    Unknown = 0
}

// @internal
export class RpcMultipart {
    static createForm(value: RpcSerializedValue): FormData;
    static createStream(_value: RpcSerializedValue): ReadableFormData;
    static parseRequest(_req: HttpServerRequest): Promise<RpcSerializedValue>;
    // (undocumented)
    static writeValueToForm(form: FormDataCommon, value: RpcSerializedValue): void;
}

// @public
export class RpcNotFoundResponse extends RpcControlResponse {
}

// @internal
export class RpcOpenAPIDescription {
    constructor(protocol: WebAppRpcProtocol);
    get document(): OpenAPIDocument;
    get paths(): OpenAPIPaths;
    readonly protocol: WebAppRpcProtocol;
    toJSON(): OpenAPIDocument;
}

// @public
export class RpcOperation {
    // @internal
    constructor(definition: RpcInterfaceDefinition, operation: string, policy: RpcOperationPolicy);
    // @internal (undocumented)
    static computeOperationName(identifier: string): string;
    static fallbackToken: IModelToken | undefined;
    static forEach(definition: RpcInterfaceDefinition, callback: (operation: RpcOperation) => void): void;
    readonly interfaceDefinition: RpcInterfaceDefinition;
    get interfaceVersion(): string;
    static lookup(target: string | RpcInterfaceDefinition, operationName: string): RpcOperation;
    readonly operationName: string;
    policy: RpcOperationPolicy;
}

// @public (undocumented)
export namespace RpcOperation {
    export function allowResponseCaching(control?: RpcResponseCacheControl): <T extends RpcInterface>(target: T, propertyKey: string, descriptor: PropertyDescriptor) => void;
    export function setDefaultPolicy(policy: RpcOperationPolicy | RpcOperationPolicyProps): <T extends RpcInterface>(definition: RpcInterfaceDefinition<T>) => void;
    export function setPolicy(policy: RpcOperationPolicy | RpcOperationPolicyProps): <T extends RpcInterface>(target: T, propertyKey: string, descriptor: PropertyDescriptor) => void;
}

// @public
export class RpcOperationPolicy {
    allowResponseCaching: RpcResponseCachingCallback_T;
    allowTokenMismatch: boolean;
    forceStrictMode: boolean;
    invocationCallback: RpcInvocationCallback_T;
    requestCallback: RpcRequestCallback_T;
    retryInterval: RpcRequestInitialRetryIntervalSupplier_T;
    sentCallback: RpcRequestCallback_T;
    token: RpcRequestTokenSupplier_T;
}

// @public (undocumented)
export type RpcOperationPolicyProps = Partial<RpcOperationPolicy>;

// @public
export interface RpcOperationsProfile {
    // (undocumented)
    readonly lastRequest: number;
    // (undocumented)
    readonly lastResponse: number;
}

// @internal
export class RpcPendingQueue {
    // (undocumented)
    static initialize(): void;
    // (undocumented)
    static instance: RpcPendingQueue;
    }

// @public
export class RpcPendingResponse extends RpcControlResponse {
    constructor(message?: string);
    message: string;
}

// @public
export abstract class RpcProtocol {
    constructor(configuration: RpcConfiguration);
    checkToken: boolean;
    readonly configuration: RpcConfiguration;
    static readonly events: BeEvent<RpcProtocolEventHandler>;
    readonly events: BeEvent<RpcProtocolEventHandler>;
    fulfill(request: SerializedRpcRequest): Promise<RpcRequestFulfillment>;
    getCode(status: RpcRequestStatus): number;
    getOperationFromPath(path: string): SerializedRpcOperation;
    getStatus(code: number): RpcRequestStatus;
    inflateToken(tokenFromBody: IModelTokenProps, _request: SerializedRpcRequest): IModelTokenProps;
    readonly invocationType: typeof RpcInvocation;
    // @internal (undocumented)
    onRpcClientInitialized(_definition: RpcInterfaceDefinition, _client: RpcInterface): void;
    // @internal (undocumented)
    onRpcClientTerminated(_definition: RpcInterfaceDefinition, _client: RpcInterface): void;
    // @internal (undocumented)
    onRpcImplInitialized(_definition: RpcInterfaceDefinition, _impl: RpcInterface): void;
    // @internal (undocumented)
    onRpcImplTerminated(_definition: RpcInterfaceDefinition, _impl: RpcInterface): void;
    preserveStreams: boolean;
    abstract readonly requestType: typeof RpcRequest;
    serialize(request: RpcRequest): Promise<SerializedRpcRequest>;
    // (undocumented)
    serializedClientRequestContextHeaderNames: SerializedClientRequestContext;
    supplyPathForOperation(operation: RpcOperation, _request: RpcRequest | undefined): string;
    transferChunkThreshold: number;
}

// @public
export enum RpcProtocolEvent {
    // (undocumented)
    BackendErrorOccurred = 11,
    // (undocumented)
    BackendErrorReceived = 5,
    // (undocumented)
    BackendReportedNotFound = 10,
    // (undocumented)
    BackendReportedPending = 9,
    // (undocumented)
    BackendResponseCreated = 8,
    // (undocumented)
    ConnectionAborted = 6,
    // (undocumented)
    ConnectionErrorReceived = 3,
    // (undocumented)
    RequestCreated = 0,
    // (undocumented)
    RequestReceived = 7,
    // (undocumented)
    ResponseLoaded = 1,
    // (undocumented)
    ResponseLoading = 2,
    // (undocumented)
    UnknownErrorReceived = 4
}

// @public
export type RpcProtocolEventHandler = (type: RpcProtocolEvent, object: RpcRequest | RpcInvocation) => void;

// @internal (undocumented)
export class RpcRegistry {
    // (undocumented)
    definitionClasses: Map<string, RpcInterfaceDefinition>;
    // (undocumented)
    describeAvailableEndpoints(): Promise<RpcInterfaceEndpoints[]>;
    // (undocumented)
    getClientForInterface<T extends RpcInterface>(definition: RpcInterfaceDefinition<T>): T;
    // (undocumented)
    getImplForInterface<T extends RpcInterface>(definition: RpcInterfaceDefinition<T>): T;
    // (undocumented)
    id: () => number;
    // (undocumented)
    implementationClasses: Map<string, RpcInterfaceImplementation>;
    // (undocumented)
    implementations: Map<string, RpcInterface>;
    // (undocumented)
    initializeRpcInterface<T extends RpcInterface>(definition: RpcInterfaceDefinition<T>): void;
    // (undocumented)
    static get instance(): RpcRegistry;
    // (undocumented)
    isRpcInterfaceInitialized<T extends RpcInterface>(definition: RpcInterfaceDefinition<T>): boolean;
    // (undocumented)
    lookupImpl<T extends RpcInterface>(interfaceName: string): T;
    // (undocumented)
    lookupInterfaceDefinition(name: string): RpcInterfaceDefinition;
    // (undocumented)
    proxies: Map<string, RpcInterface>;
    // (undocumented)
    registerImpl<TDefinition extends RpcInterface, TImplementation extends TDefinition>(definition: RpcInterfaceDefinition<TDefinition>, implementation: RpcInterfaceImplementation<TImplementation>): void;
    // (undocumented)
    suppliedImplementations: Map<string, RpcInterface>;
    // (undocumented)
    supplyImplInstance<TDefinition extends RpcInterface, TImplementation extends TDefinition>(definition: RpcInterfaceDefinition<TDefinition>, instance: TImplementation): void;
    // (undocumented)
    terminateRpcInterface<T extends RpcInterface>(definition: RpcInterfaceDefinition<T>): void;
    // (undocumented)
    unregisterImpl<TDefinition extends RpcInterface>(definition: RpcInterfaceDefinition<TDefinition>): void;
}

// @public
export abstract class RpcRequest<TResponse = any> {
    constructor(client: RpcInterface, operation: string, parameters: any[]);
    static get aggregateLoad(): RpcOperationsProfile;
    readonly client: RpcInterface;
    get connecting(): boolean;
    static current(context: RpcInterface): RpcRequest;
    // @internal (undocumented)
    dispose(): void;
    get elapsed(): number;
    static readonly events: BeEvent<RpcRequestEventHandler>;
    get extendedStatus(): string;
    findParameterOfType<T>(requiredProperties: {
        [index: string]: string;
    }): T | undefined;
    findTokenPropsParameter(): IModelTokenProps | undefined;
    // (undocumented)
    protected handleUnknownResponse(code: number): void;
    readonly id: string;
    get lastSubmitted(): number;
    get lastUpdated(): number;
    protected abstract load(): Promise<RpcSerializedValue>;
    method: string;
    static readonly notFoundHandlers: BeEvent<RpcRequestNotFoundHandler>;
    readonly operation: RpcOperation;
    parameters: any[];
    path: string;
    get pending(): boolean;
    readonly protocol: RpcProtocol;
    // (undocumented)
    protected _rawPromise: Promise<Response>;
    get rawResponse(): Promise<Response>;
    // (undocumented)
    protected reject(reason: any): void;
    // (undocumented)
    protected _resolveRaw: (value?: Response | PromiseLike<Response> | undefined) => void;
    readonly response: Promise<TResponse>;
    // (undocumented)
    protected _response: Response | undefined;
    retryInterval: number;
    protected abstract send(): Promise<number>;
    protected abstract setHeader(name: string, value: string): void;
    protected setLastUpdatedTime(): void;
    get status(): RpcRequestStatus;
    // (undocumented)
    submit(): Promise<void>;
}

// @public
export type RpcRequestCallback_T = (request: RpcRequest) => void;

// @public
export interface RpcRequestContext {
    deserialize: (request: SerializedRpcRequest) => Promise<ClientRequestContext>;
    getId: (request: RpcRequest) => string;
    serialize: (request: RpcRequest) => Promise<SerializedClientRequestContext>;
}

// @public
export enum RpcRequestEvent {
    // (undocumented)
    PendingUpdateReceived = 1,
    // (undocumented)
    StatusChanged = 0
}

// @public
export type RpcRequestEventHandler = (type: RpcRequestEvent, request: RpcRequest) => void;

// @public
export interface RpcRequestFulfillment {
    id: string;
    interfaceName: string;
    rawResult: any;
    result: RpcSerializedValue;
    status: number;
}

// @public (undocumented)
export namespace RpcRequestFulfillment {
    // (undocumented)
    export function forUnknownError(request: SerializedRpcRequest, error: any): Promise<RpcRequestFulfillment>;
}

// @public
export type RpcRequestInitialRetryIntervalSupplier_T = (configuration: RpcConfiguration) => number;

// @public
export type RpcRequestNotFoundHandler = (request: RpcRequest, response: RpcNotFoundResponse, resubmit: () => void, reject: (reason: any) => void) => void;

// @public
export enum RpcRequestStatus {
    // (undocumented)
    Created = 1,
    // (undocumented)
    Disposed = 6,
    // (undocumented)
    NotFound = 7,
    // (undocumented)
    Pending = 3,
    // (undocumented)
    Rejected = 5,
    // (undocumented)
    Resolved = 4,
    // (undocumented)
    Submitted = 2,
    // (undocumented)
    Unknown = 0
}

// @public
export type RpcRequestTokenSupplier_T = (request: RpcRequest) => IModelTokenProps | undefined;

// @public
export enum RpcResponseCacheControl {
    // (undocumented)
    Immutable = 1,
    // (undocumented)
    None = 0
}

// @public
export type RpcResponseCachingCallback_T = (request: RpcRequest) => RpcResponseCacheControl;

// @public (undocumented)
export interface RpcSerializedValue {
    // (undocumented)
    chunks?: number;
    // (undocumented)
    data: Uint8Array[];
    // (undocumented)
    objects: string;
    // (undocumented)
    stream?: Readable;
}

// @public (undocumented)
export namespace RpcSerializedValue {
    // (undocumented)
    export function create(objects?: string, data?: Uint8Array[]): RpcSerializedValue;
}

// @alpha
export interface SceneLightsProps {
    // (undocumented)
    sunDir?: XYZProps;
}

// @beta
export interface SectionLocationProps extends GeometricElement3dProps {
    categorySelectorId?: Id64String;
    clipGeometry?: string;
    modelSelectorId?: Id64String;
    sectionType?: SectionType;
    viewAttachment?: Id64String;
}

// @public
export enum SectionType {
    // (undocumented)
    Detail = 4,
    // (undocumented)
    Elevation = 5,
    // (undocumented)
    Plan = 6,
    // (undocumented)
    Section = 3
}

// @public
export interface SerializedRpcOperation {
    // (undocumented)
    encodedRequest?: string;
    // (undocumented)
    interfaceDefinition: string;
    // (undocumented)
    interfaceVersion: string;
    // (undocumented)
    operationName: string;
}

// @public
export interface SerializedRpcRequest extends SerializedClientRequestContext {
    // (undocumented)
    caching: RpcResponseCacheControl;
    // (undocumented)
    ip?: string;
    // (undocumented)
    method: string;
    // (undocumented)
    operation: SerializedRpcOperation;
    // (undocumented)
    parameters: RpcSerializedValue;
    // (undocumented)
    path: string;
}

// @public (undocumented)
export class ServerError extends IModelError {
    constructor(errorNumber: number, message: string, log?: LogFunction);
}

// @public (undocumented)
export class ServerTimeoutError extends ServerError {
    constructor(message: string, log?: LogFunction);
}

// @beta
export interface SheetBorderTemplateProps extends ElementProps {
    // (undocumented)
    height?: number;
    // (undocumented)
    width?: number;
}

// @beta
export interface SheetProps extends ElementProps {
    // (undocumented)
    attachments?: Id64String[];
    // (undocumented)
    height?: number;
    // (undocumented)
    scale?: number;
    // (undocumented)
    sheetTemplate?: Id64String;
    // (undocumented)
    width?: number;
}

// @beta
export interface SheetTemplateProps extends ElementProps {
    // (undocumented)
    border?: Id64String;
    // (undocumented)
    height?: number;
    // (undocumented)
    width?: number;
}

// @internal (undocumented)
export class SilhouetteEdgeArgs extends EdgeArgs {
    // (undocumented)
    clear(): void;
    // (undocumented)
    init(meshEdges?: MeshEdges): boolean;
    // (undocumented)
    normals?: OctEncodedNormalPair[];
}

// @public
export interface SkyBoxImageProps {
    texture?: Id64String;
    textures?: SkyCubeProps;
    type?: SkyBoxImageType;
}

// @public
export enum SkyBoxImageType {
    Cube = 2,
    // @internal
    Cylindrical = 3,
    // (undocumented)
    None = 0,
    Spherical = 1
}

// @public
export interface SkyBoxProps {
    display?: boolean;
    groundColor?: ColorDefProps;
    groundExponent?: number;
    image?: SkyBoxImageProps;
    nadirColor?: ColorDefProps;
    skyColor?: ColorDefProps;
    skyExponent?: number;
    twoColor?: boolean;
    zenithColor?: ColorDefProps;
}

// @public
export interface SkyCubeProps {
    back?: Id64String;
    bottom?: Id64String;
    front?: Id64String;
    left?: Id64String;
    right?: Id64String;
    top?: Id64String;
}

// @beta
export interface SnapRequestProps {
    // (undocumented)
    closePoint: XYZProps;
    // (undocumented)
    decorationGeometry?: DecorationGeometryProps[];
    // @alpha (undocumented)
    geometryClass?: GeometryClass;
    // (undocumented)
    id: Id64String;
    // (undocumented)
    intersectCandidates?: Id64Array;
    // (undocumented)
    snapAperture?: number;
    // (undocumented)
    snapDivisor?: number;
    // (undocumented)
    snapModes?: number[];
    // (undocumented)
    subCategoryId?: Id64String;
    // (undocumented)
    testPoint: XYZProps;
    // (undocumented)
    viewFlags?: any;
    // (undocumented)
    worldToView: Matrix4dProps;
}

// @beta
export interface SnapResponseProps {
    // (undocumented)
    curve?: any;
    // (undocumented)
    geomType?: number;
    // (undocumented)
    heat?: number;
    // (undocumented)
    hitPoint?: XYZProps;
    // (undocumented)
    intersectCurve?: any;
    // (undocumented)
    intersectId?: string;
    // (undocumented)
    normal?: XYZProps;
    // (undocumented)
    parentGeomType?: number;
    // (undocumented)
    snapMode?: number;
    // (undocumented)
    snapPoint?: XYZProps;
    // (undocumented)
    status: number;
}

// @beta
export abstract class SnapshotIModelRpcInterface extends RpcInterface {
    // (undocumented)
    closeSnapshot(_iModelToken: IModelTokenProps): Promise<boolean>;
    static getClient(): SnapshotIModelRpcInterface;
    static readonly interfaceName = "SnapshotIModelRpcInterface";
    static interfaceVersion: string;
    // (undocumented)
    openSnapshot(_fileName: string): Promise<IModelProps>;
}

// @beta
export interface SolarShadowProps {
    bias?: number;
    color?: ColorDefProps;
}

// @beta
export namespace SolarShadows {
    export interface Props {
        bias?: number;
        color?: ColorDefProps;
    }
    export class Settings implements Props {
        constructor(props?: SolarShadowProps);
        // @alpha
        bias: number;
        // (undocumented)
        clone(result?: SolarShadows.Settings): SolarShadows.Settings;
        color: ColorDef;
        // (undocumented)
        equals(other: SolarShadows.Settings): boolean;
        // (undocumented)
        static fromJSON(props?: Props): Settings;
        // (undocumented)
        toJSON(): Props;
    }
}

// @beta
export namespace SpatialClassificationProps {
    export interface Classifier {
        expand: number;
        flags: FlagsProps;
        modelId: Id64String;
        name: string;
    }
    export enum Display {
        Dimmed = 2,
        ElementColor = 4,
        Hilite = 3,
        Off = 0,
        On = 1
    }
    export function equalClassifiers(lhs: Classifier, rhs: Classifier): boolean;
    export function equalFlags(lhs: FlagsProps, rhs: FlagsProps): boolean;
    export function equalProperties(lhs: Properties, rhs: Properties): boolean;
    export class Flags implements FlagsProps {
        constructor(inside?: Display, outside?: Display, isVolumeClassifier?: boolean);
        // (undocumented)
        inside: Display;
        // (undocumented)
        isVolumeClassifier: boolean;
        // (undocumented)
        outside: Display;
        readonly type = 0;
    }
    export interface FlagsProps {
        // (undocumented)
        inside: SpatialClassificationProps.Display;
        // (undocumented)
        isVolumeClassifier?: boolean;
        // (undocumented)
        outside: SpatialClassificationProps.Display;
        readonly type: number;
    }
    export interface Properties extends Classifier {
        // (undocumented)
        isActive: boolean;
    }
}

// @public
export interface SpatialViewDefinitionProps extends ViewDefinition3dProps {
    // (undocumented)
    modelSelectorId: Id64String;
}

// @internal
export class Spot extends Light {
    constructor(opts?: SpotProps);
    // (undocumented)
    inner: Angle;
    // (undocumented)
    outer: Angle;
}

// @internal
export interface SpotProps extends LightProps {
    // (undocumented)
    inner?: AngleProps;
    // (undocumented)
    outer?: AngleProps;
}

// @public
export class SubCategoryAppearance {
    constructor(props?: SubCategoryAppearance.Props);
    // (undocumented)
    clone(): SubCategoryAppearance;
    readonly color: ColorDef;
    // (undocumented)
    static defaults: SubCategoryAppearance;
    // @internal (undocumented)
    readonly dontLocate: boolean;
    // @internal (undocumented)
    readonly dontPlot: boolean;
    // @internal (undocumented)
    readonly dontSnap: boolean;
    // (undocumented)
    equals(other: SubCategoryAppearance): boolean;
    get fillColor(): ColorDef;
    // @internal (undocumented)
    protected readonly _fillColor?: ColorDef;
    get fillTransparency(): number;
    // @internal (undocumented)
    protected readonly _fillTransparency?: number;
    readonly invisible: boolean;
    readonly materialId: Id64String;
    readonly priority: number;
    readonly styleId: Id64String;
    // @internal (undocumented)
    toJSON(): SubCategoryAppearance.Props;
    readonly transparency: number;
    readonly weight: number;
}

// @public (undocumented)
export namespace SubCategoryAppearance {
    export interface Props {
        color?: ColorDefProps;
        // @internal (undocumented)
        dontLocate?: boolean;
        // @internal (undocumented)
        dontPlot?: boolean;
        // @internal (undocumented)
        dontSnap?: boolean;
        fill?: ColorDefProps;
        invisible?: boolean;
        material?: Id64String;
        priority?: number;
        style?: Id64String;
        transp?: number;
        transpFill?: number;
        weight?: number;
    }
}

// @public
export class SubCategoryOverride {
    get anyOverridden(): boolean;
    readonly color?: ColorDef;
    static defaults: SubCategoryOverride;
    equals(other: SubCategoryOverride): boolean;
    static fromJSON(json?: SubCategoryAppearance.Props): SubCategoryOverride;
    readonly invisible?: boolean;
    readonly material?: Id64String;
    override(appearance: SubCategoryAppearance): SubCategoryAppearance;
    readonly priority?: number;
    // @internal
    readonly style?: Id64String;
    // @internal
    toJSON(): SubCategoryAppearance.Props;
    readonly transparency?: number;
    readonly weight?: number;
}

// @public
export interface SubCategoryProps extends DefinitionElementProps {
    // (undocumented)
    appearance?: SubCategoryAppearance.Props;
    // (undocumented)
    description?: string;
}

// @public
export interface SubjectProps extends ElementProps {
    // (undocumented)
    description?: string;
}

// @alpha
export enum TerrainHeightOriginMode {
    // (undocumented)
    Geodetic = 0,
    // (undocumented)
    Geoid = 1,
    // (undocumented)
    Ground = 2
}

// @alpha
export interface TerrainProps {
    applyLighting?: boolean;
    exaggeration?: number;
    heightOrigin?: number;
    heightOriginMode?: TerrainHeightOriginMode;
    providerName?: string;
}

// @alpha
export type TerrainProviderName = "CesiumWorldTerrain";

// @alpha
export class TerrainSettings {
    constructor(providerName?: TerrainProviderName, exaggeration?: number, applyLighting?: boolean, heightOrigin?: number, heightOriginMode?: TerrainHeightOriginMode);
    readonly applyLighting: boolean;
    clone(changedProps?: TerrainProps): TerrainSettings;
    // (undocumented)
    equals(other: TerrainSettings): boolean;
    equalsJSON(json?: BackgroundMapProps): boolean;
    readonly exaggeration: number;
    // (undocumented)
    static fromJSON(json?: TerrainProps): TerrainSettings;
    readonly heightOrigin: number;
    readonly heightOriginMode: TerrainHeightOriginMode;
    readonly providerName: TerrainProviderName;
    // (undocumented)
    toJSON(): TerrainProps;
}

// @internal
export class TestRpcManager {
    // (undocumented)
    static initialize(interfaces: RpcInterfaceDefinition[]): void;
}

// @public
export class TextString {
    constructor(props: TextStringProps);
    bold?: boolean;
    font: number;
    // (undocumented)
    height: number;
    italic?: boolean;
    readonly origin: Point3d;
    readonly rotation: YawPitchRollAngles;
    text: string;
    // (undocumented)
    toJSON(): TextStringProps;
    // (undocumented)
    transformInPlace(transform: Transform): boolean;
    underline?: boolean;
    // (undocumented)
    get width(): number;
    // (undocumented)
    widthFactor?: number;
}

// @public
export interface TextStringProps {
    bold?: boolean;
    font: number;
    // (undocumented)
    height: number;
    italic?: boolean;
    origin?: XYZProps;
    rotation?: YawPitchRollProps;
    text: string;
    underline?: boolean;
    // (undocumented)
    widthFactor?: number;
}

// @beta (undocumented)
export enum TextureFlags {
    // (undocumented)
    None = 0
}

// @beta
export class TextureMapping {
    constructor(tx: RenderTexture, params: TextureMapping.Params);
    // @internal (undocumented)
    computeUVParams(visitor: PolyfaceVisitor, transformToImodel: Transform): Point2d[] | undefined;
    readonly params: TextureMapping.Params;
    readonly texture: RenderTexture;
}

// @beta (undocumented)
export namespace TextureMapping {
    export enum Mode {
        // @internal (undocumented)
        Cubic = 4,
        // @internal (undocumented)
        Cylindrical = 6,
        // @internal (undocumented)
        DirectionalDrape = 3,
        // (undocumented)
        ElevationDrape = 1,
        // @internal
        FrontProject = 8,
        // (undocumented)
        None = -1,
        // (undocumented)
        Parametric = 0,
        // (undocumented)
        Planar = 2,
        // @internal (undocumented)
        Solid = 7,
        // @internal (undocumented)
        Spherical = 5
    }
    export interface ParamProps {
        mapMode?: TextureMapping.Mode;
        textureMat2x3?: TextureMapping.Trans2x3;
        textureWeight?: number;
        // @internal (undocumented)
        worldMapping?: boolean;
    }
    export class Params {
        constructor(props?: ParamProps);
        // @internal
        computeUVParams(visitor: IndexedPolyfaceVisitor, transformToImodel: Transform): Point2d[] | undefined;
        mode: TextureMapping.Mode;
        textureMatrix: TextureMapping.Trans2x3;
        weight: number;
        // @internal (undocumented)
        worldMapping: boolean;
    }
    export class Trans2x3 {
        constructor(t00?: number, t01?: number, t02?: number, t10?: number, t11?: number, t12?: number);
        // (undocumented)
        setTransform(): void;
        // (undocumented)
        get transform(): Transform;
        }
}

// @beta
export interface TextureMapProps {
    pattern_angle?: number;
    pattern_flip?: boolean;
    pattern_mapping?: TextureMapping.Mode;
    pattern_offset?: DPoint2dProps;
    pattern_scale?: DPoint2dProps;
    pattern_scalemode?: TextureMapUnits;
    pattern_u_flip?: boolean;
    pattern_weight?: number;
    TextureId: Id64String;
}

// @beta (undocumented)
export enum TextureMapUnits {
    // (undocumented)
    Feet = 5,
    // (undocumented)
    Inches = 6,
    // (undocumented)
    Meters = 3,
    // (undocumented)
    Millimeters = 4,
    // (undocumented)
    Relative = 0
}

// @beta
export interface TextureProps extends DefinitionElementProps {
    data: string;
    description?: string;
    flags: TextureFlags;
    format: ImageSourceFormat;
    height: number;
    width: number;
}

// @alpha
export interface ThumbnailFormatProps {
    format: "jpeg" | "png";
    height: number;
    width: number;
}

// @alpha
export interface ThumbnailProps extends ThumbnailFormatProps {
    image: Uint8Array;
}

// @internal (undocumented)
export interface TileContentDescription extends TileContentMetadata {
    // (undocumented)
    readonly featureTableStartPos: number;
}

// @beta (undocumented)
export interface TileContentIdentifier {
    // (undocumented)
    contentId: string;
    // (undocumented)
    guid: string | undefined;
    // (undocumented)
    iModelToken: IModelToken;
    // (undocumented)
    treeId: string;
}

// @internal
export interface TileContentMetadata {
    // (undocumented)
    readonly contentRange: Range3d;
    // (undocumented)
    readonly emptySubRangeMask: number;
    // (undocumented)
    readonly isLeaf: boolean;
    // (undocumented)
    readonly sizeMultiplier?: number;
}

// @internal
export const enum TileFormat {
    // (undocumented)
    A3x = 5780289,
    // (undocumented)
    B3dm = 1835283298,
    // (undocumented)
    Cmpt = 1953525091,
    // (undocumented)
    Gltf = 1179937895,
    // (undocumented)
    I3dm = 1835283305,
    // (undocumented)
    IModel = 1818512745,
    // (undocumented)
    Pnts = 1937010288,
    // (undocumented)
    Unknown = 0
}

// @internal
export function tileFormatFromNumber(formatNumber: number): TileFormat;

// @internal
export abstract class TileHeader {
    constructor(stream: ByteStream);
    // (undocumented)
    get format(): TileFormat;
    protected invalidate(): void;
    abstract get isValid(): boolean;
    // (undocumented)
    version: number;
}

// @internal
export interface TileMetadata extends TileContentMetadata {
    // (undocumented)
    readonly contentId: string;
    // (undocumented)
    readonly range: Range3d;
}

// @internal
export class TileMetadataReader {
    constructor(type: BatchType, is2d: boolean, options: TileOptions);
    read(stream: ByteStream, props: TileProps): TileMetadata;
}

// @internal (undocumented)
export interface TileOptions {
    // (undocumented)
    readonly disableMagnification: boolean;
    // (undocumented)
    readonly enableImprovedElision: boolean;
    // (undocumented)
    readonly enableInstancing: boolean;
    // (undocumented)
    readonly maximumMajorTileFormatVersion: number;
    // (undocumented)
    readonly useProjectExtents: boolean;
}

// @internal (undocumented)
export interface TileProps {
    contentId: string;
    contentRange?: Range3dProps;
    isLeaf?: boolean;
    maximumSize: number;
    range: Range3dProps;
    sizeMultiplier?: number;
    transformToRoot?: TransformProps;
}

// @internal
export class TileReadError extends BentleyError {
    constructor(status: TileReadStatus, message?: string);
    // (undocumented)
    get wasCanceled(): boolean;
}

// @internal
export const enum TileReadStatus {
    // (undocumented)
    Canceled = 7,
    // (undocumented)
    InvalidBatchTable = 3,
    // (undocumented)
    InvalidFeatureTable = 5,
    // (undocumented)
    InvalidHeader = 2,
    // (undocumented)
    InvalidScene = 4,
    // (undocumented)
    InvalidTileData = 1,
    // (undocumented)
    NewerMajorVersion = 6,
    // (undocumented)
    Success = 0
}

// @internal
export interface TileTreeContentIds {
    // (undocumented)
    contentIds: string[];
    // (undocumented)
    treeId: string;
}

// @internal
export interface TileTreeMetadata {
    // (undocumented)
    readonly contentRange?: Range3d;
    // (undocumented)
    readonly is2d: boolean;
    // (undocumented)
    readonly modelId: Id64String;
}

// @internal (undocumented)
export interface TileTreeProps {
    contentRange?: Range3dProps;
    formatVersion?: number;
    id: string;
    location: TransformProps;
    maxTilesToSkip?: number;
    rootTile: TileProps;
    yAxisUp?: boolean;
}

// @beta
export class Tween {
    constructor(_group: Tweens, _object: any);
    // (undocumented)
    chain(...tweens: Tween[]): this;
    // (undocumented)
    delay(amount?: number): this;
    // (undocumented)
    duration(d: number): this;
    // (undocumented)
    easing(easingFunction?: EasingFunction): this;
    // (undocumented)
    end(): this;
    // (undocumented)
    getId(): number;
    // (undocumented)
    group(group: Tweens): this;
    // (undocumented)
    interpolation(interpolationFunction?: InterpolationFunction): this;
    // (undocumented)
    get isPaused(): boolean;
    // (undocumented)
    get isPlaying(): boolean;
    // (undocumented)
    onComplete(callback?: TweenCallback): this;
    // (undocumented)
    onRepeat(callback: TweenCallback): this;
    // (undocumented)
    onStart(callback: TweenCallback): this;
    // (undocumented)
    onStop(callback: TweenCallback): this;
    // (undocumented)
    onUpdate(callback: UpdateCallback): this;
    // (undocumented)
    pause(time: number): this;
    // (undocumented)
    repeat(times: number): this;
    // (undocumented)
    repeatDelay(amount: number): this;
    // (undocumented)
    resume(time?: number): this;
    // (undocumented)
    start(time?: string | number): this;
    // (undocumented)
    stop(): this;
    // (undocumented)
    stopChainedTweens(): void;
    // (undocumented)
    to(properties: any, duration?: number): this;
    // (undocumented)
    update(time: number): boolean;
    // (undocumented)
    yoyo(yoyo: boolean): this;
    }

// @beta (undocumented)
export type TweenCallback = (obj: any) => void;

// @beta
export class Tweens {
    // (undocumented)
    add(tween: Tween): void;
    create(from: any, opts?: {
        to: any;
        duration: number;
        onUpdate: UpdateCallback;
        onComplete?: TweenCallback;
        delay?: number;
        start?: boolean;
        easing?: EasingFunction;
        interpolation?: InterpolationFunction;
    }): Tween;
    // (undocumented)
    getAll(): any[];
    // (undocumented)
    nextId(): number;
    // (undocumented)
    remove(tween: Tween): void;
    // (undocumented)
    removeAll(): void;
    // (undocumented)
    update(time?: number, preserve?: boolean): boolean;
}

// @public
export class TypeDefinition extends RelatedElement {
}

// @public
export interface TypeDefinitionElementProps extends DefinitionElementProps {
    // (undocumented)
    recipe?: RelatedElementProps;
}

// @beta (undocumented)
export type UpdateCallback = (obj: any, t: number) => void;

// @public (undocumented)
export interface ViewAttachmentLabelProps extends GeometricElement2dProps {
    // (undocumented)
    viewAttachment?: RelatedElementProps;
}

// @public
export interface ViewAttachmentProps extends GeometricElement2dProps {
    // (undocumented)
    view: RelatedElementProps;
}

// @public
export interface ViewDefinition2dProps extends ViewDefinitionProps {
    // (undocumented)
    angle: AngleProps;
    // (undocumented)
    baseModelId: Id64String;
    // (undocumented)
    delta: XYProps;
    // (undocumented)
    origin: XYProps;
}

// @public
export interface ViewDefinition3dProps extends ViewDefinitionProps {
    angles?: YawPitchRollProps;
    camera: CameraProps;
    cameraOn: boolean;
    extents: XYZProps;
    origin: XYZProps;
}

// @public
export interface ViewDefinitionProps extends DefinitionElementProps {
    // (undocumented)
    categorySelectorId: Id64String;
    // (undocumented)
    description?: string;
    // (undocumented)
    displayStyleId: Id64String;
}

// @alpha (undocumented)
export namespace ViewFlag {
    export class Overrides {
        constructor(flags?: ViewFlags);
        // (undocumented)
        anyOverridden(): boolean;
        apply(base: ViewFlags): ViewFlags;
        // (undocumented)
        clear(): void;
        // (undocumented)
        clearClipVolume(): void;
        // (undocumented)
        clearPresent(flag: PresenceFlag): void;
        // @internal
        get clipVolumeOverride(): boolean | undefined;
        // (undocumented)
        clone(out?: Overrides): Overrides;
        // (undocumented)
        copyFrom(other: Overrides): void;
        // (undocumented)
        isPresent(flag: PresenceFlag): boolean;
        // (undocumented)
        overrideAll(flags?: ViewFlags): void;
        // (undocumented)
        setApplyLighting(val: boolean): void;
        // (undocumented)
        setEdgeMask(val: number): void;
        // (undocumented)
        setForceSurfaceDiscard(val: boolean): void;
        // (undocumented)
        setIgnoreGeometryMap(val: boolean): void;
        // (undocumented)
        setMonochrome(val: boolean): void;
        // (undocumented)
        setPresent(flag: PresenceFlag): void;
        // (undocumented)
        setRenderMode(val: RenderMode): void;
        // (undocumented)
        setShowBackgroundMap(val: boolean): void;
        // (undocumented)
        setShowClipVolume(val: boolean): void;
        // (undocumented)
        setShowConstructions(val: boolean): void;
        // (undocumented)
        setShowDimensions(val: boolean): void;
        // (undocumented)
        setShowFill(val: boolean): void;
        // (undocumented)
        setShowHiddenEdges(val: boolean): void;
        // (undocumented)
        setShowMaterials(val: boolean): void;
        // (undocumented)
        setShowPatterns(val: boolean): void;
        // (undocumented)
        setShowShadows(val: boolean): void;
        // (undocumented)
        setShowStyles(val: boolean): void;
        // (undocumented)
        setShowTextures(val: boolean): void;
        // (undocumented)
        setShowTransparency(val: boolean): void;
        // (undocumented)
        setShowVisibleEdges(val: boolean): void;
        // (undocumented)
        setShowWeights(val: boolean): void;
        // (undocumented)
        setUseHlineMaterialColors(val: boolean): void;
        }
    // (undocumented)
    export const enum PresenceFlag {
        // (undocumented)
        kBackgroundMap = 21,
        // (undocumented)
        kClipVolume = 15,
        // (undocumented)
        kConstructions = 16,
        // (undocumented)
        kDimensions = 2,
        // (undocumented)
        kEdgeMask = 20,
        // (undocumented)
        kFill = 8,
        // (undocumented)
        kForceSurfaceDiscard = 22,
        // (undocumented)
        kGeometryMap = 18,
        // (undocumented)
        kHiddenEdges = 12,
        // (undocumented)
        kHlineMaterialColors = 19,
        // (undocumented)
        kLighting = 13,
        // (undocumented)
        kMaterials = 10,
        // (undocumented)
        kMonochrome = 17,
        // (undocumented)
        kPatterns = 3,
        // (undocumented)
        kRenderMode = 0,
        // (undocumented)
        kShadows = 14,
        // (undocumented)
        kStyles = 5,
        // (undocumented)
        kText = 1,
        // (undocumented)
        kTextures = 9,
        // (undocumented)
        kTransparency = 6,
        // (undocumented)
        kUnused = 7,
        // (undocumented)
        kVisibleEdges = 11,
        // (undocumented)
        kWeights = 4
    }
}

// @public
export interface ViewFlagProps {
    acs?: boolean;
    ambientOcclusion?: boolean;
    backgroundMap?: boolean;
    clipVol?: boolean;
    // @internal
    edgeMask?: number;
    forceSurfaceDiscard?: boolean;
    grid?: boolean;
    hidEdges?: boolean;
    hlMatColors?: boolean;
    monochrome?: boolean;
    noCameraLights?: boolean;
    noConstruct?: boolean;
    noDim?: boolean;
    noFill?: boolean;
    noMaterial?: boolean;
    noPattern?: boolean;
    noSolarLight?: boolean;
    noSourceLights?: boolean;
    noStyle?: boolean;
    noTexture?: boolean;
    noTransp?: boolean;
    noWeight?: boolean;
    renderMode?: number;
    shadows?: boolean;
    visEdges?: boolean;
}

// @public
export class ViewFlags {
    acsTriad: boolean;
    ambientOcclusion: boolean;
    backgroundMap: boolean;
    cameraLights: boolean;
    clipVolume: boolean;
    // (undocumented)
    clone(out?: ViewFlags): ViewFlags;
    constructions: boolean;
    // (undocumented)
    static createFrom(other?: ViewFlags, out?: ViewFlags): ViewFlags;
    dimensions: boolean;
    // @internal
    edgeMask: number;
    // @internal (undocumented)
    edgesRequired(): boolean;
    // (undocumented)
    equals(other: ViewFlags): boolean;
    fill: boolean;
    forceSurfaceDiscard: boolean;
    // (undocumented)
    static fromJSON(json?: ViewFlagProps): ViewFlags;
    grid: boolean;
    hiddenEdges: boolean;
    // @internal (undocumented)
    hiddenEdgesVisible(): boolean;
    hLineMaterialColors: boolean;
    get lighting(): boolean;
    set lighting(enable: boolean);
    materials: boolean;
    monochrome: boolean;
    // @internal
    noGeometryMap: boolean;
    patterns: boolean;
    renderMode: RenderMode;
    shadows: boolean;
    solarLight: boolean;
    sourceLights: boolean;
    styles: boolean;
    textures: boolean;
    // (undocumented)
    toJSON(): ViewFlagProps;
    transparency: boolean;
    visibleEdges: boolean;
    weights: boolean;
}

// @public
export interface ViewQueryParams extends EntityQueryParams {
    // (undocumented)
    wantPrivate?: boolean;
}

// @public
export interface ViewStateProps {
    // (undocumented)
    categorySelectorProps: CategorySelectorProps;
    // (undocumented)
    displayStyleProps: DisplayStyleProps;
    // (undocumented)
    modelSelectorProps?: ModelSelectorProps;
    // @beta (undocumented)
    sheetAttachments?: Id64Array;
    // @beta (undocumented)
    sheetProps?: SheetProps;
    // (undocumented)
    viewDefinitionProps: ViewDefinitionProps;
}

// @internal (undocumented)
export const WEB_RPC_CONSTANTS: {
    CONTENT: string;
    TEXT: string;
    ANY_TEXT: string;
    BINARY: string;
    MULTIPART: string;
};

// @public
export abstract class WebAppRpcProtocol extends RpcProtocol {
    constructor(configuration: RpcConfiguration);
    static computeContentType(httpType: string | null | undefined): RpcContentType;
    getCode(status: RpcRequestStatus): number;
    getStatus(code: number): RpcRequestStatus;
    handleOpenApiDescriptionRequest(_req: HttpServerRequest, res: HttpServerResponse): void;
    handleOperationGetRequest(req: HttpServerRequest, res: HttpServerResponse): Promise<void>;
    handleOperationPostRequest(req: HttpServerRequest, res: HttpServerResponse): Promise<void>;
    abstract info: OpenAPIInfo;
    isTimeout(code: number): boolean;
    // @internal
    get openAPIDescription(): RpcOpenAPIDescription;
    pathPrefix: string;
    // (undocumented)
    preserveStreams: boolean;
    readonly requestType: typeof WebAppRpcRequest;
    // @internal
    abstract supplyPathParametersForOperation(_operation: RpcOperation): OpenAPIParameter[];
}

// @public
export class WebAppRpcRequest extends RpcRequest {
    constructor(client: RpcInterface, operation: string, parameters: any[]);
    protected static computeTransportType(value: RpcSerializedValue, source: any): RpcContentType;
    // (undocumented)
    protected handleUnknownResponse(code: number): void;
    // (undocumented)
    protected load(): Promise<RpcSerializedValue>;
    static maxUrlComponentSize: number;
    metadata: {
        status: number;
        message: string;
    };
    method: HttpMethod_T;
    static parseRequest(protocol: WebAppRpcProtocol, req: HttpServerRequest): Promise<SerializedRpcRequest>;
    readonly protocol: WebAppRpcProtocol;
    protected send(): Promise<number>;
    static sendResponse(protocol: WebAppRpcProtocol, request: SerializedRpcRequest, fulfillment: RpcRequestFulfillment, res: HttpServerResponse): void;
    protected setHeader(name: string, value: string): void;
    }

// @internal
export abstract class WipRpcInterface extends RpcInterface {
    // (undocumented)
    attachChangeCache(_iModelToken: IModelTokenProps): Promise<void>;
    // (undocumented)
    detachChangeCache(_iModelToken: IModelTokenProps): Promise<void>;
    // (undocumented)
    getChangedElements(_iModelToken: IModelTokenProps, _startChangesetId: string, _endChangesetId: string): Promise<ChangedElements | undefined>;
    static getClient(): WipRpcInterface;
    static readonly interfaceName = "WipRpcInterface";
    static interfaceVersion: string;
    // (undocumented)
    isChangeCacheAttached(_iModelToken: IModelTokenProps): Promise<boolean>;
    // (undocumented)
    isChangesetProcessed(_iModelToken: IModelTokenProps, _changesetId: string): Promise<boolean>;
    // (undocumented)
    placeholder(_iModelToken: IModelTokenProps): Promise<string>;
}


// (No @packageDocumentation comment for this package)

```
