## API Report File for "@bentley/imodeljs-frontend"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AccessToken } from '@bentley/imodeljs-clients';
import { AmbientOcclusion } from '@bentley/imodeljs-common';
import { AnalysisStyle } from '@bentley/imodeljs-common';
import { Angle } from '@bentley/geometry-core';
import { Arc3d } from '@bentley/geometry-core';
import { AuthorizedClientRequestContext } from '@bentley/imodeljs-clients';
import { AuxCoordSystem2dProps } from '@bentley/imodeljs-common';
import { AuxCoordSystem3dProps } from '@bentley/imodeljs-common';
import { AuxCoordSystemProps } from '@bentley/imodeljs-common';
import { AxisAlignedBox3d } from '@bentley/imodeljs-common';
import { BackgroundMapProps } from '@bentley/imodeljs-common';
import { BackgroundMapSettings } from '@bentley/imodeljs-common';
import { BatchType } from '@bentley/imodeljs-common';
import { BeDuration } from '@bentley/bentleyjs-core';
import { BeEvent } from '@bentley/bentleyjs-core';
import { BentleyStatus } from '@bentley/bentleyjs-core';
import { BeTimePoint } from '@bentley/bentleyjs-core';
import { BeUiEvent } from '@bentley/bentleyjs-core';
import { ByteStream } from '@bentley/bentleyjs-core';
import { Camera } from '@bentley/imodeljs-common';
import { Cartographic } from '@bentley/imodeljs-common';
import { CartographicRange } from '@bentley/imodeljs-common';
import { CategorySelectorProps } from '@bentley/imodeljs-common';
import { ClientRequestContext } from '@bentley/bentleyjs-core';
import { ClipPlane } from '@bentley/geometry-core';
import { ClipShape } from '@bentley/geometry-core';
import { ClipVector } from '@bentley/geometry-core';
import { Code } from '@bentley/imodeljs-common';
import { CodeSpec } from '@bentley/imodeljs-common';
import { ColorDef } from '@bentley/imodeljs-common';
import { ColorDefProps } from '@bentley/imodeljs-common';
import { ColorIndex } from '@bentley/imodeljs-common';
import { ContextRealityModelProps } from '@bentley/imodeljs-common';
import { ConvexClipPlaneSet } from '@bentley/geometry-core';
import { CurvePrimitive } from '@bentley/geometry-core';
import { DevToolsStatsOptions } from '@bentley/imodeljs-common';
import { Dictionary } from '@bentley/bentleyjs-core';
import { DisplayStyle3dSettings } from '@bentley/imodeljs-common';
import { DisplayStyleProps } from '@bentley/imodeljs-common';
import { DisplayStyleSettings } from '@bentley/imodeljs-common';
import { EasingFunction } from '@bentley/imodeljs-common';
import { EcefLocationProps } from '@bentley/imodeljs-common';
import { EdgeArgs } from '@bentley/imodeljs-common';
import { ElementAlignedBox2d } from '@bentley/imodeljs-common';
import { ElementAlignedBox3d } from '@bentley/imodeljs-common';
import { ElementProps } from '@bentley/imodeljs-common';
import { EntityProps } from '@bentley/imodeljs-common';
import { EntityQueryParams } from '@bentley/imodeljs-common';
import { EnvironmentProps } from '@bentley/imodeljs-common';
import { Feature } from '@bentley/imodeljs-common';
import { FeatureIndex } from '@bentley/imodeljs-common';
import { FeatureIndexType } from '@bentley/imodeljs-common';
import { FeatureLogEntry } from '@bentley/imodeljs-clients';
import { FeatureTable } from '@bentley/imodeljs-common';
import { FillFlags } from '@bentley/imodeljs-common';
import { FontMap } from '@bentley/imodeljs-common';
import { Format } from '@bentley/imodeljs-quantity';
import { FormatterSpec } from '@bentley/imodeljs-quantity';
import { Frustum } from '@bentley/imodeljs-common';
import { FrustumPlanes } from '@bentley/imodeljs-common';
import * as Fuse from 'fuse.js';
import { GeoCoordinatesResponseProps } from '@bentley/imodeljs-common';
import { GeometricModel2dProps } from '@bentley/imodeljs-common';
import { GeometricModel3dProps } from '@bentley/imodeljs-common';
import { GeometricModelProps } from '@bentley/imodeljs-common';
import { GeometryClass } from '@bentley/imodeljs-common';
import { GeometryQuery } from '@bentley/geometry-core';
import { GeometryStreamProps } from '@bentley/imodeljs-common';
import { GltfBufferData } from '@bentley/imodeljs-common';
import { GltfBufferView } from '@bentley/imodeljs-common';
import { GltfDataType } from '@bentley/imodeljs-common';
import { Gradient } from '@bentley/imodeljs-common';
import { GraphicParams } from '@bentley/imodeljs-common';
import { GroundPlane } from '@bentley/imodeljs-common';
import { GuidString } from '@bentley/bentleyjs-core';
import { HiddenLine } from '@bentley/imodeljs-common';
import { Hilite } from '@bentley/imodeljs-common';
import { I18N } from '@bentley/imodeljs-i18n';
import { I18NNamespace } from '@bentley/imodeljs-i18n';
import { I18NOptions } from '@bentley/imodeljs-i18n';
import { IAuthorizationClient } from '@bentley/imodeljs-clients';
import { Id64 } from '@bentley/bentleyjs-core';
import { Id64Arg } from '@bentley/bentleyjs-core';
import { Id64Array } from '@bentley/bentleyjs-core';
import { Id64Set } from '@bentley/bentleyjs-core';
import { Id64String } from '@bentley/bentleyjs-core';
import { IDisposable } from '@bentley/bentleyjs-core';
import { ImageBuffer } from '@bentley/imodeljs-common';
import { ImageBufferFormat } from '@bentley/imodeljs-common';
import { ImageSource } from '@bentley/imodeljs-common';
import { ImageSourceFormat } from '@bentley/imodeljs-common';
import { IModel } from '@bentley/imodeljs-common';
import { IModelClient } from '@bentley/imodeljs-clients';
import { IModelCoordinatesResponseProps } from '@bentley/imodeljs-common';
import { IModelToken } from '@bentley/imodeljs-common';
import { IModelVersion } from '@bentley/imodeljs-common';
import { IndexedPolyface } from '@bentley/geometry-core';
import { IndexMap } from '@bentley/bentleyjs-core';
import { IOidcFrontendClient } from '@bentley/imodeljs-clients';
import { LDClient } from 'ldclient-js';
import { LDFlagValue } from 'ldclient-js';
import { LinePixels } from '@bentley/imodeljs-common';
import { LogLevel } from '@bentley/bentleyjs-core';
import { Loop } from '@bentley/geometry-core';
import { LowAndHighXY } from '@bentley/geometry-core';
import { LowAndHighXYZ } from '@bentley/geometry-core';
import { Map4d } from '@bentley/geometry-core';
import { MassPropertiesOperation } from '@bentley/imodeljs-common';
import { MassPropertiesRequestProps } from '@bentley/imodeljs-common';
import { MassPropertiesResponseProps } from '@bentley/imodeljs-common';
import { Matrix3d } from '@bentley/geometry-core';
import { Matrix4d } from '@bentley/geometry-core';
import { MeshEdges } from '@bentley/imodeljs-common';
import { MeshPolyline } from '@bentley/imodeljs-common';
import { MeshPolylineList } from '@bentley/imodeljs-common';
import { ModelProps } from '@bentley/imodeljs-common';
import { ModelQueryParams } from '@bentley/imodeljs-common';
import { ModelSelectorProps } from '@bentley/imodeljs-common';
import { OctEncodedNormal } from '@bentley/imodeljs-common';
import { OidcClient } from '@bentley/imodeljs-clients';
import { OidcDesktopClientConfiguration } from '@bentley/imodeljs-common';
import { OidcFrontendClientConfiguration } from '@bentley/imodeljs-clients';
import { OpenMode } from '@bentley/bentleyjs-core';
import { PackedFeatureTable } from '@bentley/imodeljs-common';
import { ParseResult } from '@bentley/imodeljs-quantity';
import { ParserSpec } from '@bentley/imodeljs-quantity';
import { Path } from '@bentley/geometry-core';
import { Placement2d } from '@bentley/imodeljs-common';
import { PlacementProps } from '@bentley/imodeljs-common';
import { Plane3dByOriginAndUnitNormal } from '@bentley/geometry-core';
import { Point2d } from '@bentley/geometry-core';
import { Point3d } from '@bentley/geometry-core';
import { Point4d } from '@bentley/geometry-core';
import { PointWithStatus } from '@bentley/imodeljs-common';
import { Polyface } from '@bentley/geometry-core';
import { PolyfaceVisitor } from '@bentley/geometry-core';
import { PolylineData } from '@bentley/imodeljs-common';
import { PolylineEdgeArgs } from '@bentley/imodeljs-common';
import { PolylineFlags } from '@bentley/imodeljs-common';
import { PolylineTypeFlags } from '@bentley/imodeljs-common';
import { QParams2d } from '@bentley/imodeljs-common';
import { QParams3d } from '@bentley/imodeljs-common';
import { QPoint3d } from '@bentley/imodeljs-common';
import { QPoint3dList } from '@bentley/imodeljs-common';
import { QueryLimit } from '@bentley/imodeljs-common';
import { QueryPriority } from '@bentley/imodeljs-common';
import { QueryQuota } from '@bentley/imodeljs-common';
import { QueryResponse } from '@bentley/imodeljs-common';
import { Range1d } from '@bentley/geometry-core';
import { Range1dProps } from '@bentley/geometry-core';
import { Range2d } from '@bentley/geometry-core';
import { Range3d } from '@bentley/geometry-core';
import { Range3dProps } from '@bentley/geometry-core';
import { Ray3d } from '@bentley/geometry-core';
import { RelatedElement } from '@bentley/imodeljs-common';
import { RelativePosition as RelativePosition_2 } from '@bentley/ui-abstract';
import { RenderMaterial } from '@bentley/imodeljs-common';
import { RenderSchedule } from '@bentley/imodeljs-common';
import { RenderTexture } from '@bentley/imodeljs-common';
import { RgbColor } from '@bentley/imodeljs-common';
import { RgbColorProps } from '@bentley/imodeljs-common';
import { SettingsAdmin } from '@bentley/imodeljs-clients';
import { SettingsMapResult } from '@bentley/imodeljs-clients';
import { SettingsResult } from '@bentley/imodeljs-clients';
import { SettingsStatus } from '@bentley/imodeljs-clients';
import { SheetProps } from '@bentley/imodeljs-common';
import { SilhouetteEdgeArgs } from '@bentley/imodeljs-common';
import { SkyBoxProps } from '@bentley/imodeljs-common';
import { SkyCubeProps } from '@bentley/imodeljs-common';
import { SnapRequestProps } from '@bentley/imodeljs-common';
import { SnapResponseProps } from '@bentley/imodeljs-common';
import { SolarShadows } from '@bentley/imodeljs-common';
import { SortedArray } from '@bentley/bentleyjs-core';
import { SpatialClassificationProps } from '@bentley/imodeljs-common';
import { SpatialViewDefinitionProps } from '@bentley/imodeljs-common';
import { StopWatch } from '@bentley/bentleyjs-core';
import { StrokeOptions } from '@bentley/geometry-core';
import { SubCategoryAppearance } from '@bentley/imodeljs-common';
import { SubCategoryOverride } from '@bentley/imodeljs-common';
import { TextureMapping } from '@bentley/imodeljs-common';
import { ThumbnailProps } from '@bentley/imodeljs-common';
import { TileHeader } from '@bentley/imodeljs-common';
import { TileProps } from '@bentley/imodeljs-common';
import { TileReadStatus } from '@bentley/imodeljs-common';
import { TileTreeProps } from '@bentley/imodeljs-common';
import { Transform } from '@bentley/geometry-core';
import { TransformProps } from '@bentley/geometry-core';
import { TransientIdSequence } from '@bentley/bentleyjs-core';
import { UiAdmin } from '@bentley/ui-abstract';
import { UlasClient } from '@bentley/imodeljs-clients';
import { UnitConversion } from '@bentley/imodeljs-quantity';
import { UnitProps } from '@bentley/imodeljs-quantity';
import { UnitsProvider } from '@bentley/imodeljs-quantity';
import { UsageType } from '@bentley/imodeljs-clients';
import { User } from 'oidc-client';
import { UserManagerSettings } from 'oidc-client';
import { Vector3d } from '@bentley/geometry-core';
import { ViewAttachmentProps } from '@bentley/imodeljs-common';
import { ViewDefinition2dProps } from '@bentley/imodeljs-common';
import { ViewDefinition3dProps } from '@bentley/imodeljs-common';
import { ViewDefinitionProps } from '@bentley/imodeljs-common';
import { ViewFlag } from '@bentley/imodeljs-common';
import { ViewFlags } from '@bentley/imodeljs-common';
import { ViewQueryParams } from '@bentley/imodeljs-common';
import { ViewStateProps } from '@bentley/imodeljs-common';
import { XAndY } from '@bentley/geometry-core';
import { XYAndZ } from '@bentley/geometry-core';
import { XYZ } from '@bentley/geometry-core';
import { XYZProps } from '@bentley/geometry-core';

// @internal (undocumented)
export namespace A3xTile {
    // (undocumented)
    export function aabbFromBounds(props?: BoundsProps, result?: AxisAlignedBox3d): AxisAlignedBox3d;
    // (undocumented)
    export interface BoundsProps {
        // (undocumented)
        center: XYZProps;
        // (undocumented)
        halfLengths: XYZProps;
    }
    // (undocumented)
    export class LayerSettings {
        constructor(maxLevel: number, outerBounds: AxisAlignedBox3d, maximumSize: number, innerBounds?: AxisAlignedBox3d);
        // (undocumented)
        static fromJSON(props: LayerSettingsProps): LayerSettings | undefined;
        // (undocumented)
        readonly innerBounds: AxisAlignedBox3d;
        // (undocumented)
        readonly maximumSize: number;
        // (undocumented)
        readonly maxLevel: number;
        // (undocumented)
        readonly outerBounds: AxisAlignedBox3d;
    }
    // (undocumented)
    export interface LayerSettingsProps {
        // (undocumented)
        innerBounds: BoundsProps;
        // (undocumented)
        lodWindowSize: {
            x: number;
            y: number;
        };
        // (undocumented)
        maxLevel: number;
        // (undocumented)
        outerBounds: BoundsProps;
        // (undocumented)
        textureType: TextureType;
        // (undocumented)
        type: string;
        // (undocumented)
        version: number;
    }
    // (undocumented)
    export class Loader extends TileLoader {
        constructor(url: string, maxDepth: number, maxSize: number);
        // (undocumented)
        createChildrenProps(parentRange: Range3d, parentContentId: string, contentRange?: Range3d): TileProps[];
        // (undocumented)
        formatContentId(d: number, x: number, y: number): string;
        // (undocumented)
        getChildrenProps(parent: Tile): Promise<TileProps[]>;
        // (undocumented)
        protected get _loadEdges(): boolean;
        // (undocumented)
        loadTileContent(_tile: Tile, _data: TileRequest.ResponseData, _isCanceled?: () => boolean): Promise<Tile.Content>;
        // (undocumented)
        get maxDepth(): number;
        // (undocumented)
        parseContentId(id: string): {
            x: number;
            y: number;
            d: number;
        } | undefined;
        // (undocumented)
        get priority(): Tile.LoadPriority;
        // (undocumented)
        requestTileContent(_tile: Tile): Promise<TileRequest.Response>;
        // (undocumented)
        tileRequiresLoading(_params: Tile.Params): boolean;
        // (undocumented)
        readonly url: string;
    }
    // (undocumented)
    export type TextureType = "dxt1";
}

// @internal
export namespace A3xTileIO {
    export enum AlphaInfo {
        // (undocumented)
        Opaque = 1,
        // (undocumented)
        Transluent = 2,
        // (undocumented)
        Transparent = 4
    }
    // (undocumented)
    export interface ArrayAttributeValue {
        // (undocumented)
        type: AttributeType.Array;
        // (undocumented)
        value: AttributeValue[];
    }
    // (undocumented)
    export interface Attribute {
        // (undocumented)
        keyId: number;
        // (undocumented)
        value: AttributeValue;
    }
    // (undocumented)
    export type Attributes = Attribute[];
    // (undocumented)
    export enum AttributeType {
        // (undocumented)
        Array = 7,
        // (undocumented)
        Boolean = 6,
        // (undocumented)
        Double = 5,
        // (undocumented)
        Int = 3,
        // (undocumented)
        Long = 4,
        // (undocumented)
        Object = 1,
        // (undocumented)
        String = 2
    }
    // (undocumented)
    export type AttributeValue = StringAttributeValue | NumericAttributeValue | BooleanAttributeValue | ArrayAttributeValue | ObjectAttributeValue;
    // (undocumented)
    export interface BatchInstanceGroup {
        // (undocumented)
        aabb: AxisAlignedBox3d;
        // (undocumented)
        instanceIds: number[];
        // (undocumented)
        transform: Transform;
        // (undocumented)
        type: InstanceGroupType.Batch;
    }
    // (undocumented)
    export interface BooleanAttributeValue {
        // (undocumented)
        type: AttributeType.Boolean;
        // (undocumented)
        value: boolean;
    }
    // (undocumented)
    export enum BufferDataType {
        // (undocumented)
        Byte = 1,
        // (undocumented)
        Double = 6,
        // (undocumented)
        Float = 5,
        // (undocumented)
        Int = 3,
        // (undocumented)
        Long = 4,
        // (undocumented)
        Short = 2,
        // (undocumented)
        Undefined = 0
    }
    // (undocumented)
    export interface BufferPointer {
        // (undocumented)
        bufferId: number;
        // (undocumented)
        dataType: BufferDataType;
        // (undocumented)
        offset: number;
    }
    // (undocumented)
    export interface BufferPointerRange extends BufferPointer {
        // (undocumented)
        length: number;
    }
    export enum ByteOrder {
        // (undocumented)
        BigEndian = 2,
        // (undocumented)
        LittleEndian = 1
    }
    // (undocumented)
    export interface Chunk {
        // (undocumented)
        readonly length: number;
        // (undocumented)
        readonly offset: number;
        // (undocumented)
        readonly type: ChunkType;
    }
    // (undocumented)
    export enum ChunkType {
        // (undocumented)
        ContentList = 1,
        // (undocumented)
        Model = 2
    }
    export interface ContentHeader {
        // (undocumented)
        length: number;
        // (undocumented)
        numContentData: number;
        // (undocumented)
        uid: number;
    }
    // (undocumented)
    export enum ContentType {
        // (undocumented)
        Buffer = 7,
        // (undocumented)
        Instance = 1,
        // (undocumented)
        Material = 10,
        // (undocumented)
        Mesh = 8,
        // (undocumented)
        Node = 2,
        // (undocumented)
        String = 11,
        // (undocumented)
        Texture = 9
    }
    // (undocumented)
    export enum FilterType {
        // (undocumented)
        Linear = 2,
        // (undocumented)
        Nearest = 1
    }
    // (undocumented)
    export class Header extends TileHeader {
        constructor(stream: StreamReader);
        // (undocumented)
        readonly byteOrder: ByteOrder;
        // (undocumented)
        readonly chunks: Chunk[];
        // (undocumented)
        readonly contributors: string[];
        // (undocumented)
        get isValid(): boolean;
        // (undocumented)
        readonly options: Option[];
        // (undocumented)
        readonly upAxis: UpAxis;
    }
    // (undocumented)
    export interface IndexBuffer {
        // (undocumented)
        buffer: BufferPointer;
        // (undocumented)
        count: number;
        // (undocumented)
        offset: number;
        // (undocumented)
        primitiveType: PrimitiveType;
        // (undocumented)
        type: IndexBufferType;
    }
    // (undocumented)
    export enum IndexBufferType {
        // (undocumented)
        Default = 1,
        // (undocumented)
        Quadrant0 = 2,
        // (undocumented)
        Quadrant1 = 3,
        // (undocumented)
        Quadrant2 = 4,
        // (undocumented)
        Quadrant3 = 5
    }
    // (undocumented)
    export interface Instance {
        // (undocumented)
        materialId: number;
        // (undocumented)
        meshIds: number[];
    }
    // (undocumented)
    export type InstanceGroup = NodeInstanceGroup | BatchInstanceGroup;
    // (undocumented)
    export enum InstanceGroupType {
        // (undocumented)
        Batch = 2,
        // (undocumented)
        Node = 1
    }
    // (undocumented)
    export interface Material {
        // (undocumented)
        ambient?: MaterialAspect;
        // (undocumented)
        diffuse?: MaterialAspect;
        // (undocumented)
        emission?: MaterialAspect;
        // (undocumented)
        shininess?: MaterialAspect;
        // (undocumented)
        specular?: MaterialAspect;
        // (undocumented)
        transparent?: MaterialAspect;
    }
    // (undocumented)
    export interface MaterialAspect {
        // (undocumented)
        color?: ColorDef;
        // (undocumented)
        magFilter?: FilterType;
        // (undocumented)
        minFilter?: FilterType;
        // (undocumented)
        mipFilter?: FilterType;
        // (undocumented)
        setId?: number;
        // (undocumented)
        textureId?: number;
        // (undocumented)
        value?: number;
        // (undocumented)
        wrapS?: WrapMode;
        // (undocumented)
        wrapT?: WrapMode;
    }
    // (undocumented)
    export enum MaterialDataType {
        // (undocumented)
        Color = 1,
        // (undocumented)
        ColorBufferSet = 4,
        // (undocumented)
        MagFilter = 8,
        // (undocumented)
        MinFilter = 7,
        // (undocumented)
        MipFilter = 9,
        // (undocumented)
        Texture = 2,
        // (undocumented)
        TextureCoordinateBufferSet = 3,
        // (undocumented)
        Value = 10,
        // (undocumented)
        WrapS = 5,
        // (undocumented)
        WrapT = 6
    }
    // (undocumented)
    export enum MaterialType {
        // (undocumented)
        Ambient = 2,
        // (undocumented)
        Diffuse = 1,
        // (undocumented)
        Emission = 3,
        // (undocumented)
        Shininess = 5,
        // (undocumented)
        Specular = 4,
        // (undocumented)
        Transparent = 6
    }
    // (undocumented)
    export interface Mesh {
        // (undocumented)
        colorBuffers: MeshData[];
        // (undocumented)
        indexBuffers: IndexBuffer[];
        // (undocumented)
        otherBuffers: MeshData[];
        // (undocumented)
        textureCoordinateBuffers: MeshData[];
    }
    // (undocumented)
    export interface MeshData {
        // (undocumented)
        buffer: BufferPointer;
        // (undocumented)
        numCoordinates: number;
        // (undocumented)
        offset: number;
        // (undocumented)
        setIdOrMeshType: number | MeshDataType;
        // (undocumented)
        stride: number;
    }
    // (undocumented)
    export enum MeshDataType {
        // (undocumented)
        AttributeKeys = 4,
        // (undocumented)
        Normal = 2,
        // (undocumented)
        Position = 1
    }
    // (undocumented)
    export interface Model {
        // (undocumented)
        attributes: Attributes;
        // (undocumented)
        instances: InstanceGroup[];
        // (undocumented)
        sceneGraph: number[];
    }
    // (undocumented)
    export enum ModelDataType {
        // (undocumented)
        Instances = 2,
        // (undocumented)
        SceneGraph = 1
    }
    // (undocumented)
    export interface Node {
        // (undocumented)
        readonly aabb?: AxisAlignedBox3d;
        // (undocumented)
        attributeKey: number;
        // (undocumented)
        attributeName: string;
        // (undocumented)
        attributes: Attributes;
        // (undocumented)
        childNodeIds: number[];
        // (undocumented)
        readonly transform?: Transform;
    }
    // (undocumented)
    export enum NodeDataType {
        // (undocumented)
        AABB = 1,
        // (undocumented)
        Transforms = 2
    }
    // (undocumented)
    export interface NodeInstanceGroup {
        // (undocumented)
        instanceIds: number[];
        // (undocumented)
        nodeId: number;
        // (undocumented)
        type: InstanceGroupType.Node;
    }
    // (undocumented)
    export interface NumericAttributeValue {
        // (undocumented)
        type: AttributeType.Int | AttributeType.Long | AttributeType.Double;
        // (undocumented)
        value: number;
    }
    // (undocumented)
    export interface ObjectAttributeValue {
        // (undocumented)
        type: AttributeType.Object;
        // (undocumented)
        value: Attributes;
    }
    // (undocumented)
    export interface Option {
        // (undocumented)
        readonly name: string;
        // (undocumented)
        readonly type: OptionType;
        // (undocumented)
        readonly valueLength: number;
    }
    // (undocumented)
    export enum OptionType {
        // (undocumented)
        Boolean = 1,
        // (undocumented)
        Custom = 4,
        // (undocumented)
        Int = 2,
        // (undocumented)
        String = 3
    }
    // (undocumented)
    export enum PrimitiveType {
        // (undocumented)
        Line = 2,
        // (undocumented)
        Point = 1,
        // (undocumented)
        Triangle = 5
    }
    // (undocumented)
    export class Reader {
        // (undocumented)
        readonly buffers: Map<number, Uint8Array>;
        // (undocumented)
        static create(bytes: Uint8Array): Reader | undefined;
        // (undocumented)
        readonly header: Header;
        // (undocumented)
        readonly instances: Map<number, Instance>;
        // (undocumented)
        readonly materials: Map<number, Material>;
        // (undocumented)
        readonly meshes: Map<number, Mesh>;
        // (undocumented)
        readonly model: Model;
        // (undocumented)
        readonly nodes: Map<number, Node>;
        // (undocumented)
        readonly strings: Map<number, string>;
        // (undocumented)
        readonly textures: Map<number, Texture>;
    }
    // (undocumented)
    export class StreamReader extends ByteStream {
        constructor(bytes: Uint8Array);
        // (undocumented)
        get nextAttribute(): Attribute;
        // (undocumented)
        get nextAttributes(): Attributes;
        // (undocumented)
        get nextAttributeValue(): AttributeValue;
        // (undocumented)
        get nextAxisAlignedBox3d(): AxisAlignedBox3d;
        // (undocumented)
        get nextBuffer(): Uint8Array;
        // (undocumented)
        get nextBufferPointer(): BufferPointer;
        // (undocumented)
        get nextBufferPointerRange(): BufferPointerRange;
        // (undocumented)
        get nextContentHeader(): ContentHeader;
        // (undocumented)
        get nextInstance(): Instance;
        // (undocumented)
        get nextMaterial(): Material;
        // (undocumented)
        get nextMatrix4d(): Matrix4d;
        // (undocumented)
        get nextMesh(): Mesh;
        // (undocumented)
        get nextOption(): Option;
        // (undocumented)
        get nextPoint3d64(): Point3d;
        // (undocumented)
        get nextString(): string;
        // (undocumented)
        get nextTexture(): Texture;
        // (undocumented)
        get nextVarInt(): number;
        // (undocumented)
        readModel(model: Model): void;
        // (undocumented)
        readNode(numContentData: number): Node;
    }
    // (undocumented)
    export interface StringAttributeValue {
        // (undocumented)
        type: AttributeType.String;
        // (undocumented)
        value: number;
    }
    // (undocumented)
    export interface Texture {
        // (undocumented)
        alphaInfo: AlphaInfo;
        // (undocumented)
        bufferRange: BufferPointerRange;
        // (undocumented)
        height: number;
        // (undocumented)
        type: TextureType;
        // (undocumented)
        width: number;
    }
    // (undocumented)
    export enum TextureType {
        // (undocumented)
        Dxt1 = 6,
        // (undocumented)
        Jpeg = 1,
        // (undocumented)
        Png = 2
    }
    // (undocumented)
    export enum TransformType {
        // (undocumented)
        Matrix = 1,
        // (undocumented)
        Rotate = 3,
        // (undocumented)
        Scale = 4,
        // (undocumented)
        Translate = 2
    }
    export enum UpAxis {
        // (undocumented)
        Z = 3
    }
    // (undocumented)
    export enum WrapMode {
        // (undocumented)
        ClampToBorder = 4,
        // (undocumented)
        ClampToEdge = 3,
        // (undocumented)
        MirroredRepeat = 2,
        // (undocumented)
        Repeat = 1
    }
}

// @internal
export class AccuDraw {
    // (undocumented)
    accountForAuxRotationPlane(rot: ThreeAxes, plane: RotationMode): void;
    // (undocumented)
    protected _acsPickId?: string;
    // (undocumented)
    activate(): void;
    // (undocumented)
    adjustPoint(pointActive: Point3d, vp: ScreenViewport, fromSnap: boolean): boolean;
    // (undocumented)
    alwaysShowCompass: boolean;
    // (undocumented)
    angleLock(): void;
    // (undocumented)
    protected _animationFrames: number;
    // (undocumented)
    autoFocusFields: boolean;
    // (undocumented)
    autoPointPlacement: boolean;
    // (undocumented)
    readonly axes: ThreeAxes;
    // (undocumented)
    axisIndexing: boolean;
    // (undocumented)
    readonly baseAxes: ThreeAxes;
    // (undocumented)
    changeBaseRotationMode(mode: RotationMode): void;
    // (undocumented)
    changeCompassMode(animate?: boolean): void;
    // (undocumented)
    clearTentative(): boolean;
    // (undocumented)
    compassMode: CompassMode;
    // (undocumented)
    protected _compassSizeInches: number;
    // (undocumented)
    contextSensitive: boolean;
    // (undocumented)
    currentState: CurrentState;
    // (undocumented)
    currentView?: ScreenViewport;
    // (undocumented)
    deactivate(): void;
    // (undocumented)
    decorate(context: DecorateContext): void;
    // (undocumented)
    readonly delta: Vector3d;
    // (undocumented)
    disableForSession(): void;
    // (undocumented)
    distanceIndexing: boolean;
    // (undocumented)
    distanceLock(synchText: boolean, saveInHistory: boolean): void;
    // (undocumented)
    doAutoPoint(index: ItemField, mode: CompassMode): Promise<void>;
    // (undocumented)
    doLockAngle(isSnapped: boolean): void;
    // (undocumented)
    dontMoveFocus: boolean;
    // (undocumented)
    downgradeInactiveState(): boolean;
    // (undocumented)
    enableForSession(): void;
    // (undocumented)
    protected readonly _fillColor: ColorDef;
    // (undocumented)
    protected readonly _fillColorNoFocus: ColorDef;
    // (undocumented)
    fixPointPolar(vp: Viewport): void;
    // (undocumented)
    fixPointRectangular(vp: Viewport): void;
    // (undocumented)
    readonly flags: Flags;
    // (undocumented)
    floatingOrigin: boolean;
    // (undocumented)
    protected readonly _frameColor: ColorDef;
    // (undocumented)
    protected readonly _frameColorNoFocus: ColorDef;
    // (undocumented)
    static getCurrentOrientation(vp: Viewport, checkAccuDraw: boolean, checkACS: boolean, rMatrix?: Matrix3d): Matrix3d | undefined;
    // (undocumented)
    getDecorationGeometry(hit: HitDetail): GeometryStreamProps | undefined;
    // (undocumented)
    getFieldLock(index: ItemField): boolean;
    // (undocumented)
    getKeyinStatus(index: ItemField): KeyinStatus;
    // (undocumented)
    getRotation(rMatrix?: Matrix3d): Matrix3d;
    // (undocumented)
    static getSnapRotation(snap: SnapDetail, currentVp: Viewport | undefined, out?: Matrix3d): Matrix3d | undefined;
    // (undocumented)
    static getStandardRotation(nStandard: StandardViewId, vp: Viewport | undefined, useACS: boolean, out?: Matrix3d): Matrix3d;
    // (undocumented)
    getValueByIndex(index: ItemField): number;
    grabInputFocus(): void;
    // (undocumented)
    hardConstructionPlane(outPtP: Point3d, inPtP: Point3d, pointOnPlaneP: Point3d, normalVectorP: Vector3d, vp: Viewport, isSnap: boolean): boolean;
    // (undocumented)
    get hasInputFocus(): boolean;
    // (undocumented)
    protected readonly _indexColor: ColorDef;
    // (undocumented)
    indexed: LockedStates;
    // (undocumented)
    protected _indexToleranceInches: number;
    // (undocumented)
    get isActive(): boolean;
    // (undocumented)
    get isDeactivated(): boolean;
    // (undocumented)
    get isEnabled(): boolean;
    // (undocumented)
    get isInactive(): boolean;
    // (undocumented)
    isZLocked(vp: Viewport): boolean;
    // (undocumented)
    readonly lastAxes: ThreeAxes;
    // (undocumented)
    locked: LockedStates;
    // (undocumented)
    newFocus: ItemField;
    // (undocumented)
    onBeginDynamics(): boolean;
    // (undocumented)
    onCompassModeChange(): void;
    // (undocumented)
    onEndDynamics(): boolean;
    // (undocumented)
    onFieldLockChange(_index: ItemField): void;
    // (undocumented)
    onFieldValueChange(_index: ItemField): void;
    // (undocumented)
    onInitialized(): void;
    // (undocumented)
    onInputCollectorExit(): boolean;
    // (undocumented)
    onInputCollectorInstall(): boolean;
    onMotion(_ev: BeButtonEvent): void;
    // (undocumented)
    onPostButtonEvent(ev: BeButtonEvent): boolean;
    // (undocumented)
    onPreButtonEvent(ev: BeButtonEvent): boolean;
    // (undocumented)
    onPrimitiveToolInstall(): boolean;
    // (undocumented)
    onRotationModeChange(): void;
    // (undocumented)
    onSelectedViewportChanged(previous: ScreenViewport | undefined, current: ScreenViewport | undefined): void;
    // (undocumented)
    onSnap(snap: SnapDetail): boolean;
    // (undocumented)
    onTentative(): boolean;
    // (undocumented)
    onViewToolExit(): boolean;
    // (undocumented)
    onViewToolInstall(): boolean;
    // (undocumented)
    readonly origin: Point3d;
    // (undocumented)
    readonly planePt: Point3d;
    // (undocumented)
    readonly point: Point3d;
    // (undocumented)
    processFieldInput(index: ItemField, input: string, synchText: boolean): Promise<void>;
    // (undocumented)
    processHints(): void;
    // (undocumented)
    readonly published: AccudrawData;
    // (undocumented)
    refreshDecorationsAndDynamics(): void;
    // (undocumented)
    restoreState(stateBuffer: SavedState): void;
    // (undocumented)
    rotationMode: RotationMode;
    // (undocumented)
    saveCoordinate(index: ItemField, value: number): void;
    // (undocumented)
    readonly savedStateInputCollector: SavedState;
    // (undocumented)
    readonly savedStateViewTool: SavedState;
    // (undocumented)
    saveState(stateBuffer: SavedState): void;
    // (undocumented)
    sendDataPoint(pt: Point3d, viewport: ScreenViewport): Promise<void>;
    // (undocumented)
    setCompassMode(mode: CompassMode): void;
    // (undocumented)
    setContext(flags: AccuDrawFlags, originP?: Point3d, orientationP?: Matrix3d | Vector3d, deltaP?: Vector3d, distanceP?: number, angleP?: number, transP?: Transform): BentleyStatus;
    // (undocumented)
    setContextRotation(rMatrix: Matrix3d, locked: boolean, animate: boolean): void;
    // (undocumented)
    setFieldLock(index: ItemField, locked: boolean): void;
    // (undocumented)
    setFocusItem(_index: ItemField): void;
    // (undocumented)
    setKeyinStatus(index: ItemField, status: KeyinStatus): void;
    // (undocumented)
    setLastPoint(pt: Point3d): void;
    // (undocumented)
    protected setNewFocus(index: ItemField): void;
    // (undocumented)
    setRotationMode(mode: RotationMode): void;
    // (undocumented)
    setValueByIndex(index: ItemField, value: number): void;
    // (undocumented)
    smartKeyin: boolean;
    // (undocumented)
    softConstructionPlane(outPtP: Point3d, inPtP: Point3d, pointOnPlaneP: Point3d, normalVectorP: Vector3d, vp: Viewport, isSnap: boolean): boolean;
    // (undocumented)
    stickyZLock: boolean;
    // (undocumented)
    testDecorationHit(id: string): boolean;
    // (undocumented)
    unlockAllFields(): void;
    // (undocumented)
    static updateAuxCoordinateSystem(acs: AuxCoordSystemState, vp: Viewport, allViews?: boolean): void;
    // (undocumented)
    updateFieldLock(index: ItemField, locked: boolean): void;
    // (undocumented)
    updateRotation(animate?: boolean, newRotationIn?: Matrix3d): void;
    // (undocumented)
    upgradeToActiveState(): boolean;
    // (undocumented)
    readonly vector: Vector3d;
    // (undocumented)
    protected readonly _xColor: ColorDef;
    // (undocumented)
    protected readonly _yColor: ColorDef;
    }

// @internal (undocumented)
export class AccuDrawChangeModeTool extends Tool {
    // (undocumented)
    run(): boolean;
    // (undocumented)
    static toolId: string;
}

// @internal (undocumented)
export class AccudrawData {
    // (undocumented)
    angle: number;
    // (undocumented)
    readonly delta: Point3d;
    // (undocumented)
    distance: number;
    // (undocumented)
    flags: number;
    // (undocumented)
    readonly origin: Point3d;
    // (undocumented)
    readonly rMatrix: Matrix3d;
    // (undocumented)
    readonly vector: Vector3d;
    // (undocumented)
    zero(): void;
}

// @internal (undocumented)
export enum AccuDrawFlags {
    // (undocumented)
    AlwaysSetOrigin = 2097156,
    // (undocumented)
    Disable = 4096,
    // (undocumented)
    FixedOrigin = 8,
    // (undocumented)
    Lock_X = 512,
    // (undocumented)
    Lock_Y = 1024,
    // (undocumented)
    Lock_Z = 2048,
    // (undocumented)
    LockAngle = 524288,
    // (undocumented)
    LockDistance = 256,
    // (undocumented)
    OrientACS = 131072,
    // (undocumented)
    OrientDefault = 16384,
    // (undocumented)
    RedrawCompass = 4194304,
    // (undocumented)
    SetDistance = 128,
    // (undocumented)
    SetFocus = 32768,
    // (undocumented)
    SetModePolar = 1,
    // (undocumented)
    SetModeRect = 2,
    // (undocumented)
    SetNormal = 64,
    // (undocumented)
    SetOrigin = 4,
    // (undocumented)
    SetRMatrix = 16,
    // (undocumented)
    SetXAxis = 32,
    // (undocumented)
    SetXAxis2 = 262144,
    // (undocumented)
    SmartRotation = 16777216,
    // (undocumented)
    UpdateRotation = 8388608
}

// @beta
export class AccuDrawHintBuilder {
    // (undocumented)
    static activate(): void;
    // (undocumented)
    static deactivate(): void;
    // (undocumented)
    enableSmartRotation: boolean;
    sendHints(activate?: boolean): boolean;
    // (undocumented)
    setAngle(angle: number): void;
    // (undocumented)
    setDistance(distance: number): void;
    // (undocumented)
    setLockAngle: boolean;
    // (undocumented)
    setLockDistance: boolean;
    // (undocumented)
    setLockX: boolean;
    // (undocumented)
    setLockY: boolean;
    // (undocumented)
    setLockZ: boolean;
    // (undocumented)
    setModePolar(): void;
    // (undocumented)
    setModeRectangular(): void;
    // (undocumented)
    setNormal(normal: Vector3d): void;
    // (undocumented)
    setOrigin(origin: Point3d): void;
    // (undocumented)
    setOriginAlways: boolean;
    // (undocumented)
    setOriginFixed: boolean;
    // (undocumented)
    setRotation(rMatrix: Matrix3d): void;
    // (undocumented)
    setXAxis(xAxis: Vector3d): void;
    // (undocumented)
    setXAxis2(xAxis: Vector3d): void;
}

// @internal (undocumented)
export class AccuDrawRotateAxesTool extends AccuDrawShortcutsTool {
    constructor(aboutCurrentZ?: boolean);
    // (undocumented)
    aboutCurrentZ: boolean;
    // (undocumented)
    doManipulation(ev: BeButtonEvent | undefined, isMotion: boolean): boolean;
    // (undocumented)
    doManipulationStart(): void;
    // (undocumented)
    protected _immediateMode: boolean;
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    onInstall(): boolean;
    // (undocumented)
    onManipulationComplete(): AccuDrawFlags;
    // (undocumented)
    onPostInstall(): void;
    // (undocumented)
    parseAndRun(...args: any[]): boolean;
    // (undocumented)
    static toolId: string;
}

// @internal (undocumented)
export class AccuDrawRotateCycleTool extends Tool {
    // (undocumented)
    run(): boolean;
    // (undocumented)
    static toolId: string;
}

// @internal (undocumented)
export class AccuDrawRotateElementTool extends AccuDrawShortcutsTool {
    // (undocumented)
    doManipulation(ev: BeButtonEvent | undefined, isMotion: boolean): boolean;
    // (undocumented)
    doManipulationStart(): void;
    // (undocumented)
    moveOrigin: boolean;
    // (undocumented)
    onInstall(): boolean;
    // (undocumented)
    onManipulationComplete(): AccuDrawFlags;
    // (undocumented)
    static toolId: string;
    // (undocumented)
    updateOrientation(snap: SnapDetail, vp: Viewport): boolean;
}

// @internal (undocumented)
export class AccuDrawRotateFrontTool extends Tool {
    // (undocumented)
    run(): boolean;
    // (undocumented)
    static toolId: string;
}

// @internal (undocumented)
export class AccuDrawRotateSideTool extends Tool {
    // (undocumented)
    run(): boolean;
    // (undocumented)
    static toolId: string;
}

// @internal (undocumented)
export class AccuDrawRotateTopTool extends Tool {
    // (undocumented)
    run(): boolean;
    // (undocumented)
    static toolId: string;
}

// @internal (undocumented)
export class AccuDrawRotateViewTool extends Tool {
    // (undocumented)
    run(): boolean;
    // (undocumented)
    static toolId: string;
}

// @internal (undocumented)
export class AccuDrawSetLockAngleTool extends Tool {
    // (undocumented)
    run(): boolean;
    // (undocumented)
    static toolId: string;
}

// @internal (undocumented)
export class AccuDrawSetLockDistanceTool extends Tool {
    // (undocumented)
    run(): boolean;
    // (undocumented)
    static toolId: string;
}

// @internal (undocumented)
export class AccuDrawSetLockSmartTool extends Tool {
    // (undocumented)
    run(): boolean;
    // (undocumented)
    static toolId: string;
}

// @internal (undocumented)
export class AccuDrawSetLockXTool extends Tool {
    // (undocumented)
    run(): boolean;
    // (undocumented)
    static toolId: string;
}

// @internal (undocumented)
export class AccuDrawSetLockYTool extends Tool {
    // (undocumented)
    run(): boolean;
    // (undocumented)
    static toolId: string;
}

// @internal (undocumented)
export class AccuDrawSetLockZTool extends Tool {
    // (undocumented)
    run(): boolean;
    // (undocumented)
    static toolId: string;
}

// @internal (undocumented)
export class AccuDrawSetOriginTool extends Tool {
    // (undocumented)
    run(): boolean;
    // (undocumented)
    static toolId: string;
}

// @alpha
export class AccuDrawShortcuts {
    // (undocumented)
    static alignView(): void;
    // (undocumented)
    static changeCompassMode(): void;
    // (undocumented)
    static defineACSByElement(): void;
    // (undocumented)
    static defineACSByPoints(): void;
    // (undocumented)
    static getACS(acsName: string | undefined, useOrigin: boolean, useRotation: boolean): BentleyStatus;
    // (undocumented)
    static itemFieldAcceptInput(index: ItemField, str: string): Promise<void>;
    // (undocumented)
    static itemFieldLockToggle(index: ItemField): void;
    // (undocumented)
    static itemFieldNavigate(index: ItemField, str: string, forward: boolean): Promise<void>;
    // (undocumented)
    static itemFieldNewInput(index: ItemField): void;
    // (undocumented)
    static itemFieldUnlockAll(): void;
    // (undocumented)
    static itemRotationModeChange(rotation: RotationMode): void;
    // (undocumented)
    static lockAngle(): void;
    // (undocumented)
    static lockDistance(): void;
    // (undocumented)
    lockIndex(): void;
    // (undocumented)
    static lockSmart(): void;
    // (undocumented)
    static lockX(): void;
    // (undocumented)
    static lockY(): void;
    // (undocumented)
    static lockZ(): void;
    // (undocumented)
    static processPendingHints(): void;
    // @internal
    static processShortcutKey(keyEvent: KeyboardEvent): boolean;
    // (undocumented)
    static requestInputFocus(): void;
    // (undocumented)
    static rotate90(axis: number): void;
    // (undocumented)
    static rotateAxes(aboutCurrentZ: boolean): void;
    // (undocumented)
    static rotateAxesByPoint(isSnapped: boolean, aboutCurrentZ: boolean): boolean;
    // (undocumented)
    static rotateCycle(): void;
    // (undocumented)
    static rotateToACS(): void;
    // (undocumented)
    static rotateToBase(): void;
    // (undocumented)
    static rotateToElement(): void;
    // (undocumented)
    static setOrigin(explicitOrigin?: Point3d): void;
    // (undocumented)
    static setStandardRotation(rotation: RotationMode): void;
    // (undocumented)
    static updateACSByPoints(acs: AuxCoordSystemState, vp: Viewport, points: Point3d[], isDynamics: boolean): boolean;
    // (undocumented)
    static writeACS(_acsName: string): BentleyStatus;
}

// @public
export class AccuSnap implements Decorator {
    // @internal (undocumented)
    adjustPointIfHot(pt: Point3d, view: Viewport): void;
    readonly areFlashed: Set<Viewport>;
    aSnapHits?: HitList<HitDetail>;
    clear(): void;
    // @internal (undocumented)
    clearIfElement(sourceId: string): void;
    // @internal (undocumented)
    clearToolTip(ev?: BeButtonEvent): void;
    readonly cross: SpriteLocation;
    currHit?: HitDetail;
    // @internal (undocumented)
    decorate(context: DecorateContext): void;
    // @internal (undocumented)
    destroy(): void;
    // @internal (undocumented)
    displayToolTip(viewPt: XAndY, vp: ScreenViewport, uorPt?: Point3d): void;
    enableLocate(yesNo: boolean): void;
    enableSnap(yesNo: boolean): void;
    // @internal (undocumented)
    erase(): void;
    readonly errorIcon: SpriteLocation;
    errorKey?: string;
    explanation?: string;
    getActiveSnapModes(): SnapMode[];
    // @internal (undocumented)
    getCurrSnapDetail(): SnapDetail | undefined;
    // @internal (undocumented)
    getHitAndList(holder: HitListHolder): HitDetail | undefined;
    readonly icon: SpriteLocation;
    // @internal (undocumented)
    intersectXY(tpSnap: SnapDetail, second: SnapDetail): IntersectDetail | undefined;
    get isActive(): boolean;
    get isHot(): boolean;
    get isLocateEnabled(): boolean;
    get isSnapEnabled(): boolean;
    get isSnapEnabledByUser(): boolean;
    get keypointDivisor(): number;
    readonly needFlash: Set<Viewport>;
    // @internal
    onEnabledStateChange(_isEnabled: boolean, _wasEnabled: boolean): void;
    // @internal (undocumented)
    onInitialized(): void;
    // @internal
    onMotion(ev: BeButtonEvent): Promise<void>;
    // @internal (undocumented)
    onPreButtonEvent(ev: BeButtonEvent): boolean;
    // @internal
    onStartTool(): void;
    // @internal (undocumented)
    onTouchCancel(ev: BeTouchEvent): void;
    // @internal (undocumented)
    onTouchEnd(ev: BeTouchEvent): void;
    // @internal (undocumented)
    onTouchMove(ev: BeTouchEvent): boolean;
    // @internal (undocumented)
    onTouchMoveStart(ev: BeTouchEvent, startEv: BeTouchEvent): boolean;
    // @internal (undocumented)
    onTouchStart(ev: BeTouchEvent): void;
    // @internal (undocumented)
    onTouchTap(ev: BeTouchEvent): Promise<boolean>;
    // @internal
    reEvaluate(): Promise<void>;
    // @internal (undocumented)
    static requestSnap(thisHit: HitDetail, snapModes: SnapMode[], hotDistanceInches: number, keypointDivisor: number, hitList?: HitList<HitDetail>, out?: LocateResponse): Promise<SnapDetail | undefined>;
    // @internal
    resetButton(): Promise<SnapStatus>;
    // @internal (undocumented)
    setCurrHit(newHit?: HitDetail): void;
    // @internal (undocumented)
    protected _settings: AccuSnap.Settings;
    // @internal (undocumented)
    suppress(doSuppress: boolean): number;
    // @internal (undocumented)
    suspend(doSuspend: boolean): void;
    // @internal
    synchSnapMode(): void;
    // @internal (undocumented)
    readonly toolState: AccuSnap.ToolState;
    // @internal (undocumented)
    touchCursor?: TouchCursor;
    }

// @public (undocumented)
export namespace AccuSnap {
    // (undocumented)
    export class Settings {
        // (undocumented)
        enableFlag: boolean;
        // (undocumented)
        hiliteColdHits: boolean;
        // (undocumented)
        hotDistanceFactor: number;
        // (undocumented)
        searchDistance: number;
        // (undocumented)
        stickyFactor: number;
        // (undocumented)
        toolTip: boolean;
        // (undocumented)
        toolTipDelay: BeDuration;
    }
    // (undocumented)
    export class ToolState {
        // (undocumented)
        clone(): ToolState;
        // (undocumented)
        enabled: boolean;
        // (undocumented)
        locate: boolean;
        // (undocumented)
        setFrom(other: ToolState): void;
        // (undocumented)
        suspended: number;
    }
}

// @public (undocumented)
export enum ACSDisplayOptions {
    // (undocumented)
    Active = 1,
    // (undocumented)
    CheckVisible = 8,
    // (undocumented)
    Deemphasized = 2,
    // (undocumented)
    Dynamics = 16,
    // (undocumented)
    Hilite = 4,
    // (undocumented)
    None = 0
}

// @public (undocumented)
export enum ACSType {
    // (undocumented)
    Cylindrical = 2,
    // (undocumented)
    None = 0,
    // (undocumented)
    Rectangular = 1,
    // (undocumented)
    Spherical = 3
}

// @alpha (undocumented)
export enum ActiveClipStatus {
    // (undocumented)
    Modified = 3,
    // (undocumented)
    None = 0,
    // (undocumented)
    Saved = 2,
    // (undocumented)
    Unsaved = 1
}

// @public
export class ActivityMessageDetails {
    constructor(showProgressBar: boolean, showPercentInMessage: boolean, supportsCancellation: boolean, showDialogInitially?: boolean);
    onActivityCancelled(): void;
    onActivityCompleted(): void;
    // (undocumented)
    showDialogInitially: boolean;
    // (undocumented)
    showPercentInMessage: boolean;
    // (undocumented)
    showProgressBar: boolean;
    // (undocumented)
    supportsCancellation: boolean;
    // (undocumented)
    wasCancelled: boolean;
}

// @public
export enum ActivityMessageEndReason {
    // (undocumented)
    Cancelled = 1,
    // (undocumented)
    Completed = 0
}

// @beta
export class AngleDescription extends BaseQuantityDescription {
    constructor(name?: string, displayLabel?: string, iconSpec?: string);
    // (undocumented)
    get parseError(): string;
    // (undocumented)
    get quantityType(): QuantityType;
}

// @internal
export class AnimationBranchState {
    constructor(transform?: Transform, clip?: RenderClipVolume, omit?: boolean);
    // (undocumented)
    readonly clip?: RenderClipVolume;
    // (undocumented)
    readonly omit?: boolean;
    // (undocumented)
    readonly transform?: Transform;
}

// @internal
export type AnimationBranchStates = Map<string, AnimationBranchState>;

// @beta
export interface Animator {
    animate(): boolean;
    interrupt(): void;
}

// @beta (undocumented)
export interface AppearanceOverrideProps {
    // (undocumented)
    color?: ColorDefProps;
    // (undocumented)
    ids?: Id64Array;
    // (undocumented)
    overrideType?: FeatureOverrideType;
}

// @beta
export interface ArrayValue extends BasePropertyValue {
    // (undocumented)
    items: PropertyRecord[];
    // (undocumented)
    itemsTypeName: string;
    // (undocumented)
    valueFormat: PropertyValueFormat.Array;
}

// @internal (undocumented)
export namespace Attachments {
    // (undocumented)
    export abstract class Attachment {
        protected constructor(props: ViewAttachmentProps, view: ViewState);
        clearClipping(): void;
        // (undocumented)
        clip: ClipVector;
        static readonly DEBUG_BOUNDING_BOX_COLOR: ColorDef;
        debugDrawBorder(context: SceneContext): void;
        // (undocumented)
        discloseTileTrees(trees: TileTreeSet): void;
        // (undocumented)
        displayPriority: number;
        getOrCreateClip(transform?: Transform): ClipVector;
        // (undocumented)
        id: Id64String;
        abstract get is2d(): boolean;
        get isReady(): boolean;
        abstract load(sheetView: SheetViewState, sceneContext: SceneContext): State;
        // (undocumented)
        placement: Placement2d;
        // (undocumented)
        scale: number;
        get tree(): Tree | undefined;
        set tree(tree: Tree | undefined);
        // (undocumented)
        protected _tree?: Tree;
        // (undocumented)
        readonly view: ViewState;
    }
    // (undocumented)
    export class Attachment2d extends Attachment {
        constructor(props: ViewAttachmentProps, view: ViewState2d);
        // (undocumented)
        discloseTileTrees(trees: TileTreeSet): void;
        // (undocumented)
        get is2d(): boolean;
        // (undocumented)
        load(_sheetView: SheetViewState, _sceneContext: SceneContext): State;
        // (undocumented)
        treeRef?: TileTreeReference;
    }
    // (undocumented)
    export class Attachment3d extends Attachment {
        constructor(props: ViewAttachmentProps, view: ViewState3d);
        // (undocumented)
        discloseTileTrees(trees: TileTreeSet): void;
        getState(depth: number): State;
        // (undocumented)
        get is2d(): boolean;
        // (undocumented)
        load(sheetView: SheetViewState, sceneContext: SceneContext): State;
        setState(depth: number, state: State): void;
        }
    // (undocumented)
    export class AttachmentList {
        constructor();
        add(attachment: Attachment): void;
        get allReady(): boolean;
        clear(): void;
        drop(attachment: Attachment): void;
        get length(): number;
        // (undocumented)
        readonly list: Attachment[];
        load(idx: number, sheetView: SheetViewState, sceneContext: SceneContext): State;
        }
    // (undocumented)
    export abstract class AttachmentTileLoader extends TileLoader {
        // (undocumented)
        getChildrenProps(_parent: Tile): Promise<TileProps[]>;
        // (undocumented)
        abstract get is3dAttachment(): boolean;
        // (undocumented)
        get priority(): Tile.LoadPriority;
        // (undocumented)
        requestTileContent(_tile: Tile, _isCanceled: () => boolean): Promise<TileRequest.Response>;
        // (undocumented)
        tileRequiresLoading(_params: Tile.Params): boolean;
    }
    // (undocumented)
    export class AttachmentViewport {
        constructor(view: ViewState3d);
        // (undocumented)
        createScene(currentState: State): State;
        // (undocumented)
        get isAspectRatioLocked(): boolean;
        // (undocumented)
        renderImage(): ImageBuffer | undefined;
        // (undocumented)
        rendering: boolean;
        // (undocumented)
        renderTexture(): void;
        // (undocumented)
        setSceneDepth(depth: number, tree: Tree3d): void;
        // (undocumented)
        get texture(): RenderTexture | undefined;
        // (undocumented)
        toParent: Transform;
        // (undocumented)
        readonly vp: OffScreenViewport;
    }
    export const enum State {
        // (undocumented)
        Empty = 1,
        // (undocumented)
        Loading = 2,
        // (undocumented)
        NotLoaded = 0,
        // (undocumented)
        Ready = 3
    }
    // (undocumented)
    export class Tile2d extends Tile {
        constructor(root: Tree2d, range: ElementAlignedBox2d);
        // (undocumented)
        drawGraphics(args: Tile.DrawArgs): void;
        // (undocumented)
        get hasChildren(): boolean;
        // (undocumented)
        get hasGraphics(): boolean;
    }
    // (undocumented)
    export class Tile3d extends Tile {
        // (undocumented)
        static create(root: Tree3d, parent: Tile3d | undefined, placement: Tile3dPlacement): Tile3d;
        // (undocumented)
        createGraphics(context: SceneContext): void;
        // (undocumented)
        createPolyfaces(context: SceneContext): void;
        // (undocumented)
        drawGraphics(args: Tile.DrawArgs): void;
        // (undocumented)
        get hasChildren(): boolean;
        // (undocumented)
        get hasGraphics(): boolean;
        // (undocumented)
        prepareChildren(): Tile[] | undefined;
        // (undocumented)
        selectTiles(selected: Tile[], args: Tile.DrawArgs, _numSkipped?: number): Tile.SelectParent;
        }
    export const enum Tile3dPlacement {
        // (undocumented)
        LowerLeft = 2,
        // (undocumented)
        LowerRight = 3,
        // (undocumented)
        Root = 4,
        // (undocumented)
        UpperLeft = 0,
        // (undocumented)
        UpperRight = 1
    }
    // (undocumented)
    export abstract class Tree extends TileTree {
        constructor(loader: AttachmentTileLoader, iModel: IModelConnection, modelId: Id64String);
        // (undocumented)
        dispose(): void;
        // (undocumented)
        graphicsClip?: RenderClipVolume;
    }
    // (undocumented)
    export class Tree2d extends Tree {
        static create(attachment: Attachment2d): State;
        // (undocumented)
        readonly drawingToAttachment: Transform;
        // (undocumented)
        readonly symbologyOverrides: FeatureSymbology.Overrides;
        // (undocumented)
        readonly view: ViewState2d;
        // (undocumented)
        readonly viewRoot: TileTree;
    }
    // (undocumented)
    export class Tree3d extends Tree {
        // (undocumented)
        readonly attachment: Attachment3d;
        // (undocumented)
        readonly biasDistance: number;
        // (undocumented)
        static create(sheetView: SheetViewState, attachment: Attachment3d, sceneContext: SceneContext): Tree3d;
        // (undocumented)
        readonly featureTable: PackedFeatureTable;
        getRootRange(result?: Range3d): Range3d;
        getState(depth: number): State;
        setState(depth: number, state: State): void;
        // (undocumented)
        readonly sheetView: SheetViewState;
        // (undocumented)
        readonly tileColor: ColorDef;
        // (undocumented)
        readonly viewport: AttachmentViewport;
    }
    {};
}

// @public
export class AuthorizedFrontendRequestContext extends AuthorizedClientRequestContext {
    constructor(accessToken: AccessToken, activityId?: string);
    static create(activityId?: string): Promise<AuthorizedFrontendRequestContext>;
}

// @public
export class AuxCoordSystem2dState extends AuxCoordSystemState implements AuxCoordSystem2dProps {
    constructor(props: AuxCoordSystem2dProps, iModel: IModelConnection);
    // (undocumented)
    angle: number;
    // @internal (undocumented)
    static get className(): string;
    // (undocumented)
    getOrigin(result?: Point3d): Point3d;
    // (undocumented)
    getRotation(result?: Matrix3d): Matrix3d;
    // (undocumented)
    readonly origin: Point2d;
    // (undocumented)
    setOrigin(val: XYAndZ | XAndY): void;
    // (undocumented)
    setRotation(val: Matrix3d): void;
    // (undocumented)
    toJSON(): AuxCoordSystem2dProps;
}

// @public
export class AuxCoordSystem3dState extends AuxCoordSystemState implements AuxCoordSystem3dProps {
    constructor(props: AuxCoordSystem3dProps, iModel: IModelConnection);
    // @internal (undocumented)
    static get className(): string;
    // (undocumented)
    getOrigin(result?: Point3d): Point3d;
    // (undocumented)
    getRotation(result?: Matrix3d): Matrix3d;
    // (undocumented)
    readonly origin: Point3d;
    // (undocumented)
    pitch: number;
    // (undocumented)
    roll: number;
    // (undocumented)
    setOrigin(val: XYAndZ | XAndY): void;
    // (undocumented)
    setRotation(rMatrix: Matrix3d): void;
    // (undocumented)
    toJSON(): AuxCoordSystem3dProps;
    // (undocumented)
    yaw: number;
}

// @public
export class AuxCoordSystemSpatialState extends AuxCoordSystem3dState {
    // @internal (undocumented)
    static get className(): string;
}

// @public
export abstract class AuxCoordSystemState extends ElementState implements AuxCoordSystemProps {
    constructor(props: AuxCoordSystemProps, iModel: IModelConnection);
    // @internal (undocumented)
    static get className(): string;
    static createNew(acsName: string, iModel: IModelConnection): AuxCoordSystemState;
    // (undocumented)
    description?: string;
    // (undocumented)
    display(context: DecorateContext, options: ACSDisplayOptions): void;
    // (undocumented)
    drawGrid(context: DecorateContext): void;
    // (undocumented)
    static fromProps(props: AuxCoordSystemProps, iModel: IModelConnection): AuxCoordSystemState;
    // (undocumented)
    abstract getOrigin(result?: Point3d): Point3d;
    abstract getRotation(result?: Matrix3d): Matrix3d;
    // (undocumented)
    get is3d(): boolean;
    static isOriginInView(drawOrigin: Point3d, viewport: Viewport, adjustOrigin: boolean): boolean;
    // (undocumented)
    isValidForView(view: ViewState): boolean;
    // (undocumented)
    abstract setOrigin(val: XYAndZ | XAndY): void;
    // (undocumented)
    abstract setRotation(val: Matrix3d): void;
    // (undocumented)
    toJSON(): AuxCoordSystemProps;
    // (undocumented)
    type: number;
}

// @internal
export class BackgroundMapTileTreeReference extends MapTileTreeReference {
    constructor(settings: BackgroundMapSettings, iModel: IModelConnection, forDrape?: boolean);
    // (undocumented)
    protected get _graphicType(): TileTree.GraphicType.BackgroundMap | TileTree.GraphicType.Scene;
    // (undocumented)
    protected get _groundBias(): number;
    // (undocumented)
    protected get _imageryProvider(): ImageryProvider | undefined;
    // (undocumented)
    settings: BackgroundMapSettings;
    // (undocumented)
    protected get _transparency(): number | undefined;
    // (undocumented)
    get treeOwner(): TileTree.Owner;
}

// @internal
export class BackgroundTerrainTileTreeReference extends TileTreeReference {
    constructor(settings: BackgroundMapSettings, iModel: IModelConnection);
    addLogoCards(logoDiv: HTMLTableElement, vp: ScreenViewport): void;
    // (undocumented)
    addPlanes(planes: Plane3dByOriginAndUnitNormal[]): void;
    addToScene(context: SceneContext): void;
    // (undocumented)
    discloseTileTrees(trees: TileTreeSet): void;
    // (undocumented)
    getHeightRange(): Range1d | undefined;
    // (undocumented)
    getToolTip(hit: HitDetail): HTMLElement | string | undefined;
    // (undocumented)
    settings: BackgroundMapSettings;
    // (undocumented)
    get treeOwner(): TileTree.Owner;
    unionFitRange(_range: Range3d): void;
}

// @beta
export interface BasePropertyEditorParams {
    // (undocumented)
    type: string;
}

// @beta
export interface BasePropertyValue {
    // (undocumented)
    valueFormat: PropertyValueFormat;
}

// @beta
export abstract class BaseQuantityDescription implements PropertyDescription {
    constructor(name: string, displayLabel: string, iconSpec?: string);
    // (undocumented)
    displayLabel: string;
    // (undocumented)
    editor: PropertyEditorInfo;
    // (undocumented)
    format: (numberValue: number) => string;
    // (undocumented)
    get formatterSpec(): FormatterSpec | undefined;
    // (undocumented)
    name: string;
    // (undocumented)
    parse: (userInput: string) => ParseResults;
    // (undocumented)
    abstract get parseError(): string;
    // (undocumented)
    get parserSpec(): ParserSpec | undefined;
    // (undocumented)
    abstract get quantityType(): QuantityType;
    // (undocumented)
    typename: string;
}

// @internal
export class BatchedTileIdMap {
    constructor(iModel: IModelConnection);
    getBatchId(properties: any): Id64String;
    getBatchProperties(id: Id64String): any;
    }

// @public (undocumented)
export enum BeButton {
    // (undocumented)
    Data = 0,
    // (undocumented)
    Middle = 2,
    // (undocumented)
    Reset = 1
}

// @public
export class BeButtonEvent implements BeButtonEventProps {
    constructor(props?: BeButtonEventProps);
    button: BeButton;
    clone(): this;
    coordsFrom: CoordSource;
    init(props: BeButtonEventProps): void;
    inputSource: InputSource;
    invalidate(): void;
    get isAltKey(): boolean;
    get isControlKey(): boolean;
    isDoubleClick: boolean;
    isDown: boolean;
    isDragging: boolean;
    get isShiftKey(): boolean;
    get isValid(): boolean;
    keyModifiers: BeModifierKeys;
    // @internal
    get movement(): XAndY | undefined;
    set movement(mov: XAndY | undefined);
    get point(): Point3d;
    set point(pt: Point3d);
    get rawPoint(): Point3d;
    set rawPoint(pt: Point3d);
    setFrom(src: BeButtonEvent): this;
    get viewPoint(): Point3d;
    set viewPoint(pt: Point3d);
    viewport?: ScreenViewport;
}

// @public
export interface BeButtonEventProps {
    button?: BeButton;
    coordsFrom?: CoordSource;
    inputSource?: InputSource;
    isDoubleClick?: boolean;
    isDown?: boolean;
    isDragging?: boolean;
    // (undocumented)
    keyModifiers?: BeModifierKeys;
    point?: Point3d;
    rawPoint?: Point3d;
    viewPoint?: Point3d;
    viewport?: ScreenViewport;
}

// @public (undocumented)
export class BeButtonState {
    // (undocumented)
    get downRawPt(): Point3d;
    set downRawPt(pt: Point3d);
    // (undocumented)
    downTime: number;
    // (undocumented)
    get downUorPt(): Point3d;
    set downUorPt(pt: Point3d);
    // (undocumented)
    init(downUorPt: Point3d, downRawPt: Point3d, downTime: number, isDown: boolean, isDoubleClick: boolean, isDragging: boolean, source: InputSource): void;
    // (undocumented)
    inputSource: InputSource;
    // (undocumented)
    isDoubleClick: boolean;
    // (undocumented)
    isDown: boolean;
    // (undocumented)
    isDragging: boolean;
}

// @public
export enum BeModifierKeys {
    // (undocumented)
    Alt = 4,
    // (undocumented)
    Control = 1,
    // (undocumented)
    None = 0,
    // (undocumented)
    Shift = 2
}

// @public
export class BeTouchEvent extends BeButtonEvent implements BeTouchEventProps {
    constructor(props: BeTouchEventProps);
    // (undocumented)
    static findTouchById(list: TouchList, id: number): Touch | undefined;
    // (undocumented)
    static getTouchListCentroid(list: TouchList, vp: ScreenViewport): Point2d | undefined;
    // (undocumented)
    static getTouchPosition(touch: Touch, vp: ScreenViewport): Point2d;
    // (undocumented)
    get isDoubleTap(): boolean;
    // (undocumented)
    get isSingleTap(): boolean;
    // (undocumented)
    get isSingleTouch(): boolean;
    // (undocumented)
    get isTwoFingerTap(): boolean;
    // (undocumented)
    get isTwoFingerTouch(): boolean;
    // (undocumented)
    setFrom(src: BeTouchEvent): this;
    // (undocumented)
    tapCount: number;
    // (undocumented)
    get touchCount(): number;
    // (undocumented)
    touchEvent: TouchEvent;
}

// @public
export interface BeTouchEventProps extends BeButtonEventProps {
    // (undocumented)
    touchEvent: TouchEvent;
}

// @public
export class BeWheelEvent extends BeButtonEvent implements BeWheelEventProps {
    constructor(props?: BeWheelEventProps);
    // (undocumented)
    setFrom(src: BeWheelEvent): this;
    // (undocumented)
    time: number;
    // (undocumented)
    wheelDelta: number;
}

// @public
export interface BeWheelEventProps extends BeButtonEventProps {
    // (undocumented)
    time?: number;
    // (undocumented)
    wheelDelta?: number;
}

// @internal (undocumented)
export class BingElevationProvider {
    constructor();
    // (undocumented)
    getGeodeticToSeaLevelOffset(point: Point3d, iModel: IModelConnection): Promise<number>;
    // (undocumented)
    getGraphic(latLongRange: Range2d, corners: Point3d[], groundBias: number, texture: RenderTexture, system: RenderSystem): Promise<RenderGraphic | undefined>;
    // (undocumented)
    getHeightAverage(iModel: IModelConnection): Promise<number>;
    // (undocumented)
    getHeightRange(iModel: IModelConnection): Promise<Range1d>;
    // (undocumented)
    getHeights(range: Range2d): Promise<any>;
    // (undocumented)
    getHeightValue(point: Point3d, iModel: IModelConnection, geodetic?: boolean): Promise<number>;
    // (undocumented)
    protected _requestContext: ClientRequestContext;
    }

// @beta
export interface BlankConnectionProps {
    extents: Range3dProps;
    globalOrigin?: XYZProps;
    location: Cartographic | EcefLocationProps;
    name: string;
}

// @beta
export interface ButtonGroupEditorParams extends BasePropertyEditorParams {
    // (undocumented)
    buttons: IconDefinition[];
    // (undocumented)
    type: PropertyEditorParamTypes.ButtonGroupData;
}

// @internal
export interface CachedIModelCoordinatesResponseProps {
    missing?: XYZProps[];
    result: Array<PointWithStatus | undefined>;
}

// @beta
export function calculateSolarAngles(date: Date, location: Cartographic): {
    azimuth: number;
    elevation: number;
};

// @beta
export function calculateSolarDirection(date: Date, location: Cartographic): Vector3d;

// @beta
export function calculateSunriseOrSunset(date: Date, location: Cartographic, sunrise: boolean): Date;

// @public
export interface CanvasDecoration {
    decorationCursor?: string;
    drawDecoration(ctx: CanvasRenderingContext2D): void;
    onMouseButton?(ev: BeButtonEvent): boolean;
    onMouseEnter?(ev: BeButtonEvent): void;
    onMouseLeave?(): void;
    onMouseMove?(ev: BeButtonEvent): void;
    onWheel?(ev: BeWheelEvent): boolean;
    pick?(pt: XAndY): boolean;
    position?: XAndY;
}

// @public
export type CanvasDecorationList = CanvasDecoration[];

// @public
export function canvasToImageBuffer(canvas: HTMLCanvasElement, format?: ImageBufferFormat): ImageBuffer | undefined;

// @public
export function canvasToResizedCanvasWithBars(canvasIn: HTMLCanvasElement, targetSize: Point2d, barSize?: Point2d, barStyle?: string): HTMLCanvasElement;

// @public
export class CategorySelectorState extends ElementState {
    constructor(props: CategorySelectorProps, iModel: IModelConnection);
    addCategories(arg: Id64Arg): void;
    // (undocumented)
    categories: Set<string>;
    changeCategoryDisplay(arg: Id64Arg, add: boolean): void;
    // @internal (undocumented)
    static get className(): string;
    dropCategories(arg: Id64Arg): void;
    equalState(other: CategorySelectorState): boolean;
    has(id: Id64String): boolean;
    isCategoryViewed(categoryId: Id64String): boolean;
    get name(): string;
    // (undocumented)
    toJSON(): CategorySelectorProps;
}

// @beta
export enum ChangeFlag {
    // (undocumented)
    All = 268435455,
    // (undocumented)
    AlwaysDrawn = 1,
    // (undocumented)
    DisplayStyle = 16,
    // (undocumented)
    FeatureOverrideProvider = 32,
    // (undocumented)
    Initial = 28,
    // (undocumented)
    NeverDrawn = 2,
    // (undocumented)
    None = 0,
    // (undocumented)
    Overrides = 268435319,
    // (undocumented)
    ViewedCategories = 4,
    // (undocumented)
    ViewedCategoriesPerModel = 64,
    // (undocumented)
    ViewedModels = 8,
    // (undocumented)
    ViewState = 128
}

// @beta
export class ChangeFlags {
    constructor(flags?: ChangeFlag);
    get alwaysDrawn(): boolean;
    areAllSet(flags: ChangeFlag): boolean;
    get areFeatureOverridesDirty(): boolean;
    clear(flags?: ChangeFlag): void;
    get displayStyle(): boolean;
    get featureOverrideProvider(): boolean;
    get hasChanges(): boolean;
    isSet(flags: ChangeFlag): boolean;
    get neverDrawn(): boolean;
    set(flags: ChangeFlag): void;
    // (undocumented)
    setAlwaysDrawn(): void;
    // (undocumented)
    setDisplayStyle(): void;
    // (undocumented)
    setFeatureOverrideProvider(): void;
    // (undocumented)
    setNeverDrawn(): void;
    // (undocumented)
    setViewedCategories(): void;
    // (undocumented)
    setViewedCategoriesPerModel(): void;
    // (undocumented)
    setViewedModels(): void;
    // (undocumented)
    setViewState(): void;
    // (undocumented)
    get value(): ChangeFlag;
    get viewedCategories(): boolean;
    // @alpha
    get viewedCategoriesPerModel(): boolean;
    get viewedModels(): boolean;
    get viewState(): boolean;
}

// @public
export interface ChangeViewedModel2dOptions {
    doFit?: boolean;
}

// @alpha
export interface CheckBoxIconsEditorParams extends BasePropertyEditorParams {
    // (undocumented)
    offIconDefinition?: IconDefinition;
    // (undocumented)
    onIconDefinition?: IconDefinition;
    // (undocumented)
    type: PropertyEditorParamTypes.CheckBoxIcons;
}

// @alpha
export enum ClipEventType {
    // (undocumented)
    Activate = 4,
    // (undocumented)
    Clear = 3,
    // (undocumented)
    Modify = 2,
    // (undocumented)
    New = 0,
    // (undocumented)
    NewPlane = 1
}

// @beta
export const enum ClippingType {
    Mask = 1,
    None = 0,
    Planes = 2
}

// @internal
export enum ClipResult {
    NewElements = 1,
    NotSupported = 0,
    OriginalElements = 2
}

// @internal
export class Clips {
    // (undocumented)
    clear(): void;
    // (undocumented)
    get count(): number;
    // (undocumented)
    get isValid(): boolean;
    // (undocumented)
    set(numPlanes: number, texture: TextureHandle): void;
    // (undocumented)
    get texture(): TextureHandle | undefined;
    }

// @public
export class Cluster<T extends Marker> {
    constructor(markers: T[]);
    // (undocumented)
    clusterMarker?: Marker;
    // (undocumented)
    readonly markers: T[];
    // (undocumented)
    readonly rect: ViewRect;
}

// @beta
export interface ColorEditorParams extends BasePropertyEditorParams {
    colorValues: number[];
    numColumns?: number;
    // (undocumented)
    type: PropertyEditorParamTypes.ColorData;
}

// @internal (undocumented)
export enum CompassMode {
    // (undocumented)
    Polar = 0,
    // (undocumented)
    Rectangular = 1
}

// @internal (undocumented)
export function computeMercatorFractionToDb(iModel: IModelConnection, groundBias: number, tilingScheme: MapTilingScheme): Transform;

// @internal (undocumented)
export enum ContextMode {
    // (undocumented)
    Locked = 0,
    // (undocumented)
    None = 15,
    // (undocumented)
    XAxis = 1,
    // (undocumented)
    XAxis2 = 4,
    // (undocumented)
    YAxis = 2,
    // (undocumented)
    ZAxis = 3
}

// @internal
export class ContextRealityModelState {
    constructor(props: ContextRealityModelProps, iModel: IModelConnection, displayStyle: DisplayStyleState);
    // (undocumented)
    get classifiers(): SpatialClassifiers | undefined;
    // (undocumented)
    readonly description: string;
    // (undocumented)
    readonly iModel: IModelConnection;
    intersectsProjectExtents(): Promise<boolean>;
    // (undocumented)
    matches(other: ContextRealityModelState): boolean;
    // (undocumented)
    matchesNameAndUrl(name: string, url: string): boolean;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    toJSON(): ContextRealityModelProps;
    // (undocumented)
    get treeRef(): TileTreeReference;
    // (undocumented)
    readonly url: string;
}

// @internal
export abstract class ContextTileLoader extends TileLoader {
    constructor();
    // (undocumented)
    computeTilePriority(tile: Tile, viewports: Iterable<Viewport>): number;
    // (undocumented)
    get drawAsRealityTiles(): boolean;
    // (undocumented)
    get preloadRealityParentDepth(): number;
    // (undocumented)
    get preloadRealityParentSkip(): number;
    }

// @alpha
export class ConversionData implements UnitConversion {
    // (undocumented)
    factor: number;
    // (undocumented)
    offset: number;
}

// @public (undocumented)
export enum CoordinateLockOverrides {
    // (undocumented)
    ACS = 2,
    // (undocumented)
    All = 65535,
    // (undocumented)
    Grid = 4,
    // (undocumented)
    None = 0
}

// @public
export enum CoordSource {
    ElemSnap = 3,
    Precision = 1,
    TentativePoint = 2,
    User = 0
}

// @public
export enum CoordSystem {
    Npc = 1,
    View = 0,
    World = 2
}

// @internal (undocumented)
export class CoreTools {
    // (undocumented)
    static namespace: string;
    // (undocumented)
    static outputPromptByKey(key: string): void;
    // (undocumented)
    static tools: string;
    // (undocumented)
    static translate(prompt: string): any;
}

// @internal (undocumented)
export function createClassifierTileTreeReference(classifiers: SpatialClassifiers, classifiedTree: TileTreeReference, iModel: IModelConnection, source: ViewState | DisplayStyleState): SpatialClassifierTileTreeReference;

// @internal
export function createTileTreeFromImageryProvider(imageryProvider: ImageryProvider, groundBias: number, filterTextures: boolean, iModel: IModelConnection): Promise<TileTree | undefined>;

// @internal (undocumented)
export class CurrentInputState {
    // (undocumented)
    adjustLastDataPoint(ev: BeButtonEvent): void;
    // (undocumented)
    button: BeButtonState[];
    // (undocumented)
    changeButtonToDownPoint(ev: BeButtonEvent): void;
    // (undocumented)
    clearKeyQualifiers(): void;
    // (undocumented)
    clearViewport(vp: Viewport): void;
    // (undocumented)
    fromButton(vp: ScreenViewport, pt: XAndY, source: InputSource, applyLocks: boolean): void;
    // (undocumented)
    fromPoint(vp: ScreenViewport, pt: XAndY, source: InputSource): void;
    // (undocumented)
    inputSource: InputSource;
    // (undocumented)
    get isAltDown(): boolean;
    // (undocumented)
    get isControlDown(): boolean;
    // (undocumented)
    isDragging(button: BeButton): boolean;
    // (undocumented)
    get isShiftDown(): boolean;
    // (undocumented)
    isStartDrag(button: BeButton): boolean;
    // (undocumented)
    lastButton: BeButton;
    // (undocumented)
    lastMotion: Point2d;
    // (undocumented)
    lastTouchStart?: BeTouchEvent;
    // (undocumented)
    lastWheelEvent?: BeWheelEvent;
    // (undocumented)
    onButtonDown(button: BeButton): void;
    // (undocumented)
    onButtonUp(button: BeButton): void;
    // (undocumented)
    onInstallTool(): void;
    // (undocumented)
    onMotion(pt2d: XAndY): void;
    // (undocumented)
    onStartDrag(button: BeButton): void;
    // (undocumented)
    get point(): Point3d;
    set point(pt: Point3d);
    // (undocumented)
    qualifiers: BeModifierKeys;
    // (undocumented)
    get rawPoint(): Point3d;
    set rawPoint(pt: Point3d);
    // (undocumented)
    setKeyQualifiers(ev: MouseEvent | KeyboardEvent | TouchEvent): void;
    // (undocumented)
    toEvent(ev: BeButtonEvent, useSnap: boolean): void;
    // (undocumented)
    toEventFromLastDataPoint(ev: BeButtonEvent): void;
    // (undocumented)
    touchTapCount?: number;
    // (undocumented)
    touchTapTimer?: number;
    // (undocumented)
    updateDownPoint(ev: BeButtonEvent): void;
    // (undocumented)
    get viewPoint(): Point3d;
    set viewPoint(pt: Point3d);
    // (undocumented)
    viewport?: ScreenViewport;
}

// @internal (undocumented)
export enum CurrentState {
    // (undocumented)
    Active = 3,
    // (undocumented)
    Deactivated = 1,
    // (undocumented)
    Inactive = 2,
    // (undocumented)
    NotEnabled = 0
}

// @beta
export interface CustomFormattedNumberParams extends BasePropertyEditorParams {
    // (undocumented)
    formatFunction: (numberValue: number, quantityType?: QuantityType | string) => string;
    // (undocumented)
    parseFunction: (stringValue: string, quantityType?: QuantityType | string) => ParseResults;
    // (undocumented)
    type: PropertyEditorParamTypes.CustomFormattedNumber;
}

// @public
export class DecorateContext extends RenderContext {
    // @internal
    constructor(vp: ScreenViewport, _decorations: Decorations);
    addCanvasDecoration(decoration: CanvasDecoration, atFront?: boolean): void;
    addDecoration(type: GraphicType, decoration: RenderGraphic): void;
    addDecorationFromBuilder(builder: GraphicBuilder): void;
    addHtmlDecoration(decoration: HTMLElement): void;
    createGraphicBuilder(type: GraphicType, transform?: Transform, id?: Id64String): GraphicBuilder;
    decorationDiv: HTMLDivElement;
    // @internal (undocumented)
    drawStandardGrid(gridOrigin: Point3d, rMatrix: Matrix3d, spacing: XAndY, gridsPerRef: number, _isoGrid?: boolean, _fixedRepetitions?: Point2d): void;
    get screenViewport(): ScreenViewport;
    setSkyBox(graphic: RenderGraphic): void;
    setViewBackground(graphic: RenderGraphic): void;
}

// @public
export class Decorations implements IDisposable {
    // (undocumented)
    canvasDecorations?: CanvasDecorationList;
    // (undocumented)
    dispose(): void;
    get normal(): GraphicList | undefined;
    set normal(normal: GraphicList | undefined);
    get skyBox(): RenderGraphic | undefined;
    set skyBox(skyBox: RenderGraphic | undefined);
    get viewBackground(): RenderGraphic | undefined;
    set viewBackground(viewBackground: RenderGraphic | undefined);
    get viewOverlay(): GraphicList | undefined;
    set viewOverlay(viewOverlay: GraphicList | undefined);
    get world(): GraphicList | undefined;
    set world(world: GraphicList | undefined);
    get worldOverlay(): GraphicList | undefined;
    set worldOverlay(worldOverlay: GraphicList | undefined);
    }

// @public
export interface Decorator {
    decorate(context: DecorateContext): void;
    getDecorationGeometry?(hit: HitDetail): GeometryStreamProps | undefined;
    getDecorationToolTip?(hit: HitDetail): Promise<HTMLElement | string>;
    onDecorationButtonEvent?(hit: HitDetail, ev: BeButtonEvent): Promise<EventHandled>;
    testDecorationHit?(id: string): boolean;
}

// @internal (undocumented)
export class DefaultViewTouchTool extends ViewManip implements Animator {
    constructor(startEv: BeTouchEvent, ev: BeTouchEvent);
    animate(): boolean;
    // (undocumented)
    interrupt(): void;
    // (undocumented)
    onDataButtonDown(_ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onDataButtonUp(_ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onStart(ev: BeTouchEvent): void;
    // (undocumented)
    onTouchCancel(_ev: BeTouchEvent): Promise<void>;
    // (undocumented)
    onTouchComplete(_ev: BeTouchEvent): Promise<void>;
    // (undocumented)
    onTouchMove(ev: BeTouchEvent): Promise<void>;
    // (undocumented)
    static toolId: string;
}

// @internal (undocumented)
export class DefineACSByElementTool extends AccuDrawShortcutsTool {
    // (undocumented)
    activateAccuDrawOnStart(): boolean;
    // (undocumented)
    decorate(context: DecorateContext): void;
    // (undocumented)
    doManipulation(ev: BeButtonEvent | undefined, isMotion: boolean): boolean;
    // (undocumented)
    doManipulationStart(): void;
    // (undocumented)
    onManipulationComplete(): AccuDrawFlags;
    // (undocumented)
    static toolId: string;
    // (undocumented)
    updateOrientation(snap: SnapDetail, vp: Viewport): boolean;
}

// @internal (undocumented)
export class DefineACSByPointsTool extends AccuDrawShortcutsTool {
    // (undocumented)
    activateAccuDrawOnStart(): boolean;
    // (undocumented)
    decorate(context: DecorateContext): void;
    // (undocumented)
    doManipulation(ev: BeButtonEvent | undefined, isMotion: boolean): boolean;
    // (undocumented)
    doManipulationStart(): void;
    // (undocumented)
    onManipulationComplete(): AccuDrawFlags;
    // (undocumented)
    static toolId: string;
}

// @alpha
export interface DepthPointOptions {
    excludeDecorations?: boolean;
    excludeExternalIModels?: boolean;
    excludeNonLocatable?: boolean;
}

// @alpha
export enum DepthPointSource {
    ACS = 5,
    BackgroundMap = 2,
    Geometry = 0,
    Grid = 4,
    GroundPlane = 3,
    Model = 1,
    TargetPoint = 6
}

// @public
export interface DepthRangeNpc {
    maximum: number;
    minimum: number;
}

// @internal
export class DevTools {
    static connectToBackendInstance(iModelToken: IModelToken): DevTools;
    ping(count: number): Promise<PingTestResult>;
    setLogLevel(inLoggerCategory: string, newLevel: LogLevel): Promise<LogLevel | undefined>;
    stats(options?: DevToolsStatsOptions): Promise<any>;
    // (undocumented)
    versions(): Promise<any>;
}

// @public
export class DisplayStyle2dState extends DisplayStyleState {
    constructor(props: DisplayStyleProps, iModel: IModelConnection);
    // @internal (undocumented)
    static get className(): string;
    // (undocumented)
    get settings(): DisplayStyleSettings;
    }

// @public
export class DisplayStyle3dState extends DisplayStyleState {
    constructor(props: DisplayStyleProps, iModel: IModelConnection);
    // @internal (undocumented)
    static get className(): string;
    // @internal (undocumented)
    clone(iModel: IModelConnection): this;
    get environment(): Environment;
    set environment(env: Environment);
    // @internal
    loadSkyBoxParams(system: RenderSystem, vp?: Viewport): SkyBox.CreateParams | undefined;
    // @beta
    setSunTime(time: number): void;
    // (undocumented)
    get settings(): DisplayStyle3dSettings;
    // @beta (undocumented)
    get sunDirection(): Vector3d | undefined;
}

// @public
export abstract class DisplayStyleState extends ElementState implements DisplayStyleProps {
    constructor(props: DisplayStyleProps, iModel: IModelConnection);
    get analysisStyle(): AnalysisStyle | undefined;
    set analysisStyle(style: AnalysisStyle | undefined);
    // @internal (undocumented)
    attachRealityModel(props: ContextRealityModelProps): void;
    get backgroundColor(): ColorDef;
    set backgroundColor(val: ColorDef);
    // @internal (undocumented)
    get backgroundDrapeMap(): BackgroundMapTileTreeReference;
    // @internal (undocumented)
    get backgroundMap(): BackgroundMapOrTerrainTileTreeReference;
    // @internal (undocumented)
    get backgroundMapPlane(): Plane3dByOriginAndUnitNormal | undefined;
    // @beta
    get backgroundMapSettings(): BackgroundMapSettings;
    set backgroundMapSettings(settings: BackgroundMapSettings);
    // @beta
    changeBackgroundMapProps(props: BackgroundMapProps): void;
    // @internal (undocumented)
    static get className(): string;
    // @internal (undocumented)
    detachRealityModelByIndex(index: number): void;
    // @internal (undocumented)
    detachRealityModelByNameAndUrl(name: string, url: string): void;
    dropSubCategoryOverride(id: Id64String): void;
    equalState(other: DisplayStyleState): boolean;
    // @internal (undocumented)
    forEachRealityModel(func: (model: ContextRealityModelState) => void): void;
    // @internal (undocumented)
    forEachRealityTileTreeRef(func: (ref: TileTreeReference) => void): void;
    // @internal (undocumented)
    forEachTileTreeRef(func: (ref: TileTreeReference) => void): void;
    // @internal (undocumented)
    getAnimationBranches(scheduleTime: number): AnimationBranchStates | undefined;
    // @internal (undocumented)
    getAttribution(div: HTMLTableElement, vp: ScreenViewport): void;
    getSubCategoryOverride(id: Id64String): SubCategoryOverride | undefined;
    // @internal (undocumented)
    hasAttachedRealityModel(name: string, url: string): boolean;
    get hasSubCategoryOverride(): boolean;
    is3d(): this is DisplayStyle3dState;
    get monochromeColor(): ColorDef;
    set monochromeColor(val: ColorDef);
    get name(): string;
    overrideSubCategory(id: Id64String, ovr: SubCategoryOverride): void;
    // @internal (undocumented)
    get scheduleScript(): RenderScheduleState.Script | undefined;
    set scheduleScript(script: RenderScheduleState.Script | undefined);
    // @deprecated
    setBackgroundMap(mapProps: BackgroundMapProps): void;
    abstract get settings(): DisplayStyleSettings;
    get viewFlags(): ViewFlags;
    set viewFlags(flags: ViewFlags);
    // @internal (undocumented)
    get wantShadows(): boolean;
}

// @alpha
export interface DrawClipOptions {
    color?: ColorDef;
    fill?: ColorDef;
    fillClipPlanes?: boolean;
    hasPrimaryPlane?: boolean;
    hiddenStyle?: LinePixels;
    hiddenWidth?: number;
    id?: string;
    visibleWidth?: number;
}

// @public
export class DrawingModelState extends GeometricModel2dState {
    // @internal (undocumented)
    static get className(): string;
}

// @public
export class DrawingViewState extends ViewState2d {
    // @internal (undocumented)
    static get className(): string;
    // (undocumented)
    static createFromProps(props: ViewStateProps, iModel: IModelConnection): DrawingViewState;
    // (undocumented)
    get defaultExtentLimits(): ExtentLimits;
    }

// @public
export class DynamicsContext extends RenderContext {
    addGraphic(graphic: RenderGraphic): void;
    // @internal (undocumented)
    changeDynamics(): void;
    }

// @alpha
export namespace EditManipulator {
    // (undocumented)
    export enum EventType {
        // (undocumented)
        Accept = 2,
        // (undocumented)
        Cancel = 1,
        // (undocumented)
        Synch = 0
    }
    // (undocumented)
    export abstract class HandleProvider {
        constructor(iModel: IModelConnection);
        // (undocumented)
        protected clearControls(): void;
        protected abstract createControls(): Promise<boolean>;
        // (undocumented)
        decorate(_context: DecorateContext): void;
        // (undocumented)
        iModel: IModelConnection;
        // (undocumented)
        protected _isActive: boolean;
        protected abstract modifyControls(_hit: HitDetail, _ev: BeButtonEvent): boolean;
        // (undocumented)
        onDecorationButtonEvent(hit: HitDetail, ev: BeButtonEvent): Promise<EventHandled>;
        // (undocumented)
        protected onDoubleClick(_hit: HitDetail, _ev: BeButtonEvent): Promise<EventHandled>;
        // (undocumented)
        onManipulatorEvent(_eventType: EventType): void;
        // (undocumented)
        onManipulatorToolEvent(_tool: Tool, event: ManipulatorToolEvent): void;
        // (undocumented)
        protected onRightClick(_hit: HitDetail, _ev: BeButtonEvent): Promise<EventHandled>;
        // (undocumented)
        onSelectionChanged(ev: SelectionSetEvent): void;
        // (undocumented)
        protected onTouchTap(_hit: HitDetail, _ev: BeButtonEvent): Promise<EventHandled>;
        // (undocumented)
        protected _removeDecorationListener?: () => void;
        // (undocumented)
        protected _removeManipulatorToolListener?: () => void;
        // (undocumented)
        protected _removeSelectionListener?: () => void;
        // (undocumented)
        protected stop(): void;
        // (undocumented)
        protected updateControls(): Promise<void>;
        // (undocumented)
        protected updateDecorationListener(add: boolean): void;
    }
    // (undocumented)
    export abstract class HandleTool extends InputCollector {
        constructor(manipulator: HandleProvider);
        // (undocumented)
        protected abstract accept(_ev: BeButtonEvent): boolean;
        // (undocumented)
        protected cancel(_ev: BeButtonEvent): boolean;
        // (undocumented)
        static hidden: boolean;
        protected init(): void;
        // (undocumented)
        manipulator: HandleProvider;
        // (undocumented)
        onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
        // (undocumented)
        onPostInstall(): void;
        // (undocumented)
        onResetButtonUp(ev: BeButtonEvent): Promise<EventHandled>;
        // (undocumented)
        onTouchCancel(ev: BeTouchEvent): Promise<void>;
        // (undocumented)
        onTouchComplete(ev: BeTouchEvent): Promise<void>;
        // (undocumented)
        onTouchMove(ev: BeTouchEvent): Promise<void>;
        // (undocumented)
        static toolId: string;
    }
    // (undocumented)
    export class HandleUtils {
        static getArrowShape(baseStart?: number, baseWidth?: number, tipStart?: number, tipEnd?: number, tipWidth?: number, flangeStart?: number, flangeWidth?: number): Point3d[];
        static getArrowTransform(vp: Viewport, base: Point3d, direction: Vector3d, sizeInches: number): Transform | undefined;
        // (undocumented)
        static getBoresite(origin: Point3d, vp: Viewport, checkAccuDraw?: boolean, checkACS?: boolean): Ray3d;
        // (undocumented)
        static getRotation(rotation: RotationType, viewport: Viewport): Matrix3d | undefined;
        // (undocumented)
        static isPointVisible(testPt: Point3d, vp: Viewport, borderPaddingFactor?: number): boolean;
        // (undocumented)
        static projectPointToLineInView(spacePt: Point3d, linePt: Point3d, lineDirection: Vector3d, vp: Viewport, checkAccuDraw?: boolean, checkACS?: boolean): Point3d | undefined;
        // (undocumented)
        static projectPointToPlaneInView(spacePt: Point3d, planePt: Point3d, planeNormal: Vector3d, vp: Viewport, checkAccuDraw?: boolean, checkACS?: boolean): Point3d | undefined;
    }
    // (undocumented)
    export enum RotationType {
        // (undocumented)
        Back = 4,
        // (undocumented)
        Bottom = 3,
        // (undocumented)
        Face = 7,
        // (undocumented)
        Front = 1,
        // (undocumented)
        Left = 2,
        // (undocumented)
        Right = 5,
        // (undocumented)
        Top = 0,
        // (undocumented)
        View = 6
    }
}

// @beta
export interface EditorPosition {
    columnIndex: number;
    columnSpan?: number;
    rowPriority: number;
}

// @internal (undocumented)
export class ElementAgenda {
    constructor(iModel: IModelConnection);
    add(arg: Id64Arg): boolean;
    clear(): void;
    // (undocumented)
    get count(): number;
    // (undocumented)
    readonly elements: string[];
    find(id: Id64String): boolean;
    getSource(): ModifyElementSource.Unknown | ModifyElementSource;
    // (undocumented)
    readonly groupMarks: GroupMark[];
    // (undocumented)
    has(id: string): boolean;
    hilite(): void;
    // (undocumented)
    hilitedState: HilitedState;
    hiliteOnAdd: boolean;
    // (undocumented)
    iModel: IModelConnection;
    invert(arg: Id64Arg): boolean;
    // (undocumented)
    get isEmpty(): boolean;
    // (undocumented)
    get length(): number;
    popGroup(): void;
    // (undocumented)
    remove(arg: Id64Arg): boolean;
    setSource(val: ModifyElementSource): void;
}

// @public (undocumented)
export class ElementLocateManager {
    // (undocumented)
    get apertureInches(): number;
    // (undocumented)
    clear(): void;
    // (undocumented)
    currHit?: HitDetail;
    // (undocumented)
    doLocate(response: LocateResponse, newSearch: boolean, testPoint: Point3d, view: ScreenViewport | undefined, source: InputSource, filterHits?: boolean): Promise<HitDetail | undefined>;
    // (undocumented)
    filterHit(hit: HitDetail, _action: LocateAction, out: LocateResponse): Promise<LocateFilterStatus>;
    static getFailureMessageKey(key: string): string;
    // (undocumented)
    getNextHit(): HitDetail | undefined;
    getPreLocatedHit(): HitDetail | undefined;
    // (undocumented)
    hitList?: HitList<HitDetail>;
    // (undocumented)
    initLocateOptions(): void;
    // (undocumented)
    initToolLocate(): void;
    // (undocumented)
    onInitialized(): void;
    // (undocumented)
    readonly options: LocateOptions;
    // (undocumented)
    readonly picker: ElementPicker;
    // (undocumented)
    setCurrHit(hit?: HitDetail): void;
    // (undocumented)
    setHitList(list?: HitList<HitDetail>): void;
    // (undocumented)
    get touchApertureInches(): number;
}

// @public (undocumented)
export class ElementPicker {
    doPick(vp: ScreenViewport, pickPointWorld: Point3d, pickRadiusView: number, options: LocateOptions): number;
    // (undocumented)
    empty(): void;
    getHit(i: number): HitDetail | undefined;
    getHitList(takeOwnership: boolean): HitList<HitDetail>;
    // (undocumented)
    getNextHit(): HitDetail | undefined;
    // (undocumented)
    hitList?: HitList<HitDetail>;
    // (undocumented)
    readonly pickPointWorld: Point3d;
    // (undocumented)
    resetCurrentHit(): void;
    // (undocumented)
    testHit(hit: HitDetail, vp: ScreenViewport, pickPointWorld: Point3d, pickRadiusView: number, options: LocateOptions): boolean;
    // (undocumented)
    viewport?: Viewport;
}

// @public
export class ElementState extends EntityState implements ElementProps {
    constructor(props: ElementProps, iModel: IModelConnection);
    // @internal (undocumented)
    static get className(): string;
    readonly code: Code;
    readonly federationGuid?: GuidString;
    readonly model: Id64String;
    readonly parent?: RelatedElement;
    // @internal (undocumented)
    toJSON(): ElementProps;
    readonly userLabel?: string;
}

// @internal
export enum ElemMethod {
    Add = 0,
    Invert = 1
}

// @internal
export enum ElemSource {
    Fence = 1,
    Pick = 0,
    SelectionSet = 2
}

// @beta
export class EmphasizeElements implements FeatureOverrideProvider {
    addFeatureOverrides(overrides: FeatureSymbology.Overrides, vp: Viewport): void;
    static clear(vp: Viewport, inactiveOnly?: boolean): void;
    clearAlwaysDrawnElements(vp: Viewport): boolean;
    clearEmphasizedElements(vp: Viewport): boolean;
    clearEmphasizedIsolatedElements(vp: Viewport, setToAlwaysDrawn: boolean): boolean;
    clearHiddenElements(vp: Viewport): boolean;
    clearIsolatedElements(vp: Viewport): boolean;
    clearNeverDrawnElements(vp: Viewport): boolean;
    clearOverriddenElements(vp: Viewport, key?: number): boolean;
    // @internal (undocumented)
    protected createAppearanceFromKey(key: number): FeatureSymbology.Appearance;
    createDefaultAppearance(): FeatureSymbology.Appearance;
    createOverrideKey(color: ColorDef, override: FeatureOverrideType): number | undefined;
    get defaultAppearance(): FeatureSymbology.Appearance | undefined;
    set defaultAppearance(appearance: FeatureSymbology.Appearance | undefined);
    emphasizeElements(ids: Id64Arg, vp: Viewport, defaultAppearance?: FeatureSymbology.Appearance, replace?: boolean): boolean;
    emphasizeSelectedElements(vp: Viewport, defaultAppearance?: FeatureSymbology.Appearance, replace?: boolean, clearSelection?: boolean): boolean;
    // (undocumented)
    fromJSON(props: EmphasizeElementsProps, vp: Viewport): boolean;
    static get(vp: Viewport): EmphasizeElements | undefined;
    getAlwaysDrawnElements(vp: Viewport): Id64Set | undefined;
    getEmphasizedElements(vp: Viewport): Id64Set | undefined;
    getEmphasizedIsolatedElements(): Id64Set | undefined;
    getHiddenElements(vp: Viewport): Id64Set | undefined;
    getIsolatedElements(vp: Viewport): Id64Set | undefined;
    getNeverDrawnElements(vp: Viewport): Id64Set | undefined;
    static getOrCreate(vp: Viewport): EmphasizeElements;
    getOverriddenElements(): Map<number, Id64Set> | undefined;
    getOverriddenElementsByKey(key: number): Id64Set | undefined;
    getOverrideFromKey(key: number, color: ColorDef): FeatureOverrideType;
    hideElements(ids: Id64Arg, vp: Viewport, replace?: boolean): boolean;
    hideSelectedElements(vp: Viewport, replace?: boolean, clearSelection?: boolean): boolean;
    isActive(vp: Viewport): boolean;
    isolateElements(ids: Id64Arg, vp: Viewport, replace?: boolean): boolean;
    isolateSelectedElements(vp: Viewport, replace?: boolean, clearSelection?: boolean): boolean;
    overrideElements(ids: Id64Arg, vp: Viewport, color: ColorDef, override?: FeatureOverrideType, replace?: boolean): boolean;
    overrideSelectedElements(vp: Viewport, color: ColorDef, override?: FeatureOverrideType, replace?: boolean, clearSelection?: boolean): boolean;
    // @internal
    setAlwaysDrawnElements(ids: Id64Arg, vp: Viewport, exclusive?: boolean, replace?: boolean): boolean;
    // @internal
    setNeverDrawnElements(ids: Id64Arg, vp: Viewport, replace?: boolean): boolean;
    // (undocumented)
    toJSON(vp: Viewport): EmphasizeElementsProps;
    // @internal (undocumented)
    protected updateIdSet(ids: Id64Arg, replace: boolean, existingIds?: Id64Set): Id64Set | undefined;
    wantEmphasis: boolean;
}

// @beta (undocumented)
export interface EmphasizeElementsProps {
    // (undocumented)
    alwaysDrawn?: Id64Array;
    // (undocumented)
    alwaysDrawnExclusiveEmphasized?: Id64Array;
    // (undocumented)
    appearanceOverride?: AppearanceOverrideProps[];
    // (undocumented)
    defaultAppearance?: FeatureSymbology.AppearanceProps;
    // (undocumented)
    isAlwaysDrawnExclusive?: boolean;
    // (undocumented)
    neverDrawn?: Id64Array;
    // (undocumented)
    wantEmphasis?: boolean;
}

// @beta
export class EngineeringLengthDescription extends BaseQuantityDescription {
    constructor(name?: string, displayLabel?: string, iconSpec?: string);
    // (undocumented)
    get parseError(): string;
    // (undocumented)
    get quantityType(): QuantityType;
}

// @public
export class EntityState implements EntityProps {
    constructor(props: EntityProps, iModel: IModelConnection, _state?: EntityState);
    readonly classFullName: string;
    static get classFullName(): string;
    static get className(): string;
    get className(): string;
    clone(iModel?: IModelConnection): this;
    equals(other: this): boolean;
    readonly id: Id64String;
    readonly iModel: IModelConnection;
    readonly jsonProperties: {
        [key: string]: any;
    };
    static get schemaName(): string;
    // @internal (undocumented)
    toJSON(): EntityProps;
}

// @beta
export interface EnumerationChoice {
    // (undocumented)
    label: string;
    // (undocumented)
    value: string | number;
}

// @beta
export interface EnumerationChoicesInfo {
    // (undocumented)
    choices: EnumerationChoice[];
    // (undocumented)
    isStrict?: boolean;
    // (undocumented)
    maxDisplayedRows?: number;
}

// @public
export class Environment implements EnvironmentProps {
    constructor(json?: EnvironmentProps);
    // (undocumented)
    readonly ground: GroundPlane;
    // (undocumented)
    readonly sky: SkyBox;
    // (undocumented)
    toJSON(): EnvironmentProps;
}

// @internal
export enum ErrorNums {
    NoFence = 0,
    NoFenceElems = 1,
    NoFenceElemsOutside = 2,
    NoSSElems = 3,
    NotSupportedElmType = 4
}

// @public
export class EventController {
    constructor(vp: ScreenViewport);
    // (undocumented)
    destroy(): void;
    // (undocumented)
    vp: ScreenViewport;
}

// @public (undocumented)
export enum EventHandled {
    // (undocumented)
    No = 0,
    // (undocumented)
    Yes = 1
}

// @internal
export interface EventSourceOptions {
    pollInterval: number;
    prefetchLimit: number;
}

// @public
export interface ExtentLimits {
    max: number;
    min: number;
}

// @public
export function extractImageSourceDimensions(source: ImageSource): Promise<Point2d>;

// @public
export interface FeatureOverrideProvider {
    addFeatureOverrides(overrides: FeatureSymbology.Overrides, viewport: Viewport): void;
}

// @beta
export enum FeatureOverrideType {
    // (undocumented)
    AlphaOnly = 1,
    // (undocumented)
    ColorAndAlpha = 2,
    // (undocumented)
    ColorOnly = 0
}

// @public
export namespace FeatureSymbology {
    export class Appearance implements AppearanceProps {
        static readonly defaults: Appearance;
        // @beta
        readonly emphasized?: true | undefined;
        // (undocumented)
        equals(other: Appearance): boolean;
        extendAppearance(base: Appearance): Appearance;
        // (undocumented)
        static fromJSON(props?: AppearanceProps): Appearance;
        static fromRgb(color: ColorDef): Appearance;
        static fromRgba(color: ColorDef): Appearance;
        static fromSubCategoryOverride(ovr: SubCategoryOverride): Appearance;
        static fromTransparency(transparencyValue: number): Appearance;
        readonly ignoresMaterial?: true | undefined;
        // (undocumented)
        get isFullyTransparent(): boolean;
        readonly linePixels?: LinePixels;
        readonly nonLocatable?: true | undefined;
        // (undocumented)
        get overridesLinePixels(): boolean;
        // (undocumented)
        get overridesRgb(): boolean;
        // (undocumented)
        get overridesSymbology(): boolean;
        // (undocumented)
        get overridesTransparency(): boolean;
        // (undocumented)
        get overridesWeight(): boolean;
        readonly rgb?: RgbColor;
        // (undocumented)
        toJSON(): AppearanceProps;
        readonly transparency?: number;
        readonly weight?: number;
    }
    export interface AppearanceProps {
        // @beta
        emphasized?: true | undefined;
        ignoresMaterial?: true | undefined;
        linePixels?: LinePixels;
        nonLocatable?: true | undefined;
        rgb?: RgbColorProps;
        transparency?: number;
        weight?: number;
    }
    export class Overrides {
        constructor(view?: ViewState | Viewport);
        // @internal (undocumented)
        get alwaysDrawn(): Id64.Uint32Set;
        // @internal
        protected readonly _alwaysDrawn: Id64.Uint32Set;
        // @alpha
        alwaysDrawnIgnoresSubCategory: boolean;
        // @internal
        readonly animationNodeOverrides: Map<number, Appearance>;
        // @internal
        protected _constructions: boolean;
        get defaultOverrides(): Appearance;
        // @internal
        protected _defaultOverrides: Appearance;
        // @internal
        protected _dimensions: boolean;
        // @internal
        protected readonly _elementOverrides: Id64.Uint32Map<Appearance>;
        // @internal
        getAppearance(elemLo: number, elemHi: number, subcatLo: number, subcatHi: number, geomClass: GeometryClass, modelLo: number, modelHi: number, type: BatchType, animationNodeId: number): Appearance | undefined;
        // @internal
        protected getClassifierAppearance(elemLo: number, elemHi: number, subcatLo: number, subcatHi: number, modelLo: number, modelHi: number, animationNodeId: number): Appearance | undefined;
        // @internal (undocumented)
        protected getElementOverrides(idLo: number, idHi: number, animationNodeId: number): Appearance | undefined;
        getElementOverridesById(id: Id64String): Appearance | undefined;
        getFeatureAppearance(feature: Feature, modelId: Id64String, type?: BatchType): Appearance | undefined;
        // @internal (undocumented)
        protected getModelOverrides(idLo: number, idHi: number): Appearance | undefined;
        getModelOverridesById(id: Id64String): Appearance | undefined;
        // @internal (undocumented)
        protected getSubCategoryOverrides(idLo: number, idHi: number): Appearance | undefined;
        getSubCategoryOverridesById(id: Id64String): Appearance | undefined;
        // @internal
        initFromView(view: ViewState): void;
        // @internal
        initFromViewport(viewport: Viewport): void;
        // @internal (undocumented)
        protected isAlwaysDrawn(idLo: number, idHi: number): boolean;
        isAlwaysDrawnExclusive: boolean;
        // @internal (undocumented)
        isClassVisible(geomClass: GeometryClass): boolean;
        isFeatureVisible(feature: Feature): boolean;
        // @internal (undocumented)
        protected isNeverDrawn(elemIdLo: number, elemIdHi: number, animationNodeId: number): boolean;
        isSubCategoryIdVisible(id: Id64String): boolean;
        // @internal
        isSubCategoryVisible(idLo: number, idHi: number): boolean;
        // @internal (undocumented)
        isSubCategoryVisibleInModel(subcatLo: number, subcatHi: number, modelLo: number, modelHi: number): boolean;
        get lineWeights(): boolean;
        // @internal
        protected _lineWeights: boolean;
        // @internal
        protected readonly _modelOverrides: Id64.Uint32Map<Appearance>;
        // @internal
        protected readonly _modelSubCategoryOverrides: Id64.Uint32Map<Id64.Uint32Set>;
        // @internal (undocumented)
        get neverDrawn(): Id64.Uint32Set;
        // @internal
        protected readonly _neverDrawn: Id64.Uint32Set;
        // @internal
        readonly neverDrawnAnimationNodes: Set<number>;
        overrideAnimationNode(id: number, app: Appearance): void;
        overrideElement(id: Id64String, app: Appearance, replaceExisting?: boolean): void;
        overrideModel(id: Id64String, app: Appearance, replaceExisting?: boolean): void;
        overrideSubCategory(id: Id64String, app: Appearance, replaceExisting?: boolean): void;
        // @internal
        protected _patterns: boolean;
        setAlwaysDrawn(id: Id64String): void;
        setAlwaysDrawnSet(ids: Id64Set, exclusive: boolean, ignoreSubCategory?: boolean): void;
        setAnimationNodeNeverDrawn(id: number): void;
        setDefaultOverrides(appearance: Appearance, replaceExisting?: boolean): void;
        setNeverDrawn(id: Id64String): void;
        setNeverDrawnSet(ids: Id64Set): void;
        setVisibleSubCategory(id: Id64String): void;
        // @internal
        protected readonly _subCategoryOverrides: Id64.Uint32Map<Appearance>;
        // @internal
        protected readonly _visibleSubCategories: Id64.Uint32Set;
        }
}

// @internal
export class FeatureToggleClient {
    evaluateFeature(featureKey: string, defaultValue?: LDFlagValue): LDFlagValue;
    initialize(envKey?: string): Promise<void>;
    isFeatureEnabled(featureKey: string, defaultValue?: boolean): boolean;
    get ldClient(): LDClient;
    protected _ldClient?: LDClient;
    // (undocumented)
    protected readonly _loggingCategory = FrontendLoggerCategory.FeatureToggle;
    // (undocumented)
    protected _offlineValue: boolean;
    setUser(accessToken: AccessToken): Promise<void>;
}

// @alpha
export function findAvailableRealityModels(projectid: string, modelCartographicRange?: CartographicRange | undefined): Promise<ContextRealityModelProps[]>;

// @alpha
export function findAvailableUnattachedRealityModels(projectid: string, iModel?: IModelConnection, modelCartographicRange?: CartographicRange | undefined): Promise<ContextRealityModelProps[]>;

// @public
export class FitViewTool extends ViewTool {
    constructor(viewport: ScreenViewport, oneShot: boolean, doAnimate?: boolean, isolatedOnly?: boolean);
    // (undocumented)
    doAnimate: boolean;
    // (undocumented)
    doFit(viewport: ScreenViewport, oneShot: boolean, doAnimate?: boolean, isolatedOnly?: boolean): Promise<boolean>;
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    isolatedOnly: boolean;
    // (undocumented)
    onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    oneShot: boolean;
    // (undocumented)
    onPostInstall(): void;
    // @beta (undocumented)
    provideToolAssistance(): void;
    // (undocumented)
    static toolId: string;
}

// @internal (undocumented)
export class Flags {
    // (undocumented)
    animateRotation: boolean;
    // (undocumented)
    auxRotationPlane: RotationMode;
    // (undocumented)
    baseMode: number;
    // (undocumented)
    baseRotation: RotationMode;
    // (undocumented)
    bearingFixToPlane2D: boolean;
    // (undocumented)
    contextRotMode: number;
    // (undocumented)
    dialogNeedsUpdate: boolean;
    // (undocumented)
    fixedOrg: boolean;
    // (undocumented)
    haveValidOrigin: boolean;
    // (undocumented)
    ignoreDataButton: boolean;
    // (undocumented)
    inDataPoint: boolean;
    // (undocumented)
    indexLocked: boolean;
    // (undocumented)
    lockedRotation: boolean;
    // (undocumented)
    pointIsOnPlane: boolean;
    // (undocumented)
    redrawCompass: boolean;
    // (undocumented)
    rotationNeedsUpdate: boolean;
    // (undocumented)
    softAngleLock: boolean;
}

// @public
export class FlyViewTool extends ViewManip {
    constructor(vp: ScreenViewport, oneShot?: boolean, isDraggingRequired?: boolean);
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    onReinitialize(): void;
    // @beta (undocumented)
    provideToolAssistance(mainInstrKey: string): void;
    // (undocumented)
    static toolId: string;
}

// @public
export enum FrontendLoggerCategory {
    Authorization = "imodeljs-frontend.Authorization",
    EventSource = "imodeljs-frontend.EventSource",
    FeatureToggle = "imodeljs-frontend.FeatureToggles",
    FrontendRequestContext = "imodeljs-frontend.FrontendRequestContext",
    IModelConnection = "imodeljs-frontend.IModelConnection",
    // @deprecated
    OidcBrowserClient = "imodeljs-frontend.OidcBrowserClient",
    OidcIOSClient = "imodeljs-frontend.OidcIOSClient",
    // (undocumented)
    Package = "imodeljs-frontend"
}

// @public
export class FrontendRequestContext extends ClientRequestContext {
    constructor(activityId?: string);
}

// @public (undocumented)
export class FuzzySearch<T> {
    onGetMultiWordSearchOptions(): Fuse.FuseOptions<T>;
    onGetSingleWordSearchOptions(): Fuse.FuseOptions<T>;
    search(searchedObjects: T[], keys: Array<keyof T>, pattern: string): FuzzySearchResults<T>;
}

// @public
export interface FuzzySearchResult<T> {
    getBoldMask(): boolean[];
    getMatchedKey(): string;
    getMatchedValue(): string;
    getResult(): T;
}

// @public
export class FuzzySearchResults<T> implements Iterable<T> {
    // (undocumented)
    [Symbol.iterator](): any;
    constructor(results: any[] | undefined);
    // (undocumented)
    getResult(resultIndex: number): FuzzySearchResult<T> | undefined;
    // (undocumented)
    get length(): number;
    // (undocumented)
    results: any[];
}

// @internal
export class GeoConverter {
    constructor(iModel: IModelConnection, datum: string);
    // (undocumented)
    getCachedIModelCoordinatesFromGeoCoordinates(geoPoints: XYZProps[]): CachedIModelCoordinatesResponseProps;
    // (undocumented)
    getGeoCoordinatesFromIModelCoordinates(iModelPoints: XYZProps[]): Promise<GeoCoordinatesResponseProps>;
    // (undocumented)
    getIModelCoordinatesFromGeoCoordinates(geoPoints: XYZProps[]): Promise<IModelCoordinatesResponseProps>;
    }

// @public
export class GeometricModel2dState extends GeometricModelState implements GeometricModel2dProps {
    constructor(props: GeometricModel2dProps, iModel: IModelConnection, state?: GeometricModel2dState);
    // @internal (undocumented)
    get asGeometricModel2d(): GeometricModel2dState;
    // @internal (undocumented)
    static get className(): string;
    // @internal (undocumented)
    readonly globalOrigin: Point2d;
    // @internal (undocumented)
    get is3d(): boolean;
    // (undocumented)
    toJSON(): GeometricModel2dProps;
}

// @public
export class GeometricModel3dState extends GeometricModelState {
    constructor(props: GeometricModel3dProps, iModel: IModelConnection, state?: GeometricModel3dState);
    // @internal (undocumented)
    get asGeometricModel3d(): GeometricModel3dState;
    // @internal (undocumented)
    static get className(): string;
    // @internal (undocumented)
    get is3d(): boolean;
    readonly isNotSpatiallyLocated: boolean;
    get iSpatiallyLocated(): boolean;
    readonly isPlanProjection: boolean;
    // @internal (undocumented)
    toJSON(): GeometricModel3dProps;
}

// @public
export abstract class GeometricModelState extends ModelState implements GeometricModelProps {
    constructor(props: GeometricModelProps, iModel: IModelConnection, state?: GeometricModelState);
    // @internal (undocumented)
    get asGeometricModel(): GeometricModelState;
    // @internal (undocumented)
    static get className(): string;
    // @internal (undocumented)
    createTileTreeReference(view: ViewState): TileTreeReference;
    // @internal (undocumented)
    geometryGuid?: string;
    get is2d(): boolean;
    abstract get is3d(): boolean;
    // @internal (undocumented)
    get isGeometricModel(): boolean;
    // @internal
    queryModelRange(): Promise<Range3d>;
    // @internal (undocumented)
    get treeModelId(): Id64String;
}

// @internal
export class GeoServices {
    constructor(iModel: IModelConnection);
    // (undocumented)
    getConverter(datum?: string): GeoConverter | undefined;
    }

// @beta
export function getCenteredViewRect(viewRect: ViewRect, aspectRatio?: number): ViewRect;

// @internal (undocumented)
export function getCesiumWorldTerrainLoader(iModel: IModelConnection, modelId: Id64String, groundBias: number, heightRange: Range1d, wantSkirts: boolean): Promise<TerrainTileLoaderBase | undefined>;

// @beta
export function getCompressedJpegFromCanvas(canvas: HTMLCanvasElement, maxBytes?: number, minCompressionQuality?: number): string | undefined;

// @internal
export function getGcsConverterAvailable(iModel: IModelConnection): Promise<boolean>;

// @public
export function getImageSourceFormatForMimeType(mimeType: string): ImageSourceFormat | undefined;

// @public
export function getImageSourceMimeType(format: ImageSourceFormat): string;

// @internal
export abstract class GltfReader {
    protected constructor(props: GltfReaderProps, iModel: IModelConnection, modelId: Id64String, is3d: boolean, system: RenderSystem, type?: BatchType, isCanceled?: ShouldAbortReadGltf);
    // (undocumented)
    protected readonly _accessors: any;
    // (undocumented)
    protected readonly _batchData: any;
    // (undocumented)
    protected readonly _binaryData: Uint8Array;
    // (undocumented)
    protected readonly _buffer: ByteStream;
    // (undocumented)
    protected readonly _bufferViews: any;
    // (undocumented)
    protected createDisplayParams(materialJson: any, hasBakedLighting: boolean): DisplayParams | undefined;
    // (undocumented)
    protected extractReturnToCenter(extensions: any): number[] | undefined;
    // (undocumented)
    protected findTextureMapping(textureId: string): TextureMapping | undefined;
    // (undocumented)
    getBufferView(json: any, accessorName: string): GltfBufferView | undefined;
    // (undocumented)
    protected readonly _images: any;
    // (undocumented)
    protected readonly _iModel: IModelConnection;
    // (undocumented)
    protected readonly _is3d: boolean;
    // (undocumented)
    protected get _isCanceled(): boolean;
    // (undocumented)
    protected get _isVolumeClassifier(): boolean;
    // (undocumented)
    protected loadTexture(textureId: string, isTransparent: boolean): Promise<void>;
    // (undocumented)
    protected loadTextureImage(imageJson: any, samplerJson: any, isTransparent: boolean): Promise<RenderTexture | undefined>;
    // (undocumented)
    protected loadTextures(): Promise<void>;
    // (undocumented)
    protected readonly _materialValues: any;
    // (undocumented)
    protected readonly _meshes: any;
    // (undocumented)
    protected readonly _modelId: Id64String;
    // (undocumented)
    protected readonly _namedTextures: any;
    // (undocumented)
    protected readonly _nodes: any;
    abstract read(): Promise<GltfReaderResult>;
    // (undocumented)
    protected readBufferData(json: any, accessorName: string, type: GltfDataType): GltfBufferData | undefined;
    // (undocumented)
    readBufferData16(json: any, accessorName: string): GltfBufferData | undefined;
    // (undocumented)
    readBufferData32(json: any, accessorName: string): GltfBufferData | undefined;
    // (undocumented)
    readBufferData8(json: any, accessorName: string): GltfBufferData | undefined;
    // (undocumented)
    readBufferDataFloat(json: any, accessorName: string): GltfBufferData | undefined;
    // (undocumented)
    protected readFeatureIndices(_json: any): number[] | undefined;
    // (undocumented)
    protected readFeatures(features: Mesh.Features, json: any): boolean;
    // (undocumented)
    protected readGltfAndCreateGraphics(isLeaf: boolean, featureTable: FeatureTable, contentRange: ElementAlignedBox3d, transformToRoot?: Transform, pseudoRtcBias?: Vector3d, sizeMultiplier?: number, instances?: InstancedGraphicParams): GltfReaderResult;
    // (undocumented)
    protected readIndices(json: any, accessorName: string): number[] | undefined;
    // (undocumented)
    protected readMeshIndices(mesh: Mesh, json: any): boolean;
    // (undocumented)
    protected readMeshPrimitive(primitive: any, featureTable?: FeatureTable, pseudoRtcBias?: Vector3d): Mesh | undefined;
    // (undocumented)
    protected readNormals(normals: OctEncodedNormal[], json: any, accessorName: string): boolean;
    // (undocumented)
    protected readPolylines(polylines: MeshPolylineList, json: any, accessorName: string, disjoint: boolean): boolean;
    // (undocumented)
    protected readUVParams(params: Point2d[], json: any, accessorName: string): boolean;
    // (undocumented)
    protected readVertices(positions: QPoint3dList, primitive: any, pseudoRtcBias?: Vector3d): boolean;
    // (undocumented)
    protected readonly _renderMaterials: any;
    // (undocumented)
    protected readonly _returnToCenter: number[] | undefined;
    // (undocumented)
    protected readonly _samplers: any;
    // (undocumented)
    protected readonly _scene: any;
    // (undocumented)
    protected readonly _system: RenderSystem;
    // (undocumented)
    protected readonly _techniques: any;
    // (undocumented)
    protected readonly _textures: any;
    // (undocumented)
    protected readonly _type: BatchType;
    // (undocumented)
    protected readonly _yAxisUp: boolean;
}

// @internal
export class GltfReaderProps {
    // (undocumented)
    readonly accessors: any;
    // (undocumented)
    readonly binaryData: Uint8Array;
    // (undocumented)
    readonly buffer: ByteStream;
    // (undocumented)
    readonly bufferViews: any;
    static create(buffer: ByteStream, yAxisUp?: boolean): GltfReaderProps | undefined;
    // (undocumented)
    readonly extensions: any;
    // (undocumented)
    readonly materials: any;
    // (undocumented)
    readonly meshes: any;
    // (undocumented)
    readonly nodes: any;
    // (undocumented)
    readonly samplers: any;
    // (undocumented)
    readonly scene: any;
    // (undocumented)
    readonly techniques: any;
    // (undocumented)
    readonly yAxisUp: boolean;
}

// @internal
export interface GltfReaderResult extends Tile.Content {
    // (undocumented)
    readStatus: TileReadStatus;
}

// @internal (undocumented)
export interface GLTimerResult {
    children?: GLTimerResult[];
    label: string;
    nanoseconds: number;
}

// @internal (undocumented)
export type GLTimerResultCallback = (result: GLTimerResult) => void;

// @public
export class GraphicBranch implements IDisposable {
    constructor(ownsEntries?: boolean);
    add(graphic: RenderGraphic): void;
    // @internal
    animationId?: string;
    clear(): void;
    // @internal (undocumented)
    collectStatistics(stats: RenderMemory.Statistics): void;
    // (undocumented)
    dispose(): void;
    readonly entries: RenderGraphic[];
    // @internal (undocumented)
    getViewFlags(flags: ViewFlags, out?: ViewFlags): ViewFlags;
    // (undocumented)
    get isEmpty(): boolean;
    readonly ownsEntries: boolean;
    // @internal (undocumented)
    setViewFlagOverrides(ovr: ViewFlag.Overrides): void;
    // @internal (undocumented)
    setViewFlags(flags: ViewFlags): void;
    symbologyOverrides?: FeatureSymbology.Overrides;
    }

// @internal
export interface GraphicBranchOptions {
    // (undocumented)
    classifierOrDrape?: RenderPlanarClassifier | RenderTextureDrape;
    // (undocumented)
    clipVolume?: RenderClipVolume;
    // (undocumented)
    iModel?: IModelConnection;
}

// @public
export abstract class GraphicBuilder {
    // @internal
    protected constructor(placement: Transform | undefined, type: GraphicType, viewport: Viewport, pickId?: Id64String);
    abstract activateGraphicParams(graphicParams: GraphicParams): void;
    abstract addArc(arc: Arc3d, isEllipse: boolean, filled: boolean): void;
    abstract addArc2d(ellipse: Arc3d, isEllipse: boolean, filled: boolean, zDepth: number): void;
    addFrustum(frustum: Frustum): void;
    abstract addLineString(points: Point3d[]): void;
    abstract addLineString2d(points: Point2d[], zDepth: number): void;
    abstract addLoop(loop: Loop): void;
    abstract addPath(path: Path): void;
    abstract addPointString(points: Point3d[]): void;
    abstract addPointString2d(points: Point2d[], zDepth: number): void;
    abstract addPolyface(meshData: Polyface, filled: boolean): void;
    addRangeBox(range: Range3d): void;
    abstract addShape(points: Point3d[]): void;
    abstract addShape2d(points: Point2d[], zDepth: number): void;
    abstract finish(): RenderGraphic;
    // @internal (undocumented)
    get iModel(): IModelConnection;
    // @internal (undocumented)
    get isOverlay(): boolean;
    // @internal (undocumented)
    get isSceneGraphic(): boolean;
    // @internal (undocumented)
    get isViewBackground(): boolean;
    // @internal (undocumented)
    get isViewCoordinates(): boolean;
    // @internal (undocumented)
    get isWorldCoordinates(): boolean;
    // (undocumented)
    pickId?: string;
    get placement(): Transform;
    set placement(tf: Transform);
    // @beta
    setBlankingFill(fillColor: ColorDef): void;
    setSymbology(lineColor: ColorDef, fillColor: ColorDef, lineWidth: number, linePixels?: LinePixels): void;
    readonly type: GraphicType;
    readonly viewport: Viewport;
}

// @public
export type GraphicList = RenderGraphic[];

// @public
export enum GraphicType {
    Scene = 1,
    ViewBackground = 0,
    ViewOverlay = 4,
    WorldDecoration = 2,
    WorldOverlay = 3
}

// @public
export enum GridOrientationType {
    AuxCoord = 4,
    View = 0,
    WorldXY = 1,
    WorldXZ = 3,
    WorldYZ = 2
}

// @internal (undocumented)
export interface GroupMark {
    // (undocumented)
    source: ModifyElementSource;
    // (undocumented)
    start: number;
}

// @internal (undocumented)
export enum HilitedState {
    No = 2,
    Unknown = 0,
    Yes = 1
}

// @internal (undocumented)
export interface Hilites {
    // (undocumented)
    readonly elements: Id64.Uint32Set;
    // (undocumented)
    readonly isEmpty: boolean;
    // (undocumented)
    readonly models: Id64.Uint32Set;
    // (undocumented)
    readonly subcategories: Id64.Uint32Set;
}

// @alpha
export class HiliteSet {
    constructor(iModel: IModelConnection, syncWithSelectionSet?: boolean);
    clear(): void;
    // (undocumented)
    get elements(): Id64.Uint32Set;
    // (undocumented)
    iModel: IModelConnection;
    // (undocumented)
    get isEmpty(): boolean;
    // (undocumented)
    readonly models: Id64.Uint32Set;
    setHilite(arg: Id64Arg, onOff: boolean): void;
    // (undocumented)
    readonly subcategories: Id64.Uint32Set;
    get wantSyncWithSelectionSet(): boolean;
    set wantSyncWithSelectionSet(want: boolean);
}

// @public
export class HitDetail {
    constructor(testPoint: Point3d, viewport: ScreenViewport, hitSource: HitSource, hitPoint: Point3d, sourceId: string, priority: HitPriority, distXY: number, distFraction: number, subCategoryId?: string | undefined, geometryClass?: GeometryClass | undefined, modelId?: string | undefined, iModel?: IModelConnection, tileId?: string, isClassifier?: boolean);
    clone(): HitDetail;
    // (undocumented)
    readonly distFraction: number;
    // (undocumented)
    readonly distXY: number;
    draw(_context: DecorateContext): void;
    // (undocumented)
    readonly geometryClass?: GeometryClass | undefined;
    getHitType(): HitDetailType;
    getPoint(): Point3d;
    getToolTip(): Promise<HTMLElement | string>;
    // (undocumented)
    readonly hitPoint: Point3d;
    // (undocumented)
    readonly hitSource: HitSource;
    // @alpha
    get iModel(): IModelConnection;
    // @alpha (undocumented)
    readonly isClassifier: boolean;
    get isElementHit(): boolean;
    // @alpha
    get isExternalIModelHit(): boolean;
    // (undocumented)
    get isModelHit(): boolean;
    isSameHit(otherHit?: HitDetail): boolean;
    // (undocumented)
    readonly modelId?: string | undefined;
    // (undocumented)
    readonly priority: HitPriority;
    // (undocumented)
    readonly sourceId: string;
    // (undocumented)
    readonly subCategoryId?: string | undefined;
    // (undocumented)
    readonly testPoint: Point3d;
    // @alpha (undocumented)
    readonly tileId?: string;
    // (undocumented)
    readonly viewport: ScreenViewport;
}

// @public (undocumented)
export enum HitDetailType {
    // (undocumented)
    Hit = 1,
    // (undocumented)
    Intersection = 3,
    // (undocumented)
    Snap = 2
}

// @public
export enum HitGeomType {
    // (undocumented)
    Arc = 4,
    // (undocumented)
    Curve = 3,
    // (undocumented)
    None = 0,
    // (undocumented)
    Point = 1,
    // (undocumented)
    Segment = 2,
    // (undocumented)
    Surface = 5
}

// @public
export class HitList<T extends HitDetail> {
    addHit(newHit: T): number;
    compare(hit1: HitDetail | undefined, hit2: HitDetail | undefined): -1 | 1 | 0;
    // (undocumented)
    currHit: number;
    // (undocumented)
    dropNulls(): void;
    // (undocumented)
    empty(): void;
    // (undocumented)
    getCurrentHit(): T | undefined;
    getHit(hitNum: number): T | undefined;
    // (undocumented)
    getNextHit(): T | undefined;
    // (undocumented)
    hits: T[];
    insertHit(i: number, hit: T): void;
    // (undocumented)
    get length(): number;
    removeCurrentHit(): void;
    removeHit(hitNum: number): void;
    removeHitsFrom(sourceId: string): boolean;
    // (undocumented)
    resetCurrentHit(): void;
    // (undocumented)
    setCurrentHit(hit: T): void;
    setHit(i: number, p: T | undefined): void;
}

// @public (undocumented)
export interface HitListHolder {
    // (undocumented)
    setHitList(list: HitList<HitDetail> | undefined): void;
}

// @public
export enum HitParentGeomType {
    // (undocumented)
    Mesh = 4,
    // (undocumented)
    None = 0,
    // (undocumented)
    Sheet = 2,
    // (undocumented)
    Solid = 3,
    // (undocumented)
    Text = 5,
    // (undocumented)
    Wire = 1
}

// @public (undocumented)
export enum HitPriority {
    // (undocumented)
    NonPlanarEdge = 2,
    // (undocumented)
    NonPlanarSurface = 5,
    // (undocumented)
    PlanarEdge = 1,
    // (undocumented)
    PlanarSurface = 4,
    // (undocumented)
    SilhouetteEdge = 3,
    // (undocumented)
    Unknown = 6,
    // (undocumented)
    WireEdge = 0
}

// @public
export enum HitSource {
    // (undocumented)
    AccuSnap = 3,
    // (undocumented)
    Application = 6,
    // (undocumented)
    DataPoint = 5,
    // (undocumented)
    EditAction = 7,
    // (undocumented)
    EditActionSS = 8,
    // (undocumented)
    FromUser = 1,
    // (undocumented)
    MotionLocate = 2,
    // (undocumented)
    None = 0,
    // (undocumented)
    TentativeSnap = 4
}

// @beta
export interface IconDefinition {
    iconSpec: string;
    isEnabledFunction?: () => boolean;
}

// @alpha
export interface IconEditorParams extends BasePropertyEditorParams {
    // (undocumented)
    definition: IconDefinition;
    // (undocumented)
    type: PropertyEditorParamTypes.Icon;
}

// @beta
export interface IconListEditorParams extends BasePropertyEditorParams {
    iconValue: string;
    iconValues: string[];
    numColumns?: number;
    // (undocumented)
    type: PropertyEditorParamTypes.IconListData;
}

// @public
export class IconSprites {
    static emptyAll(): void;
    static getSpriteFromUrl(spriteUrl: string): Sprite;
    }

// @public
export class IdleTool extends InteractiveTool {
    // (undocumented)
    exitTool(): void;
    // (undocumented)
    static hidden: boolean;
    // (undocumented)
    onMiddleButtonUp(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onMouseStartDrag(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onMouseWheel(ev: BeWheelEvent): Promise<EventHandled>;
    // (undocumented)
    onTouchMoveStart(ev: BeTouchEvent, startEv: BeTouchEvent): Promise<EventHandled>;
    // (undocumented)
    onTouchTap(ev: BeTouchEvent): Promise<EventHandled>;
    // (undocumented)
    run(): boolean;
    // (undocumented)
    static toolId: string;
}

// @public
export function imageBufferToBase64EncodedPng(buffer: ImageBuffer, preserveAlpha?: boolean): string | undefined;

// @public
export function imageBufferToCanvas(buffer: ImageBuffer, preserveAlpha?: boolean): HTMLCanvasElement | undefined;

// @public
export function imageBufferToPngDataUrl(buffer: ImageBuffer, preserveAlpha?: boolean): string | undefined;

// @public
export function imageElementFromImageSource(source: ImageSource): Promise<HTMLImageElement>;

// @public
export function imageElementFromUrl(url: string): Promise<HTMLImageElement>;

// @internal
export abstract class ImageryProvider {
    // (undocumented)
    abstract constructUrl(row: number, column: number, zoomLevel: number): string;
    // (undocumented)
    geometryAttributionProvider?: MapTileGeometryAttributionProvider;
    // (undocumented)
    abstract getImageryLogo(tileProvider: MapTileTreeReference, viewport: ScreenViewport): HTMLTableRowElement | undefined;
    // (undocumented)
    abstract initialize(): Promise<void>;
    // (undocumented)
    loadTile(row: number, column: number, zoomLevel: number): Promise<ImageSource | undefined>;
    // (undocumented)
    matchesMissingTile(_tileData: Uint8Array): boolean;
    // (undocumented)
    abstract get maximumZoomLevel(): number;
    // (undocumented)
    abstract get minimumZoomLevel(): number;
    // (undocumented)
    protected _requestContext: ClientRequestContext;
    // (undocumented)
    abstract get tileHeight(): number;
    // (undocumented)
    abstract get tileWidth(): number;
}

// @internal
export abstract class ImageryProviderEPSG3857 extends ImageryProvider {
    // (undocumented)
    getEPSG3857Extent(row: number, column: number, zoomLevel: number): {
        left: number;
        right: number;
        top: number;
        bottom: number;
    };
    // (undocumented)
    getEPSG3857X(longitude: number): number;
    // (undocumented)
    getEPSG3857Y(latitude: number): number;
}

// @internal
export class ImdlReader extends GltfReader {
    // (undocumented)
    protected colorDefFromMaterialJson(json: any): ColorDef | undefined;
    static create(stream: ByteStream, iModel: IModelConnection, modelId: Id64String, is3d: boolean, system: RenderSystem, type?: BatchType, loadEdges?: boolean, isCanceled?: ShouldAbortReadGltf, sizeMultiplier?: number, tileId?: string): ImdlReader | undefined;
    // (undocumented)
    protected createDisplayParams(json: any): DisplayParams | undefined;
    // (undocumented)
    protected extractReturnToCenter(_extensions: any): number[] | undefined;
    // (undocumented)
    protected materialFromJson(key: string): RenderMaterial | undefined;
    read(): Promise<GltfReaderResult>;
    // (undocumented)
    protected readFeatureTable(startPos: number): PackedFeatureTable | undefined;
    }

// @public
export class IModelApp {
    // @internal
    static get accuDraw(): AccuDraw;
    static get accuSnap(): AccuSnap;
    // @beta
    static get animationInterval(): BeDuration | undefined;
    static set animationInterval(interval: BeDuration | undefined);
    static get applicationId(): string;
    // @beta
    static applicationLogoCard?: () => HTMLTableRowElement;
    static get applicationVersion(): string;
    static authorizationClient?: IAuthorizationClient;
    // @internal (undocumented)
    static createRenderSys(opts?: RenderSystem.Options): RenderSystem;
    // @internal
    static eventSourceOptions: EventSourceOptions;
    static get features(): FeatureTrackingManager;
    // @internal
    static get featureToggles(): FeatureToggleClient;
    // @internal (undocumented)
    static get hasRenderSystem(): boolean;
    static get i18n(): I18N;
    static get iModelClient(): IModelClient;
    // @internal (undocumented)
    static get initialized(): boolean;
    // @internal (undocumented)
    static get locateManager(): ElementLocateManager;
    // @internal (undocumented)
    static lookupEntityClass(classFullName: string): typeof EntityState | undefined;
    // @internal
    static makeHTMLElement<K extends keyof HTMLElementTagNameMap>(type: K, opt?: {
        parent?: HTMLElement;
        className?: string;
        id?: string;
        innerHTML?: string;
        innerText?: string;
    }): HTMLElementTagNameMap[K];
    // @internal
    static makeIModelJsLogoCard(): HTMLTableRowElement;
    // @beta
    static makeLogoCard(opts: {
        heading: string | HTMLElement;
        iconSrc?: string | HTMLImageElement;
        iconWidth?: number;
        notice?: string | HTMLElement;
    }): HTMLTableRowElement;
    // @internal
    static makeModalDiv(options: ModalOptions): ModalReturn;
    static get notifications(): NotificationManager;
    // @internal (undocumented)
    static get pluginAdmin(): PluginAdmin;
    // @alpha
    static get quantityFormatter(): QuantityFormatter;
    // @beta
    static queryRenderCompatibility(): WebGLRenderCompatibilityInfo;
    // @internal
    static registerEntityState(classFullName: string, classType: typeof EntityState): void;
    // @internal
    static registerModuleEntities(moduleObj: any): void;
    static get renderSystem(): RenderSystem;
    // @internal (undocumented)
    static requestNextAnimation(): void;
    static sessionId: GuidString;
    static get settings(): SettingsAdmin;
    static shutdown(): void;
    // @internal (undocumented)
    static startEventLoop(): void;
    static startup(opts?: IModelAppOptions): void;
    // @internal (undocumented)
    static get tentativePoint(): TentativePoint;
    // @internal (undocumented)
    static get terrainProvider(): TerrainProvider | undefined;
    // @alpha
    static get tileAdmin(): TileAdmin;
    static get toolAdmin(): ToolAdmin;
    static readonly tools: ToolRegistry;
    static get uiAdmin(): UiAdmin;
    static get viewManager(): ViewManager;
    }

// @public
export interface IModelAppOptions {
    // @internal
    accuDraw?: AccuDraw;
    accuSnap?: AccuSnap;
    applicationId?: string;
    applicationVersion?: string;
    authorizationClient?: IAuthorizationClient;
    features?: FeatureTrackingManager;
    // @internal
    featureToggles?: FeatureToggleClient;
    i18n?: I18N | I18NOptions;
    imodelClient?: IModelClient;
    // @internal (undocumented)
    locateManager?: ElementLocateManager;
    notifications?: NotificationManager;
    // @internal (undocumented)
    pluginAdmin?: PluginAdmin;
    // @internal (undocumented)
    quantityFormatter?: QuantityFormatter;
    // @internal (undocumented)
    renderSys?: RenderSystem | RenderSystem.Options;
    // @internal (undocumented)
    sessionId?: GuidString;
    settings?: SettingsAdmin;
    // @internal (undocumented)
    tentativePoint?: TentativePoint;
    // @internal (undocumented)
    terrainProvider?: TerrainProvider;
    // @alpha
    tileAdmin?: TileAdmin;
    toolAdmin?: ToolAdmin;
    uiAdmin?: UiAdmin;
    viewManager?: ViewManager;
}

// @public
export class IModelConnection extends IModel {
    // @internal
    attachChangeCache(): Promise<void>;
    cartographicToSpatial(cartographic: Cartographic, result?: Point3d): Promise<Point3d>;
    cartographicToSpatialFromGcs(cartographic: Cartographic, result?: Point3d): Promise<Point3d>;
    // @internal
    changeCacheAttached(): Promise<boolean>;
    close(): Promise<void>;
    // @beta
    closeSnapshot(): Promise<void>;
    readonly codeSpecs: IModelConnection.CodeSpecs;
    static connectionTimeout: number;
    // @beta
    static createBlank(props: BlankConnectionProps): IModelConnection;
    // @internal
    detachChangeCache(): Promise<void>;
    // @internal
    readonly displayedExtents: AxisAlignedBox3d;
    readonly elements: IModelConnection.Elements;
    // @internal
    readonly eventSource: EventSource | undefined;
    findClassFor<T extends typeof EntityState>(className: string, defaultClass: T | undefined): Promise<T | undefined>;
    fontMap?: FontMap;
    // @internal
    readonly geoServices: GeoServices;
    // @beta
    getMassProperties(requestProps: MassPropertiesRequestProps): Promise<MassPropertiesResponseProps>;
    getToolTipMessage(id: Id64String): Promise<string[]>;
    // @alpha
    readonly hilited: HiliteSet;
    // @beta
    readonly isBlank: boolean;
    // @beta
    get isClosed(): boolean;
    // @beta
    get isOpen(): boolean;
    get isReadonly(): boolean;
    loadFontMap(): Promise<FontMap>;
    readonly models: IModelConnection.Models;
    // @internal
    protected _noGcsDefined?: boolean;
    static readonly onClose: BeEvent<(_imodel: IModelConnection) => void>;
    // @beta
    readonly onClose: BeEvent<(_imodel: IModelConnection) => void>;
    static readonly onOpen: BeEvent<(_imodel: IModelConnection) => void>;
    static open(contextId: string, iModelId: string, openMode?: OpenMode, version?: IModelVersion): Promise<IModelConnection>;
    readonly openMode: OpenMode;
    // @beta
    static openSnapshot(fileName: string): Promise<IModelConnection>;
    // @beta
    query(ecsql: string, bindings?: any[] | object, limitRows?: number, quota?: QueryQuota, priority?: QueryPriority): AsyncIterableIterator<any>;
    queryEntityIds(params: EntityQueryParams): Promise<Id64Set>;
    queryRowCount(ecsql: string, bindings?: any[] | object): Promise<number>;
    // @internal
    queryRows(ecsql: string, bindings?: any[] | object, limit?: QueryLimit, quota?: QueryQuota, priority?: QueryPriority): Promise<QueryResponse>;
    requestSnap(props: SnapRequestProps): Promise<SnapResponseProps>;
    saveChanges(description?: string): Promise<void>;
    readonly selectionSet: SelectionSet;
    spatialToCartographic(spatial: XYAndZ, result?: Cartographic): Promise<Cartographic>;
    spatialToCartographicFromGcs(spatial: XYAndZ, result?: Cartographic): Promise<Cartographic>;
    // @internal
    readonly subcategories: SubCategoriesCache;
    // @internal
    readonly tiles: IModelConnection.Tiles;
    readonly transientIds: TransientIdSequence;
    updateProjectExtents(newExtents: AxisAlignedBox3d): Promise<void>;
    readonly views: IModelConnection.Views;
}

// @public (undocumented)
export namespace IModelConnection {
    export class CodeSpecs {
        // @internal
        constructor(_iModel: IModelConnection);
        getById(codeSpecId: Id64String): Promise<CodeSpec>;
        getByName(name: string): Promise<CodeSpec>;
        }
    export class Elements {
        // @internal
        constructor(_iModel: IModelConnection);
        getProps(arg: Id64Arg): Promise<ElementProps[]>;
        queryIds(params: EntityQueryParams): Promise<Id64Set>;
        queryProps(params: EntityQueryParams): Promise<ElementProps[]>;
        get rootSubjectId(): Id64String;
    }
    export class Models {
        // @internal
        constructor(_iModel: IModelConnection);
        // @alpha
        filterLoaded(modelIds: Id64Arg): Id64Set | undefined;
        getLoaded(id: string): ModelState | undefined;
        getProps(modelIds: Id64Arg): Promise<ModelProps[]>;
        load(modelIds: Id64Arg): Promise<void>;
        loaded: Map<string, ModelState>;
        // @alpha
        query(queryParams: ModelQueryParams): AsyncIterableIterator<ModelProps>;
        queryModelRanges(modelIds: Id64Arg): Promise<Range3dProps[]>;
        queryProps(queryParams: ModelQueryParams): Promise<ModelProps[]>;
        get repositoryModelId(): string;
    }
    // @internal
    export class Tiles {
        constructor(iModel: IModelConnection);
        // (undocumented)
        dispose(): void;
        // (undocumented)
        dropSupplier(supplier: TileTree.Supplier): void;
        // (undocumented)
        forEachTreeOwner(func: (owner: TileTree.Owner) => void): void;
        // (undocumented)
        getTileContent(treeId: string, contentId: string, isCanceled: () => boolean, guid: string | undefined): Promise<Uint8Array>;
        // (undocumented)
        getTileTreeOwner(id: any, supplier: TileTree.Supplier): TileTree.Owner;
        // (undocumented)
        getTileTreeProps(id: string): Promise<TileTreeProps>;
        // (undocumented)
        get isDisposed(): boolean;
        purge(olderThan: BeTimePoint, exclude?: Set<TileTree>): void;
        // (undocumented)
        purgeTileTrees(modelIds: Id64Array | undefined): Promise<void>;
        reset(): void;
        }
    export class Views {
        // @internal
        constructor(_iModel: IModelConnection);
        getThumbnail(viewId: Id64String): Promise<ThumbnailProps>;
        getViewList(queryParams: ViewQueryParams): Promise<ViewSpec[]>;
        load(viewDefinitionId: Id64String): Promise<ViewState>;
        queryDefaultViewId(): Promise<Id64String>;
        queryProps(queryParams: ViewQueryParams): Promise<ViewDefinitionProps[]>;
        saveThumbnail(viewId: Id64String, thumbnail: ThumbnailProps): Promise<void>;
    }
    export interface ViewSpec {
        class: string;
        id: string;
        name: string;
    }
}

// @internal
export class IModelTileLoader extends TileLoader {
    constructor(iModel: IModelConnection, formatVersion: number | undefined, batchType: BatchType, edgesRequired: boolean, allowInstancing: boolean, guid: string | undefined);
    // (undocumented)
    adjustContentIdSizeMultiplier(contentId: string, sizeMultiplier: number): string;
    // (undocumented)
    protected get _batchType(): BatchType;
    // (undocumented)
    getChildrenProps(parent: Tile): Promise<TileProps[]>;
    // (undocumented)
    protected get _loadEdges(): boolean;
    // (undocumented)
    get maxDepth(): number;
    // (undocumented)
    onActiveRequestCanceled(tile: Tile): void;
    // (undocumented)
    get priority(): Tile.LoadPriority;
    // (undocumented)
    requestTileContent(tile: Tile, isCanceled: () => boolean): Promise<TileRequest.Response>;
    // (undocumented)
    get rootContentId(): string;
    // (undocumented)
    tileRequiresLoading(params: Tile.Params): boolean;
    // (undocumented)
    get viewFlagOverrides(): ViewFlag.Overrides;
    // (undocumented)
    protected static _viewFlagOverrides: ViewFlag.Overrides;
}

// @public
export abstract class InputCollector extends InteractiveTool {
    // (undocumented)
    exitTool(): void;
    // (undocumented)
    onResetButtonUp(_ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    run(..._args: any[]): boolean;
}

// @beta
export interface InputEditorSizeParams extends BasePropertyEditorParams {
    maxLength?: number;
    size?: number;
    // (undocumented)
    type: PropertyEditorParamTypes.InputEditorSize;
}

// @public
export enum InputSource {
    Mouse = 1,
    Touch = 2,
    Unknown = 0
}

// @internal
export interface InstancedGraphicParams {
    readonly count: number;
    readonly featureIds?: Uint8Array;
    readonly symbologyOverrides?: Uint8Array;
    readonly transformCenter: Point3d;
    readonly transforms: Float32Array;
}

// @public
export abstract class InteractiveTool extends Tool {
    // @beta
    applyToolSettingPropertyChange(_updatedValue: ToolSettingsPropertySyncItem): boolean;
    beginDynamics(): void;
    changeLocateState(enableLocate: boolean, enableSnap?: boolean, cursor?: string, coordLockOvr?: CoordinateLockOverrides): void;
    decorate(_context: DecorateContext): void;
    decorateSuspended(_context: DecorateContext): void;
    endDynamics(): void;
    // (undocumented)
    abstract exitTool(): void;
    filterHit(_hit: HitDetail, _out?: LocateResponse): Promise<LocateFilterStatus>;
    getCurrentButtonEvent(ev: BeButtonEvent): void;
    getDecorationGeometry(_hit: HitDetail): GeometryStreamProps | undefined;
    getToolTip(_hit: HitDetail): Promise<HTMLElement | string>;
    initLocateElements(enableLocate?: boolean, enableSnap?: boolean, cursor?: string, coordLockOvr?: CoordinateLockOverrides): void;
    // (undocumented)
    isCompatibleViewport(_vp: ScreenViewport, _isSelectedViewChange: boolean): boolean;
    get isDynamicsStarted(): boolean;
    // (undocumented)
    isValidLocation(_ev: BeButtonEvent, _isButtonEvent: boolean): boolean;
    onCleanup(): void;
    onDataButtonDown(_ev: BeButtonEvent): Promise<EventHandled>;
    onDataButtonUp(_ev: BeButtonEvent): Promise<EventHandled>;
    onDynamicFrame(_ev: BeButtonEvent, _context: DynamicsContext): void;
    onInstall(): boolean;
    onKeyTransition(_wentDown: boolean, _keyEvent: KeyboardEvent): Promise<EventHandled>;
    onMiddleButtonDown(_ev: BeButtonEvent): Promise<EventHandled>;
    onMiddleButtonUp(_ev: BeButtonEvent): Promise<EventHandled>;
    onModifierKeyTransition(_wentDown: boolean, _modifier: BeModifierKeys, _event: KeyboardEvent): Promise<EventHandled>;
    onMouseEndDrag(ev: BeButtonEvent): Promise<EventHandled>;
    onMouseMotion(_ev: BeButtonEvent): Promise<void>;
    onMouseStartDrag(_ev: BeButtonEvent): Promise<EventHandled>;
    onMouseWheel(_ev: BeWheelEvent): Promise<EventHandled>;
    onPostInstall(): void;
    onReinitialize(): void;
    onResetButtonDown(_ev: BeButtonEvent): Promise<EventHandled>;
    onResetButtonUp(_ev: BeButtonEvent): Promise<EventHandled>;
    onSelectedViewportChanged(_previous: ScreenViewport | undefined, _current: ScreenViewport | undefined): void;
    onSuspend(): void;
    onTouchCancel(_ev: BeTouchEvent): Promise<void>;
    onTouchComplete(_ev: BeTouchEvent): Promise<void>;
    onTouchEnd(_ev: BeTouchEvent): Promise<void>;
    onTouchMove(_ev: BeTouchEvent): Promise<void>;
    onTouchMoveStart(_ev: BeTouchEvent, _startEv: BeTouchEvent): Promise<EventHandled>;
    onTouchStart(_ev: BeTouchEvent): Promise<void>;
    onTouchTap(_ev: BeTouchEvent): Promise<EventHandled>;
    onUnsuspend(): void;
    receivedDownEvent: boolean;
    // @beta
    supplyToolSettingsProperties(): ToolSettingsPropertyRecord[] | undefined;
    // @beta
    syncToolSettingsProperties(syncData: ToolSettingsPropertySyncItem[]): void;
    testDecorationHit(_id: string): boolean;
}

// @public (undocumented)
export class IntersectDetail extends SnapDetail {
    constructor(from: SnapDetail, heat: SnapHeat | undefined, snapPoint: XYZProps, otherPrimitive: CurvePrimitive, otherId: string);
    // (undocumented)
    draw(context: DecorateContext): void;
    // (undocumented)
    readonly otherId: string;
    // (undocumented)
    readonly otherPrimitive: CurvePrimitive;
}

// @alpha (undocumented)
export enum ItemField {
    // (undocumented)
    ANGLE_Item = 1,
    // (undocumented)
    DIST_Item = 0,
    // (undocumented)
    X_Item = 2,
    // (undocumented)
    Y_Item = 3,
    // (undocumented)
    Z_Item = 4
}

// @alpha
export interface JsonEditorParams extends BasePropertyEditorParams {
    // (undocumented)
    json: any;
    // (undocumented)
    type: PropertyEditorParamTypes.JSON;
}

// @internal (undocumented)
export enum KeyinStatus {
    // (undocumented)
    DontUpdate = 2,
    // (undocumented)
    Dynamic = 0,
    // (undocumented)
    Partial = 1
}

// @beta
export class LengthDescription extends BaseQuantityDescription {
    constructor(name?: string, displayLabel?: string, iconSpec?: string);
    // (undocumented)
    get parseError(): string;
    // (undocumented)
    get quantityType(): QuantityType;
}

// @internal (undocumented)
export function linePlaneIntersect(outP: Point3d, linePt: Point3d, lineNormal: Vector3d | undefined, planePt: Point3d, planeNormal: Vector3d, perpendicular: boolean): void;

// @beta
export interface LinkElementsInfo {
    matcher?: (displayValue: string) => Array<{
        start: number;
        end: number;
    }>;
    onClick?: (record: PropertyRecord, text: string) => void;
}

// @internal (undocumented)
export class LoadSavedPluginsResult {
    constructor(status: LoadSavedPluginsStatus, i18nkey?: string | undefined, pluginResults?: Map<string, PluginLoadResults> | undefined);
    // (undocumented)
    i18nkey?: string | undefined;
    // (undocumented)
    pluginResults?: Map<string, PluginLoadResults> | undefined;
    // (undocumented)
    report(): void;
    // (undocumented)
    status: LoadSavedPluginsStatus;
}

// @internal (undocumented)
export enum LoadSavedPluginsStatus {
    // (undocumented)
    AllPluginsFailedToLoad = 5,
    // (undocumented)
    LoadError = 6,
    // (undocumented)
    NoSavedPlugins = 2,
    // (undocumented)
    NotLoggedIn = 1,
    // (undocumented)
    SettingsInvalid = 3,
    // (undocumented)
    SomePluginsFailedToLoad = 4,
    // (undocumented)
    Success = 0
}

// @public
export enum LocateAction {
    // (undocumented)
    AutoLocate = 1,
    // (undocumented)
    Identify = 0
}

// @public
export enum LocateFilterStatus {
    // (undocumented)
    Accept = 0,
    // (undocumented)
    Reject = 1
}

// @public
export class LocateOptions {
    allowDecorations: boolean;
    // @alpha
    allowExternalIModels: boolean;
    allowNonLocatable: boolean;
    clone(): LocateOptions;
    hitSource: HitSource;
    // (undocumented)
    init(): void;
    maxHits: number;
    // (undocumented)
    setFrom(other: LocateOptions): void;
}

// @public (undocumented)
export class LocateResponse {
    // (undocumented)
    explanation: string;
    // (undocumented)
    reason?: string;
    // (undocumented)
    snapStatus: SnapStatus;
}

// @internal (undocumented)
export enum LockedStates {
    // (undocumented)
    ANGLE_BM = 7,
    // (undocumented)
    DIST_BM = 8,
    // (undocumented)
    NONE_LOCKED = 0,
    // (undocumented)
    VEC_BM = 4,
    // (undocumented)
    X_BM = 1,
    // (undocumented)
    XY_BM = 3,
    // (undocumented)
    Y_BM = 2
}

// @beta
export class LookAndMoveTool extends ViewManip {
    constructor(vp: ScreenViewport, oneShot?: boolean, isDraggingRequired?: boolean);
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    onReinitialize(): void;
    // (undocumented)
    provideToolAssistance(mainInstrKey: string): void;
    // (undocumented)
    static toolId: string;
}

// @public
export class LookViewTool extends ViewManip {
    constructor(vp: ScreenViewport, oneShot?: boolean, isDraggingRequired?: boolean);
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    onReinitialize(): void;
    // (undocumented)
    static toolId: string;
}

// @alpha (undocumented)
export enum ManipulatorToolEvent {
    // (undocumented)
    Start = 1,
    // (undocumented)
    Stop = 2,
    // (undocumented)
    Suspend = 3,
    // (undocumented)
    Unsuspend = 4
}

// @internal
export class MapImageryTileTreeReference extends MapTileTreeReference {
    constructor(imageryProvider: ImageryProvider, groundBias: number, applyTerrain: boolean, iModel: IModelConnection, graphicType?: TileTree.GraphicType, transparency?: number);
    // (undocumented)
    applyTerrain: boolean;
    // (undocumented)
    graphicType: TileTree.GraphicType;
    // (undocumented)
    protected get _graphicType(): TileTree.GraphicType;
    // (undocumented)
    groundBias: number;
    // (undocumented)
    protected get _groundBias(): number;
    // (undocumented)
    protected get _imageryProvider(): ImageryProvider;
    // (undocumented)
    protected readonly _iModel: IModelConnection;
    // (undocumented)
    provider: ImageryProvider;
    // (undocumented)
    transparency?: number;
    // (undocumented)
    protected get _transparency(): number | undefined;
    // (undocumented)
    get treeOwner(): TileTree.Owner;
}

// @internal (undocumented)
export interface MapTileGeometryAttributionProvider {
    // (undocumented)
    getGeometryLogo(tileProvider: MapTileTreeReference, viewport: ScreenViewport): HTMLTableRowElement | undefined;
}

// @internal (undocumented)
export abstract class MapTileLoaderBase extends ContextTileLoader {
    constructor(_iModel: IModelConnection, _modelId: Id64String, _groundBias: number, _mapTilingScheme: MapTilingScheme, heightRange?: Range1d);
    // (undocumented)
    protected _applyLights: boolean;
    // (undocumented)
    protected _featureTable: PackedFeatureTable;
    // (undocumented)
    getChildrenProps(_parent: Tile): Promise<TileProps[]>;
    // (undocumented)
    protected _groundBias: number;
    // (undocumented)
    get heightRange(): Range1d | undefined;
    // (undocumented)
    protected readonly _heightRange: Range1d | undefined;
    // (undocumented)
    protected _iModel: IModelConnection;
    // (undocumented)
    get isContentUnbounded(): boolean;
    // (undocumented)
    isLeaf(quadId: QuadId): boolean;
    // (undocumented)
    abstract loadTileContent(tile: Tile, data: TileRequest.ResponseData, isCanceled?: () => boolean): Promise<Tile.Content>;
    // (undocumented)
    protected _mapTilingScheme: MapTilingScheme;
    // (undocumented)
    abstract get maxDepth(): number;
    // (undocumented)
    protected _modelId: Id64String;
    // (undocumented)
    get priority(): Tile.LoadPriority;
    // (undocumented)
    abstract requestTileContent(tile: Tile, _isCanceled: () => boolean): Promise<TileRequest.Response>;
    // (undocumented)
    tileRequiresLoading(params: Tile.Params): boolean;
}

// @internal
export abstract class MapTileTreeReference extends TileTreeReference {
    addLogoCards(cards: HTMLTableElement, vp: ScreenViewport): void;
    // (undocumented)
    addPlanes(planes: Plane3dByOriginAndUnitNormal[]): void;
    addToScene(context: SceneContext): void;
    getTilesForView(viewport: Viewport): Tile[];
    // (undocumented)
    protected abstract get _graphicType(): TileTree.GraphicType;
    // (undocumented)
    protected abstract get _groundBias(): number;
    // (undocumented)
    protected abstract get _imageryProvider(): ImageryProvider | undefined;
    // (undocumented)
    get plane(): Plane3dByOriginAndUnitNormal;
    // (undocumented)
    protected abstract get _transparency(): number | undefined;
    unionFitRange(_range: Range3d): void;
}

// @public
export class MarginPercent {
    constructor(left: number, top: number, right: number, bottom: number);
    // (undocumented)
    bottom: number;
    // (undocumented)
    left: number;
    // (undocumented)
    right: number;
    // (undocumented)
    top: number;
}

// @public
export class Marker implements CanvasDecoration {
    constructor(worldLocation: XYAndZ, size: XAndY);
    addDecoration(context: DecorateContext): void;
    addMarker(context: DecorateContext): void;
    drawDecoration(ctx: CanvasRenderingContext2D): void;
    drawFunc?(ctx: CanvasRenderingContext2D): void;
    protected drawHilited(ctx: CanvasRenderingContext2D): boolean;
    protected _hiliteColor?: ColorDef;
    htmlElement?: HTMLElement;
    image?: MarkerImage;
    imageOffset?: XAndY;
    imageSize?: XAndY;
    protected _isHilited: boolean;
    label?: string;
    labelAlign?: MarkerTextAlign;
    labelBaseline?: MarkerTextBaseline;
    labelColor?: MarkerFillStyle;
    labelFont?: string;
    labelOffset?: XAndY;
    static makeFrom<T extends Marker>(other: Marker, ...args: any[]): T;
    onMouseButton?(_ev: BeButtonEvent): boolean;
    onMouseEnter(ev: BeButtonEvent): void;
    onMouseLeave(): void;
    onMouseMove(ev: BeButtonEvent): void;
    pick(pt: XAndY): boolean;
    position: Point3d;
    protected positionHtml(): void;
    readonly rect: ViewRect;
    // (undocumented)
    protected _scaleFactor?: Point2d;
    // (undocumented)
    protected _scaleFactorRange?: Range1d;
    setImage(image: MarkerImage | Promise<MarkerImage>): void;
    setImageUrl(url: string): void;
    setPosition(vp: Viewport, markerSet?: MarkerSet<Marker>): boolean;
    setScaleFactor(range: Range1dProps): void;
    size: Point2d;
    title?: HTMLElement | string;
    tooltipOptions?: ToolTipOptions;
    visible: boolean;
    get wantImage(): boolean;
    worldLocation: Point3d;
}

// @public (undocumented)
export type MarkerFillStyle = string | CanvasGradient | CanvasPattern;

// @public
export type MarkerImage = HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | ImageBitmap;

// @public
export abstract class MarkerSet<T extends Marker> {
    constructor(viewport?: ScreenViewport);
    addDecoration(context: DecorateContext): void;
    // @beta
    changeViewport(viewport: ScreenViewport): void;
    // @internal (undocumented)
    protected _entries: Array<T | Cluster<T>>;
    protected abstract getClusterMarker(cluster: Cluster<T>): Marker;
    getMinScaleViewW(vp: Viewport): number;
    markDirty(): void;
    get markers(): Set<T>;
    minimumClusterSize: number;
    // @internal (undocumented)
    protected _minScaleViewW?: number;
    get viewport(): ScreenViewport | undefined;
    // @internal (undocumented)
    protected readonly _worldToViewMap: Matrix4d;
}

// @public (undocumented)
export type MarkerTextAlign = "left" | "right" | "center" | "start" | "end";

// @public (undocumented)
export type MarkerTextBaseline = "top" | "hanging" | "middle" | "alphabetic" | "ideographic" | "bottom";

// @alpha (undocumented)
export class MeasureAreaByPointsTool extends PrimitiveTool {
    // (undocumented)
    protected _acceptedMeasurement?: MeasureMarker;
    // (undocumented)
    protected allowView(vp: Viewport): boolean;
    // (undocumented)
    applyToolSettingPropertyChange(updatedValue: ToolSettingsPropertySyncItem): boolean;
    // (undocumented)
    protected _area: number;
    // (undocumented)
    protected _centroid: Point3d;
    // (undocumented)
    decorate(context: DecorateContext): void;
    // (undocumented)
    decorateSuspended(context: DecorateContext): void;
    // (undocumented)
    protected static enumAsOrientationMessage(str: string): any;
    // (undocumented)
    protected static _getEnumAsOrientationDescription: () => PropertyDescription;
    // (undocumented)
    protected getMarkerToolTip(): Promise<HTMLElement>;
    // (undocumented)
    protected getShapePoints(ev: BeButtonEvent): Point3d[];
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    isCompatibleViewport(vp: Viewport | undefined, isSelectedViewChange: boolean): boolean;
    // (undocumented)
    protected _isComplete: boolean;
    // (undocumented)
    isValidLocation(_ev: BeButtonEvent, _isButtonEvent: boolean): boolean;
    // (undocumented)
    protected _marker?: MeasureLabel;
    // (undocumented)
    protected _matrix?: Matrix3d;
    // (undocumented)
    onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onKeyTransition(wentDown: boolean, keyEvent: KeyboardEvent): Promise<EventHandled>;
    // (undocumented)
    onMouseMotion(ev: BeButtonEvent): Promise<void>;
    // (undocumented)
    onPostInstall(): void;
    // (undocumented)
    onReinitialize(): void;
    // (undocumented)
    onResetButtonUp(_ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onRestartTool(): void;
    // (undocumented)
    onUndoPreviousStep(): Promise<boolean>;
    // (undocumented)
    onUnsuspend(): void;
    // (undocumented)
    get orientation(): EditManipulator.RotationType;
    set orientation(option: EditManipulator.RotationType);
    // (undocumented)
    protected static _orientationName: string;
    // (undocumented)
    protected _perimeter: number;
    // (undocumented)
    protected readonly _points: Point3d[];
    // (undocumented)
    protected reportMeasurements(): void;
    // (undocumented)
    requireWriteableTarget(): boolean;
    // (undocumented)
    protected setupAndPromptForNextAction(): void;
    // (undocumented)
    protected showPrompt(): void;
    // (undocumented)
    supplyToolSettingsProperties(): ToolSettingsPropertyRecord[] | undefined;
    // (undocumented)
    static toolId: string;
    // (undocumented)
    protected updateTotals(): Promise<void>;
}

// @alpha (undocumented)
export class MeasureAreaTool extends MeasureElementTool {
    // (undocumented)
    protected getOperation(): MassPropertiesOperation;
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    onRestartTool(): void;
    // (undocumented)
    static toolId: string;
}

// @alpha (undocumented)
export class MeasureDistanceTool extends PrimitiveTool {
    // (undocumented)
    protected readonly _acceptedSegments: {
        distance: number;
        slope: number;
        start: Point3d;
        end: Point3d;
        delta: Vector3d;
        refAxes: Matrix3d;
        marker: MeasureMarker;
    }[];
    // (undocumented)
    protected acceptNewSegments(): Promise<void>;
    // (undocumented)
    protected allowView(vp: Viewport): boolean;
    // (undocumented)
    protected createDecorations(context: DecorateContext, isSuspended: boolean): void;
    // (undocumented)
    decorate(context: DecorateContext): void;
    // (undocumented)
    decorateSuspended(context: DecorateContext): void;
    // (undocumented)
    protected displayDelta(context: DecorateContext, seg: any): void;
    // (undocumented)
    protected displayDynamicDistance(context: DecorateContext, points: Point3d[]): void;
    // (undocumented)
    getDecorationGeometry(_hit: HitDetail): GeometryStreamProps | undefined;
    // (undocumented)
    protected getMarkerToolTip(distance: number, slope: number, start: Point3d, end: Point3d, delta?: Vector3d): Promise<HTMLElement>;
    // (undocumented)
    protected getReferenceAxes(vp?: Viewport): Matrix3d;
    // (undocumented)
    protected getSnapPoints(): Point3d[] | undefined;
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    isCompatibleViewport(vp: Viewport | undefined, isSelectedViewChange: boolean): boolean;
    // (undocumented)
    isValidLocation(_ev: BeButtonEvent, _isButtonEvent: boolean): boolean;
    // (undocumented)
    protected readonly _locationData: {
        point: Point3d;
        refAxes: Matrix3d;
    }[];
    // (undocumented)
    onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onKeyTransition(wentDown: boolean, keyEvent: KeyboardEvent): Promise<EventHandled>;
    // (undocumented)
    onMouseMotion(ev: BeButtonEvent): Promise<void>;
    // (undocumented)
    onPostInstall(): void;
    // (undocumented)
    onResetButtonUp(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onRestartTool(): void;
    // (undocumented)
    onUndoPreviousStep(): Promise<boolean>;
    // (undocumented)
    onUnsuspend(): void;
    // (undocumented)
    protected reportMeasurements(): void;
    // (undocumented)
    requireWriteableTarget(): boolean;
    // (undocumented)
    protected setupAndPromptForNextAction(): void;
    // (undocumented)
    protected showPrompt(): void;
    // (undocumented)
    protected _snapGeomId?: string;
    // (undocumented)
    testDecorationHit(id: string): boolean;
    // (undocumented)
    static toolId: string;
    // (undocumented)
    protected _totalDistance: number;
    // (undocumented)
    protected _totalDistanceMarker?: MeasureLabel;
    // (undocumented)
    protected updateSelectedMarkerToolTip(seg: any, ev: BeButtonEvent): Promise<void>;
    // (undocumented)
    protected updateTotals(): Promise<void>;
}

// @alpha (undocumented)
export abstract class MeasureElementTool extends PrimitiveTool {
    // (undocumented)
    protected readonly _acceptedIds: Id64Array;
    // (undocumented)
    protected readonly _acceptedMeasurements: MeasureMarker[];
    // (undocumented)
    protected allowView(vp: Viewport): boolean;
    // (undocumented)
    protected readonly _checkedIds: Map<string, MassPropertiesResponseProps>;
    // (undocumented)
    decorate(context: DecorateContext): void;
    // (undocumented)
    decorateSuspended(context: DecorateContext): void;
    // (undocumented)
    doMeasureSelectedElements(viewport: Viewport): Promise<void>;
    // (undocumented)
    filterHit(hit: HitDetail, _out?: LocateResponse): Promise<LocateFilterStatus>;
    // (undocumented)
    protected getMarkerToolTip(responseProps: MassPropertiesResponseProps): Promise<HTMLElement>;
    // (undocumented)
    protected abstract getOperation(): MassPropertiesOperation;
    // (undocumented)
    isCompatibleViewport(vp: Viewport | undefined, isSelectedViewChange: boolean): boolean;
    // (undocumented)
    onCleanup(): void;
    // (undocumented)
    onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onPostInstall(): void;
    // (undocumented)
    onReinitialize(): void;
    // (undocumented)
    onResetButtonUp(_ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onUndoPreviousStep(): Promise<boolean>;
    // (undocumented)
    onUnsuspend(): void;
    // (undocumented)
    protected reportMeasurements(): void;
    // (undocumented)
    requireWriteableTarget(): boolean;
    // (undocumented)
    protected setupAndPromptForNextAction(): void;
    // (undocumented)
    protected showPrompt(): void;
    // (undocumented)
    protected _totalMarker?: MeasureLabel;
    // (undocumented)
    protected _totalValue: number;
    // (undocumented)
    protected updateTotals(selectionSetResult?: MassPropertiesResponseProps): Promise<void>;
    // (undocumented)
    protected _useSelection: boolean;
}

// @alpha (undocumented)
export class MeasureLengthTool extends MeasureElementTool {
    // (undocumented)
    protected getOperation(): MassPropertiesOperation;
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    onRestartTool(): void;
    // (undocumented)
    static toolId: string;
}

// @alpha (undocumented)
export class MeasureLocationTool extends PrimitiveTool {
    // (undocumented)
    protected readonly _acceptedLocations: MeasureMarker[];
    // (undocumented)
    protected allowView(vp: Viewport): boolean;
    // (undocumented)
    decorate(context: DecorateContext): void;
    // (undocumented)
    decorateSuspended(context: DecorateContext): void;
    // (undocumented)
    protected getMarkerToolTip(point: Point3d): Promise<HTMLElement>;
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    isCompatibleViewport(vp: Viewport | undefined, isSelectedViewChange: boolean): boolean;
    // (undocumented)
    isValidLocation(_ev: BeButtonEvent, _isButtonEvent: boolean): boolean;
    // (undocumented)
    onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onPostInstall(): void;
    // (undocumented)
    onResetButtonUp(_ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onRestartTool(): void;
    // (undocumented)
    onUndoPreviousStep(): Promise<boolean>;
    // (undocumented)
    onUnsuspend(): void;
    // (undocumented)
    protected reportMeasurements(): void;
    // (undocumented)
    requireWriteableTarget(): boolean;
    // (undocumented)
    protected setupAndPromptForNextAction(): void;
    // (undocumented)
    protected showPrompt(): void;
    // (undocumented)
    static toolId: string;
}

// @alpha (undocumented)
export class MeasureVolumeTool extends MeasureElementTool {
    // (undocumented)
    protected getOperation(): MassPropertiesOperation;
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    onRestartTool(): void;
    // (undocumented)
    static toolId: string;
}

// @public
export enum MessageBoxIconType {
    // (undocumented)
    Critical = 4,
    // (undocumented)
    Information = 1,
    // (undocumented)
    NoSymbol = 0,
    // (undocumented)
    Question = 2,
    // (undocumented)
    Warning = 3
}

// @public
export enum MessageBoxType {
    // (undocumented)
    LargeOk = 2,
    // (undocumented)
    MediumAlert = 3,
    // (undocumented)
    Ok = 1,
    // (undocumented)
    OkCancel = 0,
    // (undocumented)
    YesNo = 5,
    // (undocumented)
    YesNoCancel = 4
}

// @public
export enum MessageBoxValue {
    // (undocumented)
    Apply = 1,
    // (undocumented)
    Cancel = 4,
    // (undocumented)
    Default = 5,
    // (undocumented)
    Help = 10,
    // (undocumented)
    No = 7,
    // (undocumented)
    NoToAll = 12,
    // (undocumented)
    Ok = 3,
    // (undocumented)
    Reset = 2,
    // (undocumented)
    Retry = 8,
    // (undocumented)
    Stop = 9,
    // (undocumented)
    Yes = 6,
    // (undocumented)
    YesToAll = 11
}

// @internal
export namespace MockRender {
    export class App {
        // (undocumented)
        protected static createDefaultRenderSystem(): System;
        // (undocumented)
        static shutdown(): void;
        // (undocumented)
        static startup(opts?: IModelAppOptions): void;
        // (undocumented)
        static systemFactory: SystemFactory;
    }
    // (undocumented)
    export class Batch extends Graphic {
        constructor(graphic: RenderGraphic, featureTable: PackedFeatureTable, range: ElementAlignedBox3d);
        // (undocumented)
        dispose(): void;
        // (undocumented)
        readonly featureTable: PackedFeatureTable;
        // (undocumented)
        readonly graphic: RenderGraphic;
        // (undocumented)
        readonly range: ElementAlignedBox3d;
    }
    // (undocumented)
    export class Branch extends Graphic {
        constructor(branch: GraphicBranch, transform: Transform, options?: GraphicBranchOptions | undefined);
        // (undocumented)
        readonly branch: GraphicBranch;
        // (undocumented)
        dispose(): void;
        // (undocumented)
        readonly options?: GraphicBranchOptions | undefined;
        // (undocumented)
        readonly transform: Transform;
    }
    // (undocumented)
    export class Builder extends PrimitiveBuilder {
        constructor(system: System, placement: Transform | undefined, type: GraphicType, viewport: Viewport, pickId?: Id64String);
    }
    // (undocumented)
    export class Graphic extends RenderGraphic {
        constructor();
        // (undocumented)
        collectStatistics(_stats: RenderMemory.Statistics): void;
        // (undocumented)
        dispose(): void;
    }
    // (undocumented)
    export class List extends Graphic {
        constructor(graphics: RenderGraphic[]);
        // (undocumented)
        dispose(): void;
        // (undocumented)
        readonly graphics: RenderGraphic[];
    }
    // (undocumented)
    export class OffScreenTarget extends Target {
        constructor(system: System, _viewRect: ViewRect);
        // (undocumented)
        setViewRect(rect: ViewRect, _temp: boolean): void;
        // (undocumented)
        get viewRect(): ViewRect;
        }
    // (undocumented)
    export class OnScreenTarget extends Target {
        constructor(system: System, _canvas: HTMLCanvasElement);
        // (undocumented)
        setViewRect(_rect: ViewRect, _temp: boolean): void;
        // (undocumented)
        get viewRect(): ViewRect;
    }
    // (undocumented)
    export class System extends RenderSystem {
        constructor();
        // (undocumented)
        createBatch(graphic: RenderGraphic, features: PackedFeatureTable, range: ElementAlignedBox3d): Batch;
        // (undocumented)
        createGraphicBranch(branch: GraphicBranch, transform: Transform, options?: GraphicBranchOptions): Branch;
        // (undocumented)
        createGraphicBuilder(placement: Transform, type: GraphicType, viewport: Viewport, pickableId?: Id64String): Builder;
        // (undocumented)
        createGraphicList(primitives: RenderGraphic[]): List;
        // (undocumented)
        createMesh(_params: MeshParams): Graphic;
        // (undocumented)
        createOffscreenTarget(rect: ViewRect): RenderTarget;
        // (undocumented)
        createPointCloud(_args: PointCloudArgs, _imodel: IModelConnection): Graphic;
        // (undocumented)
        createPointString(_params: PointStringParams): Graphic;
        // (undocumented)
        createPolyline(_params: PolylineParams): Graphic;
        // (undocumented)
        createTarget(canvas: HTMLCanvasElement): OnScreenTarget;
        // (undocumented)
        dispose(): void;
        // (undocumented)
        get isValid(): boolean;
        // (undocumented)
        get maxTextureSize(): number;
    }
    // (undocumented)
    export type SystemFactory = () => RenderSystem;
    // (undocumented)
    export abstract class Target extends RenderTarget {
        protected constructor(_system: System);
        // (undocumented)
        get animationFraction(): number;
        set animationFraction(_fraction: number);
        // (undocumented)
        changeBackgroundMap(_backgroundMap: GraphicList): void;
        // (undocumented)
        changeDecorations(_decs: Decorations): void;
        // (undocumented)
        changeDynamics(_dynamics?: GraphicList): void;
        // (undocumented)
        changeOverlayGraphics(_overlayGraphics: GraphicList): void;
        // (undocumented)
        changeRenderPlan(_plan: RenderPlan): void;
        // (undocumented)
        changeScene(_scene: GraphicList): void;
        // (undocumented)
        drawFrame(_sceneTime?: number): void;
        // (undocumented)
        readPixels(_rect: ViewRect, _selector: Pixel.Selector, receiver: Pixel.Receiver, _excludeNonLocatable: boolean): void;
        // (undocumented)
        get renderSystem(): RenderSystem;
        // (undocumented)
        updateViewRect(): boolean;
        // (undocumented)
        get wantInvertBlackBackground(): boolean;
    }
}

// @internal
export interface ModalOptions {
    autoClose?: boolean;
    closeBox?: boolean;
    rootDiv?: HTMLElement;
    width?: number;
}

// @internal
export interface ModalReturn {
    modal: HTMLDivElement;
    stop: (_ev: Event) => void;
}

// @public
export class ModelSelectorState extends ElementState {
    constructor(props: ModelSelectorProps, iModel: IModelConnection);
    addModels(arg: Id64Arg): void;
    // @internal (undocumented)
    static get className(): string;
    containsModel(modelId: Id64String): boolean;
    dropModels(arg: Id64Arg): void;
    equalState(other: ModelSelectorState): boolean;
    has(id: string): boolean;
    load(): Promise<void>;
    readonly models: Set<string>;
    get name(): string;
    // (undocumented)
    toJSON(): ModelSelectorProps;
}

// @public
export class ModelState extends EntityState implements ModelProps {
    constructor(props: ModelProps, iModel: IModelConnection, state?: ModelState);
    get asGeometricModel(): GeometricModelState | undefined;
    get asGeometricModel2d(): GeometricModel2dState | undefined;
    get asGeometricModel3d(): GeometricModel3dState | undefined;
    get asSpatialModel(): SpatialModelState | undefined;
    // @internal (undocumented)
    static get className(): string;
    // @internal
    getToolTip(_hit: HitDetail): HTMLElement | string | undefined;
    get isGeometricModel(): boolean;
    // (undocumented)
    readonly isPrivate: boolean;
    // (undocumented)
    readonly isTemplate: boolean;
    // (undocumented)
    readonly modeledElement: RelatedElement;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    parentModel: Id64String;
    toJSON(): ModelProps;
}

// @internal (undocumented)
export enum ModifyElementSource {
    DragSelect = 5,
    Fence = 3,
    Group = 4,
    Selected = 1,
    SelectionSet = 2,
    Unknown = 0
}

// @alpha
export interface MultilineTextEditorParams extends BasePropertyEditorParams {
    // (undocumented)
    heightInRows: number;
    // (undocumented)
    type: PropertyEditorParamTypes.MultilineText;
}

// @internal
export class NoRenderApp {
    // (undocumented)
    static startup(opts?: IModelAppOptions): void;
}

// @public
export class NotificationManager {
    clearToolTip(): void;
    closeInputFieldMessage(): void;
    closePointerMessage(): void;
    endActivityMessage(_reason: ActivityMessageEndReason): boolean;
    get isToolTipOpen(): boolean;
    get isToolTipSupported(): boolean;
    openMessageBox(_mbType: MessageBoxType, _message: HTMLElement | string, _icon: MessageBoxIconType): Promise<MessageBoxValue>;
    openToolTip(htmlElement: HTMLElement, message: HTMLElement | string, location?: XAndY, options?: ToolTipOptions): void;
    outputActivityMessage(_messageText: HTMLElement | string, _percentComplete: number): boolean;
    outputMessage(_message: NotifyMessageDetails): void;
    outputPrompt(_prompt: string): void;
    outputPromptByKey(key: string): void;
    // @alpha
    setToolAssistance(instructions: ToolAssistanceInstructions | undefined): void;
    setupActivityMessage(_details: ActivityMessageDetails): boolean;
    protected _showToolTip(_htmlElement: HTMLElement, _message: HTMLElement | string, _location?: XAndY, _options?: ToolTipOptions): void;
    // (undocumented)
    readonly toolTipLocation: Point2d;
    updatePointerMessage(_displayPoint: XAndY, _relativePosition?: RelativePosition_2): void;
}

// @public
export class NotifyMessageDetails {
    constructor(priority: OutputMessagePriority, briefMessage: HTMLElement | string, detailedMessage?: string | HTMLElement | undefined, msgType?: OutputMessageType, openAlert?: OutputMessageAlert);
    // (undocumented)
    briefMessage: HTMLElement | string;
    // (undocumented)
    detailedMessage?: string | HTMLElement | undefined;
    // (undocumented)
    displayPoint?: Point2d;
    // (undocumented)
    displayTime: BeDuration;
    // (undocumented)
    inputField?: HTMLElement;
    // (undocumented)
    msgType: OutputMessageType;
    // (undocumented)
    openAlert: OutputMessageAlert;
    // (undocumented)
    priority: OutputMessagePriority;
    // (undocumented)
    relativePosition: RelativePosition_2;
    setInputFieldTypeDetails(inputField: HTMLElement): void;
    setPointerTypeDetails(viewport: HTMLElement, displayPoint: XAndY, relativePosition?: RelativePosition_2): void;
    // (undocumented)
    viewport?: HTMLElement;
}

// @internal
export class NullRenderSystem extends RenderSystem {
    constructor();
    // (undocumented)
    createBatch(): any;
    // (undocumented)
    createGraphicBranch(): any;
    // (undocumented)
    createGraphicBuilder(): any;
    // (undocumented)
    createGraphicList(): any;
    // (undocumented)
    createOffscreenTarget(): NullTarget;
    // (undocumented)
    createTarget(): NullTarget;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    get isValid(): boolean;
}

// @internal
export class NullTarget extends RenderTarget {
    // (undocumented)
    get animationBranches(): AnimationBranchStates | undefined;
    set animationBranches(_branches: AnimationBranchStates | undefined);
    // (undocumented)
    get animationFraction(): number;
    set animationFraction(_fraction: number);
    // (undocumented)
    changeBackgroundMap(): void;
    // (undocumented)
    changeDecorations(): void;
    // (undocumented)
    changeDynamics(): void;
    // (undocumented)
    changeOverlayGraphics(): void;
    // (undocumented)
    changeRenderPlan(): void;
    // (undocumented)
    changeScene(): void;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    drawFrame(_sceneMilSecElapsed?: number): void;
    // (undocumented)
    onDestroy(): void;
    // (undocumented)
    onResized(): void;
    // (undocumented)
    overrideFeatureSymbology(): void;
    // (undocumented)
    readImage(): undefined;
    // (undocumented)
    readPixels(): void;
    // (undocumented)
    get renderSystem(): any;
    // (undocumented)
    reset(): void;
    // (undocumented)
    setFlashed(): void;
    // (undocumented)
    setHiliteSet(): void;
    // (undocumented)
    setViewRect(): void;
    // (undocumented)
    updateViewRect(): boolean;
    // (undocumented)
    get viewRect(): ViewRect;
    // (undocumented)
    get wantInvertBlackBackground(): boolean;
}

// @internal (undocumented)
export class OffScreenTarget extends Target {
    constructor(rect: ViewRect);
    // (undocumented)
    protected _assignDC(): boolean;
    // (undocumented)
    protected _beginPaint(): void;
    // (undocumented)
    protected _endPaint(): void;
    // (undocumented)
    onResized(): void;
    // (undocumented)
    readImageToCanvas(): HTMLCanvasElement;
    // (undocumented)
    setViewRect(rect: ViewRect, temporary: boolean): void;
    // (undocumented)
    updateViewRect(): boolean;
    // (undocumented)
    get viewRect(): ViewRect;
}

// @internal
export class OffScreenViewport extends Viewport {
    // (undocumented)
    static create(view: ViewState, viewRect?: ViewRect): OffScreenViewport;
    // (undocumented)
    setRect(rect: ViewRect, temporary?: boolean): void;
    // (undocumented)
    get viewRect(): ViewRect;
}

// @beta
export class OidcBrowserClient extends OidcClient implements IOidcFrontendClient {
    constructor(_configuration: OidcFrontendClientConfiguration);
    // (undocumented)
    protected _accessToken?: AccessToken;
    dispose(): void;
    getAccessToken(requestContext?: ClientRequestContext): Promise<AccessToken>;
    // @internal
    protected getUserManagerSettings(requestContext: FrontendRequestContext): Promise<UserManagerSettings>;
    get hasExpired(): boolean;
    get hasSignedIn(): boolean;
    initialize(requestContext: FrontendRequestContext): Promise<void>;
    get isAuthorized(): boolean;
    readonly onUserStateChanged: BeEvent<(token: AccessToken | undefined) => void>;
    signIn(requestContext: ClientRequestContext, successRedirectUrl?: string): Promise<void>;
    protected signInSilent(requestContext: ClientRequestContext): Promise<User>;
    signOut(requestContext: ClientRequestContext): Promise<void>;
    }

// @internal @deprecated
export class OidcBrowserSamlClient extends OidcBrowserClient {
    getSamlToken(requestContext: ClientRequestContext): Promise<AccessToken>;
}

// @alpha
export class OidcDesktopClientRenderer implements IOidcFrontendClient {
    constructor(clientConfiguration: OidcDesktopClientConfiguration);
    dispose(): void;
    getAccessToken(requestContext?: ClientRequestContext): Promise<AccessToken>;
    get hasExpired(): boolean;
    get hasSignedIn(): boolean;
    initialize(requestContext: ClientRequestContext): Promise<void>;
    get isAuthorized(): boolean;
    readonly onUserStateChanged: BeEvent<(token: AccessToken | undefined) => void>;
    signIn(requestContext: ClientRequestContext): Promise<void>;
    signOut(requestContext: ClientRequestContext): Promise<void>;
}

// @internal
export class OnScreenTarget extends Target {
    constructor(canvas: HTMLCanvasElement);
    // (undocumented)
    protected _assignDC(): boolean;
    // (undocumented)
    protected _beginPaint(): void;
    // (undocumented)
    collectStatistics(stats: RenderMemory.Statistics): void;
    // (undocumented)
    get devicePixelRatio(): number;
    // (undocumented)
    get devicePixelRatioOverride(): number | undefined;
    set devicePixelRatioOverride(ovr: number | undefined);
    // (undocumented)
    dispose(): void;
    // (undocumented)
    protected drawOverlayDecorations(): void;
    // (undocumented)
    protected _endPaint(): void;
    // (undocumented)
    get isDisposed(): boolean;
    // (undocumented)
    onResized(): void;
    // (undocumented)
    pickOverlayDecoration(pt: XAndY): CanvasDecoration | undefined;
    // (undocumented)
    readImageToCanvas(): HTMLCanvasElement;
    // (undocumented)
    setRenderToScreen(toScreen: boolean): HTMLCanvasElement | undefined;
    // (undocumented)
    setViewRect(_rect: ViewRect, _temporary: boolean): void;
    // (undocumented)
    updateViewRect(): boolean;
    // (undocumented)
    get viewRect(): ViewRect;
    }

// @beta
export function openImageDataUrlInNewWindow(url: string, title?: string): void;

// @public
export class OrthographicViewState extends SpatialViewState {
    constructor(props: SpatialViewDefinitionProps, iModel: IModelConnection, categories: CategorySelectorState, displayStyle: DisplayStyle3dState, modelSelector: ModelSelectorState);
    // @internal (undocumented)
    static get className(): string;
    // (undocumented)
    supportsCamera(): boolean;
}

// @public
export enum OutputMessageAlert {
    // (undocumented)
    Balloon = 2,
    // (undocumented)
    Dialog = 1,
    // (undocumented)
    None = 0
}

// @public
export enum OutputMessagePriority {
    // (undocumented)
    Debug = 13,
    // (undocumented)
    Error = 10,
    // (undocumented)
    Fatal = 17,
    // (undocumented)
    Info = 12,
    // (undocumented)
    None = 0,
    // (undocumented)
    Warning = 11
}

// @public
export enum OutputMessageType {
    Alert = 4,
    // (undocumented)
    InputField = 3,
    // (undocumented)
    Pointer = 1,
    // (undocumented)
    Sticky = 2,
    Toast = 0
}

// @public
export class PanViewTool extends ViewManip {
    constructor(vp: ScreenViewport | undefined, oneShot?: boolean, isDraggingRequired?: boolean);
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    onReinitialize(): void;
    // (undocumented)
    static toolId: string;
}

// @beta
export interface ParseResults {
    // (undocumented)
    parseError?: string;
    // (undocumented)
    value?: string | number | boolean | {} | string[] | Date | [] | undefined;
}

// @internal (undocumented)
export class PerformanceMetrics {
    constructor(gatherGlFinish?: boolean, gatherCurPerformanceMetrics?: boolean, gpuResults?: GLTimerResultCallback);
    // (undocumented)
    beginFrame(sceneTime?: number): void;
    // (undocumented)
    beginOperation(operationName: string): void;
    // (undocumented)
    completeFrameTimings(fbo: FrameBuffer): void;
    // (undocumented)
    curSpfTimeIndex: number;
    // (undocumented)
    endFrame(): void;
    // (undocumented)
    endOperation(): void;
    // (undocumented)
    fpsTimer: StopWatch;
    // (undocumented)
    fpsTimerStart: number;
    // (undocumented)
    frameTimings: Map<string, number>;
    // (undocumented)
    gatherCurPerformanceMetrics: boolean;
    // (undocumented)
    gatherGlFinish: boolean;
    // (undocumented)
    spfSum: number;
    // (undocumented)
    spfTimes: number[];
    }

// @beta
export namespace PerModelCategoryVisibility {
    export enum Override {
        Hide = 2,
        None = 0,
        Show = 1
    }
    export interface Overrides {
        clearOverrides(modelIds?: Id64Arg): void;
        forEachOverride(func: (modelId: Id64String, categoryId: Id64String, visible: boolean) => boolean): boolean;
        getOverride(modelId: Id64String, categoryId: Id64String): Override;
        setOverride(modelIds: Id64Arg, categoryIds: Id64Arg, override: Override): void;
    }
}

// @public
export class PhysicalModelState extends SpatialModelState {
    // @internal (undocumented)
    static get className(): string;
}

// @internal
export interface PingTestResult {
    avg: number | undefined;
    max: number | undefined;
    min: number | undefined;
}

// @beta
export namespace Pixel {
    export interface Buffer {
        getPixel(x: number, y: number): Data;
    }
    export class Data {
        // @internal
        constructor(feature?: Feature, distanceFraction?: number, type?: GeometryType, planarity?: Planarity, featureTable?: PackedFeatureTable, iModel?: IModelConnection, tileId?: string);
        // (undocumented)
        readonly distanceFraction: number;
        // (undocumented)
        get elementId(): Id64String | undefined;
        // (undocumented)
        readonly feature?: Feature;
        // @internal (undocumented)
        readonly featureTable?: PackedFeatureTable;
        // (undocumented)
        get geometryClass(): GeometryClass | undefined;
        // @internal (undocumented)
        readonly iModel?: IModelConnection;
        // @internal (undocumented)
        get isClassifier(): boolean;
        // (undocumented)
        readonly planarity: Planarity;
        // (undocumented)
        get subCategoryId(): Id64String | undefined;
        // @internal (undocumented)
        readonly tileId?: string;
        // (undocumented)
        readonly type: GeometryType;
    }
    export const enum GeometryType {
        Edge = 4,
        Linear = 3,
        None = 1,
        Silhouette = 5,
        Surface = 2,
        Unknown = 0
    }
    export const enum Planarity {
        None = 1,
        NonPlanar = 3,
        Planar = 2,
        Unknown = 0
    }
    export type Receiver = (pixels: Buffer | undefined) => void;
    export const enum Selector {
        All = 5,
        Feature = 1,
        GeometryAndDistance = 4,
        // (undocumented)
        None = 0
    }
}

// @internal (undocumented)
export type PlanarClassifierMap = Map<Id64String, RenderPlanarClassifier>;

// @beta
export abstract class Plugin {
    constructor(name: string);
    get i18n(): I18N;
    // @internal (undocumented)
    get loader(): PluginLoader | undefined;
    set loader(loader: PluginLoader | undefined);
    // (undocumented)
    name: string;
    abstract onExecute(_args: string[]): void;
    onLoad(_args: string[]): void;
    reportReload(): boolean;
    resolveResourceUrl(relativeUrl: string): string;
    setI18n(defaultNamespace?: string, options?: I18NOptions): void;
}

// @beta
export class PluginAdmin {
    constructor();
    // @internal (undocumented)
    addPendingPlugin(pluginRootName: string, pendingPlugin: PendingPlugin): void;
    addSavedPlugins(requestContext: AuthorizedClientRequestContext, pluginName: string, args: string[] | undefined, allUsers: boolean, settingName: string): Promise<void>;
    // @internal (undocumented)
    static detailsFromPluginLoadResults(pluginName: string, results: PluginLoadResults, reportSuccess: boolean): {
        detailHTML: HTMLElement | undefined;
        detailStrings: string[] | undefined;
    };
    // @internal (undocumented)
    getRegisteredPlugin(pluginName: string): Promise<PluginLoadResults> | undefined;
    // @internal (undocumented)
    getTarFileName(pluginRootName: string): string;
    loadPlugin(pluginRoot: string, args?: string[]): Promise<PluginLoadResults>;
    // @deprecated
    static loadPlugin(pluginSpec: string, args?: string[]): Promise<PluginLoadResults>;
    // @internal
    loadSavedPlugins(requestContext: AuthorizedClientRequestContext, settingName: string, userSettings?: boolean, appSettings?: boolean, configuration?: boolean): Promise<LoadSavedPluginsResult>;
    // @internal (undocumented)
    loadViewStartupPlugins(): Promise<void>;
    // (undocumented)
    onInitialized(): void;
    register(plugin: Plugin): string[] | undefined;
    // @deprecated
    static register(plugin: Plugin): void;
    removeSavedPlugins(requestContext: AuthorizedClientRequestContext, pluginName: string, allUsers: boolean, settingName: string): Promise<void>;
    }

// @beta
export type PluginLoadResults = Plugin | undefined | string | string[];

// @beta
export namespace Primitives {
    // (undocumented)
    export type Boolean = boolean | string | {} | [];
    // (undocumented)
    export interface Composite {
        // (undocumented)
        parts: CompositePart[];
        // (undocumented)
        separator: string;
    }
    // (undocumented)
    export interface CompositePart {
        // (undocumented)
        displayValue: string;
        // (undocumented)
        rawValue: Value;
        // (undocumented)
        typeName: string;
    }
    // (undocumented)
    export type Enum = number | string;
    // (undocumented)
    export type Float = number | string;
    // (undocumented)
    export type Hexadecimal = Id64String;
    // (undocumented)
    export type Int = number | string;
    // (undocumented)
    export type Numeric = Float | Int;
    // (undocumented)
    export type Point = Point2d | Point3d;
    // (undocumented)
    export type Point2d = string[] | number[] | {
        x: number;
        y: number;
    };
    // (undocumented)
    export type Point3d = string[] | number[] | {
        x: number;
        y: number;
        z: number;
    };
    // (undocumented)
    export type ShortDate = string | Date;
    // (undocumented)
    export type String = string;
    // (undocumented)
    export type Text = string;
    // (undocumented)
    export type Value = Text | String | ShortDate | Boolean | Numeric | Enum | Point | Composite;
}

// @public
export abstract class PrimitiveTool extends InteractiveTool {
    autoLockTarget(): void;
    // (undocumented)
    exitTool(): void;
    getPrompt(): string;
    get iModel(): IModelConnection;
    isCompatibleViewport(vp: Viewport | undefined, isSelectedViewChange: boolean): boolean;
    isValidLocation(ev: BeButtonEvent, isButtonEvent: boolean): boolean;
    onRedoPreviousStep(): Promise<boolean>;
    onReinitialize(): void;
    abstract onRestartTool(): void;
    onSelectedViewportChanged(_previous: Viewport | undefined, current: Viewport | undefined): void;
    onUndoPreviousStep(): Promise<boolean>;
    // @internal (undocumented)
    redoPreviousStep(): Promise<boolean>;
    requireWriteableTarget(): boolean;
    run(..._args: any[]): boolean;
    saveChanges(): Promise<void>;
    // (undocumented)
    targetIsLocked: boolean;
    // (undocumented)
    targetModelId?: string;
    // (undocumented)
    targetView?: Viewport;
    // @internal (undocumented)
    undoPreviousStep(): Promise<boolean>;
}

// @beta
export interface PrimitiveValue extends BasePropertyValue {
    // (undocumented)
    displayValue?: string;
    // (undocumented)
    value?: Primitives.Value;
    // (undocumented)
    valueFormat: PropertyValueFormat.Primitive;
}

// @alpha
export const enum PrimitiveVisibility {
    All = 0,
    Instanced = 1,
    Uninstanced = 2
}

// @beta
export interface PropertyDescription {
    dataController?: string;
    // (undocumented)
    displayLabel: string;
    // (undocumented)
    editor?: PropertyEditorInfo;
    // (undocumented)
    enum?: EnumerationChoicesInfo;
    // (undocumented)
    name: string;
    // @alpha
    quantityType?: QuantityType | string;
    // (undocumented)
    typename: string;
}

// @beta
export interface PropertyEditorInfo {
    // (undocumented)
    name?: string;
    // (undocumented)
    params?: PropertyEditorParams[];
}

// @beta
export type PropertyEditorParams = BasePropertyEditorParams;

// @beta
export enum PropertyEditorParamTypes {
    // (undocumented)
    ButtonGroupData = "ButtonGroupData",
    // (undocumented)
    CheckBoxIcons = "CheckBoxIcons",
    // (undocumented)
    ColorData = "ColorData",
    // (undocumented)
    CustomFormattedNumber = "CustomFormattedNumber",
    // (undocumented)
    Icon = "Icon",
    // (undocumented)
    IconListData = "IconListData",
    // (undocumented)
    InputEditorSize = "InputEditorSize",
    // (undocumented)
    JSON = "JSON",
    // (undocumented)
    MultilineText = "MultilineText",
    // (undocumented)
    Range = "Range",
    // (undocumented)
    Slider = "Slider",
    // (undocumented)
    SuppressEditorLabel = "SuppressEditorLabel",
    // (undocumented)
    SuppressUnitLabel = "SuppressUnitLabel"
}

// @beta
export class PropertyRecord {
    constructor(value: PropertyValue, property: PropertyDescription);
    // (undocumented)
    autoExpand?: boolean;
    copyWithNewValue(newValue: PropertyValue): PropertyRecord;
    // (undocumented)
    description?: string;
    // (undocumented)
    extendedData?: {
        [key: string]: any;
    };
    // (undocumented)
    isDisabled?: boolean;
    // (undocumented)
    isMerged?: boolean;
    // (undocumented)
    isReadonly?: boolean;
    links?: LinkElementsInfo;
    // (undocumented)
    readonly property: PropertyDescription;
    // (undocumented)
    readonly value: PropertyValue;
}

// @beta
export type PropertyValue = PrimitiveValue | StructValue | ArrayValue;

// @beta
export enum PropertyValueFormat {
    // (undocumented)
    Array = 1,
    // (undocumented)
    Primitive = 0,
    // (undocumented)
    Struct = 2
}

// @internal (undocumented)
export class QuadId {
    constructor(level: number, column: number, row: number);
    // (undocumented)
    column: number;
    // (undocumented)
    get contentId(): string;
    // (undocumented)
    static createFromContentId(stringId: string): QuadId;
    // (undocumented)
    getLatLongRange(mapTilingScheme: MapTilingScheme): Range2d;
    // (undocumented)
    get isValid(): boolean;
    // (undocumented)
    level: number;
    // (undocumented)
    row: number;
    }

// @alpha
export class QuantityFormatter implements UnitsProvider {
    // (undocumented)
    protected _activeSystemIsImperial: boolean;
    findFormatterSpecByQuantityType(type: QuantityType, imperial?: boolean): FormatterSpec | undefined;
    protected findKoqFormatterSpec(koq: string, useImperial: boolean): FormatterSpec | undefined;
    findParserSpecByQuantityType(type: QuantityType, imperial?: boolean): ParserSpec | undefined;
    findUnit(unitLabel: string, unitFamily?: string): Promise<UnitProps>;
    findUnitByName(unitName: string): Promise<UnitProps>;
    // (undocumented)
    protected findUnitDefinition(name: string): UnitDefinition | undefined;
    formatQuantity(magnitude: number, formatSpec: FormatterSpec): string;
    // (undocumented)
    protected _formatSpecsByKoq: Map<string, FormatterSpec[]>;
    getConversion(fromUnit: UnitProps, toUnit: UnitProps): Promise<UnitConversion>;
    // (undocumented)
    protected getFormatByQuantityType(type: QuantityType, imperial: boolean): Promise<Format>;
    getFormatterSpecByQuantityType(type: QuantityType, imperial?: boolean): Promise<FormatterSpec>;
    protected getKoqFormatterSpec(koq: string, useImperial: boolean): Promise<FormatterSpec | undefined>;
    protected getKoqFormatterSpecsAsync(koq: string, useImperial: boolean): Promise<FormatterSpec[] | undefined>;
    getParserSpecByQuantityType(type: QuantityType, imperial?: boolean): Promise<ParserSpec>;
    protected getUnitByQuantityType(type: QuantityType): Promise<UnitProps>;
    getUnitsByFamily(unitFamily: string): Promise<UnitProps[]>;
    // (undocumented)
    protected _imperialFormatsByType: Map<QuantityType, Format>;
    // (undocumented)
    protected _imperialFormatSpecsByType: Map<QuantityType, FormatterSpec>;
    // (undocumented)
    protected _imperialParserSpecsByType: Map<QuantityType, ParserSpec>;
    loadFormatAndParsingMaps(useImperial: boolean): Promise<void>;
    protected loadFormatSpecsForQuantityTypes(useImperial: boolean): Promise<void>;
    protected loadKoqFormatSpecs(koq: string): Promise<void>;
    protected loadParsingSpecsForQuantityTypes(useImperial: boolean): Promise<void>;
    // (undocumented)
    protected loadStdFormat(type: QuantityType, imperial: boolean): Promise<Format>;
    // (undocumented)
    protected _metricFormatsByType: Map<QuantityType, Format>;
    // (undocumented)
    protected _metricFormatSpecsByType: Map<QuantityType, FormatterSpec>;
    // (undocumented)
    protected _metricUnitParserSpecsByType: Map<QuantityType, ParserSpec>;
    // (undocumented)
    onInitialized(): void;
    parseIntoQuantityValue(inString: string, parserSpec: ParserSpec): ParseResult;
    get useImperialFormats(): boolean;
    set useImperialFormats(useImperial: boolean);
}

// @beta
export enum QuantityType {
    // (undocumented)
    Angle = 2,
    // (undocumented)
    Area = 3,
    // (undocumented)
    Coordinate = 6,
    // (undocumented)
    LatLong = 5,
    // (undocumented)
    Length = 1,
    // (undocumented)
    LengthEngineering = 9,
    // (undocumented)
    LengthSurvey = 8,
    // (undocumented)
    Stationing = 7,
    // (undocumented)
    Volume = 4
}

// @alpha
export interface RangeEditorParams extends BasePropertyEditorParams {
    maximum?: number;
    minimum?: number;
    // (undocumented)
    type: PropertyEditorParamTypes.Range;
}

// @public @deprecated
export enum RelativePosition {
    // (undocumented)
    Bottom = 3,
    // (undocumented)
    BottomLeft = 6,
    // (undocumented)
    BottomRight = 7,
    // (undocumented)
    Left = 0,
    // (undocumented)
    Right = 2,
    // (undocumented)
    Top = 1,
    // (undocumented)
    TopLeft = 4,
    // (undocumented)
    TopRight = 5
}

// @beta
export abstract class RenderClipVolume implements IDisposable {
    protected constructor(clipVector: ClipVector);
    readonly clipVector: ClipVector;
    // @internal (undocumented)
    abstract collectStatistics(stats: RenderMemory.Statistics): void;
    abstract dispose(): void;
    abstract get type(): ClippingType;
}

// @public
export class RenderContext {
    constructor(vp: Viewport, frustum?: Frustum);
    createBranch(branch: GraphicBranch, location: Transform): RenderGraphic;
    // @internal (undocumented)
    createGraphicBranch(branch: GraphicBranch, location: Transform, opts?: GraphicBranchOptions): RenderGraphic;
    // @internal (undocumented)
    protected _createGraphicBuilder(type: GraphicType, transform?: Transform, id?: Id64String): GraphicBuilder;
    createSceneGraphicBuilder(transform?: Transform): GraphicBuilder;
    readonly frustum: Frustum;
    readonly frustumPlanes: FrustumPlanes;
    getPixelSizeAtPoint(inPoint?: Point3d): number;
    // @internal (undocumented)
    get target(): RenderTarget;
    readonly viewFlags: ViewFlags;
    readonly viewport: Viewport;
}

// @internal (undocumented)
export const enum RenderDiagnostics {
    All = 6,
    DebugOutput = 2,
    None = 0,
    WebGL = 4
}

// @public
export abstract class RenderGraphic implements IDisposable {
    // @internal (undocumented)
    abstract collectStatistics(stats: RenderMemory.Statistics): void;
    // (undocumented)
    abstract dispose(): void;
}

// @public
export abstract class RenderGraphicOwner extends RenderGraphic {
    // @internal (undocumented)
    collectStatistics(stats: RenderMemory.Statistics): void;
    dispose(): void;
    disposeGraphic(): void;
    abstract get graphic(): RenderGraphic;
}

// @internal
export namespace RenderMemory {
    export class Buffers extends Consumers {
        constructor();
        // (undocumented)
        addBuffer(type: BufferType, numBytes: number): void;
        // (undocumented)
        clear(): void;
        // (undocumented)
        readonly consumers: Consumers[];
        // (undocumented)
        get instances(): Consumers;
        // (undocumented)
        get pointClouds(): Consumers;
        // (undocumented)
        get pointStrings(): Consumers;
        // (undocumented)
        get polylineEdges(): Consumers;
        // (undocumented)
        get polylines(): Consumers;
        // (undocumented)
        get silhouetteEdges(): Consumers;
        // (undocumented)
        get surfaces(): Consumers;
        // (undocumented)
        get visibleEdges(): Consumers;
    }
    // (undocumented)
    export const enum BufferType {
        // (undocumented)
        COUNT = 8,
        // (undocumented)
        Instances = 7,
        // (undocumented)
        PointClouds = 6,
        // (undocumented)
        PointStrings = 5,
        // (undocumented)
        PolylineEdges = 3,
        // (undocumented)
        Polylines = 4,
        // (undocumented)
        SilhouetteEdges = 2,
        // (undocumented)
        Surfaces = 0,
        // (undocumented)
        VisibleEdges = 1
    }
    // (undocumented)
    export interface Consumer {
        // (undocumented)
        collectStatistics(stats: Statistics): void;
    }
    export class Consumers {
        // (undocumented)
        addConsumer(numBytes: number): void;
        // (undocumented)
        clear(): void;
        // (undocumented)
        count: number;
        // (undocumented)
        maxBytes: number;
        // (undocumented)
        totalBytes: number;
    }
    // (undocumented)
    export const enum ConsumerType {
        // (undocumented)
        ClipVolumes = 4,
        // (undocumented)
        COUNT = 8,
        // (undocumented)
        FeatureOverrides = 3,
        // (undocumented)
        FeatureTables = 2,
        // (undocumented)
        PlanarClassifiers = 5,
        // (undocumented)
        ShadowMaps = 6,
        // (undocumented)
        TextureAttachments = 7,
        // (undocumented)
        Textures = 0,
        // (undocumented)
        VertexTables = 1
    }
    // (undocumented)
    export class Statistics {
        constructor();
        // (undocumented)
        addBuffer(type: BufferType, numBytes: number): void;
        // (undocumented)
        addClipVolume(numBytes: number): void;
        // (undocumented)
        addConsumer(type: ConsumerType, numBytes: number): void;
        // (undocumented)
        addFeatureOverrides(numBytes: number): void;
        // (undocumented)
        addFeatureTable(numBytes: number): void;
        // (undocumented)
        addInstances(numBytes: number): void;
        // (undocumented)
        addPlanarClassifier(numBytes: number): void;
        // (undocumented)
        addPointCloud(numBytes: number): void;
        // (undocumented)
        addPointString(numBytes: number): void;
        // (undocumented)
        addPolyline(numBytes: number): void;
        // (undocumented)
        addPolylineEdges(numBytes: number): void;
        // (undocumented)
        addShadowMap(numBytes: number): void;
        // (undocumented)
        addSilhouetteEdges(numBytes: number): void;
        // (undocumented)
        addSurface(numBytes: number): void;
        // (undocumented)
        addTexture(numBytes: number): void;
        // (undocumented)
        addTextureAttachment(numBytes: number): void;
        // (undocumented)
        addVertexTable(numBytes: number): void;
        // (undocumented)
        addVisibleEdges(numBytes: number): void;
        // (undocumented)
        readonly buffers: Buffers;
        // (undocumented)
        clear(): void;
        // (undocumented)
        get clipVolumes(): Consumers;
        // (undocumented)
        readonly consumers: Consumers[];
        // (undocumented)
        get featureOverrides(): Consumers;
        // (undocumented)
        get featureTables(): Consumers;
        // (undocumented)
        get planarClassifiers(): Consumers;
        // (undocumented)
        get shadowMaps(): Consumers;
        // (undocumented)
        get textureAttachments(): Consumers;
        // (undocumented)
        get textures(): Consumers;
        // (undocumented)
        get totalBytes(): number;
        // (undocumented)
        get vertexTables(): Consumers;
    }
}

// @internal
export class RenderPlan {
    // (undocumented)
    readonly activeVolume?: ClipVector;
    // (undocumented)
    readonly analysisStyle?: AnalysisStyle;
    // (undocumented)
    readonly analysisTexture?: RenderTexture;
    // (undocumented)
    readonly ao?: AmbientOcclusion.Settings;
    // (undocumented)
    readonly bgColor: ColorDef;
    // (undocumented)
    readonly classificationTextures?: Map<Id64String, RenderTexture>;
    // (undocumented)
    static createEmpty(): RenderPlan;
    // (undocumented)
    static createFromViewport(vp: Viewport): RenderPlan;
    // (undocumented)
    readonly emphasisSettings: Hilite.Settings;
    // (undocumented)
    readonly fraction: number;
    // (undocumented)
    readonly frustum: Frustum;
    // (undocumented)
    readonly hiliteSettings: Hilite.Settings;
    // (undocumented)
    readonly hline?: HiddenLine.Settings;
    // (undocumented)
    readonly is3d: boolean;
    // (undocumented)
    readonly isFadeOutActive: boolean;
    // (undocumented)
    readonly monoColor: ColorDef;
    // (undocumented)
    readonly viewFlags: ViewFlags;
}

// @internal
export abstract class RenderPlanarClassifier implements IDisposable {
    // (undocumented)
    abstract collectGraphics(context: SceneContext, classifiedTree: TileTree, tileTree: TileTree): void;
    // (undocumented)
    abstract dispose(): void;
}

// @internal (undocumented)
export namespace RenderScheduleState {
    // (undocumented)
    export class ColorEntry extends TimelineEntry implements RenderSchedule.ColorEntryProps {
        constructor(props: RenderSchedule.ColorEntryProps);
        // (undocumented)
        value: {
            red: number;
            green: number;
            blue: number;
        };
    }
    // (undocumented)
    export class CuttingPlaneEntry extends TimelineEntry implements RenderSchedule.CuttingPlaneEntryProps {
        constructor(props: RenderSchedule.CuttingPlaneEntryProps);
        // (undocumented)
        value: RenderSchedule.CuttingPlaneProps;
    }
    // (undocumented)
    export class ElementTimeline extends Timeline implements RenderSchedule.ElementTimelineProps {
        // (undocumented)
        batchId: number;
        // (undocumented)
        get containsAnimation(): boolean;
        // (undocumented)
        get containsFeatureOverrides(): boolean;
        // (undocumented)
        elementIds: Id64String[];
        // (undocumented)
        static fromJSON(json?: RenderSchedule.ElementTimelineProps): ElementTimeline;
        // (undocumented)
        getSymbologyOverrides(overrides: FeatureSymbology.Overrides, time: number, interval: Interval, batchId: number, elementIds: Id64String[]): void;
        // (undocumented)
        get isValid(): boolean;
    }
    // (undocumented)
    export class Interval {
        constructor(index0?: number, index1?: number, fraction?: number);
        // (undocumented)
        fraction: number;
        // (undocumented)
        index0: number;
        // (undocumented)
        index1: number;
        // (undocumented)
        init(index0: number, index1: number, fraction: number): void;
    }
    // (undocumented)
    export class ModelTimeline extends Timeline implements RenderSchedule.ModelTimelineProps {
        // (undocumented)
        containsElementAnimation: boolean;
        // (undocumented)
        containsFeatureOverrides: boolean;
        // (undocumented)
        containsModelAnimation: boolean;
        // (undocumented)
        get duration(): Range1d;
        // (undocumented)
        elementTimelines: ElementTimeline[];
        // (undocumented)
        static fromJSON(json?: RenderSchedule.ModelTimelineProps, displayStyle?: DisplayStyleState): ModelTimeline;
        // (undocumented)
        getAnimationBranches(branches: AnimationBranchStates, scheduleTime: number): void;
        // (undocumented)
        getSymbologyOverrides(overrides: FeatureSymbology.Overrides, time: number): void;
        // (undocumented)
        modelId: Id64String;
    }
    // (undocumented)
    export class Script {
        constructor(displayStyleId: Id64String, iModel: IModelConnection);
        // (undocumented)
        containsElementAnimation: boolean;
        // (undocumented)
        get containsFeatureOverrides(): boolean;
        // (undocumented)
        containsModelAnimation: boolean;
        // (undocumented)
        displayStyleId: Id64String;
        // (undocumented)
        get duration(): Range1d;
        // (undocumented)
        static fromJSON(displayStyleId: Id64String, iModel: IModelConnection, modelTimelines: RenderSchedule.ModelTimelineProps[]): Script | undefined;
        // (undocumented)
        getAnimationBranches(scheduleTime: number): AnimationBranchStates | undefined;
        // (undocumented)
        getModelAnimationId(modelId: Id64String): Id64String | undefined;
        // (undocumented)
        getSymbologyOverrides(overrides: FeatureSymbology.Overrides, time: number): void;
        // (undocumented)
        iModel: IModelConnection;
        // (undocumented)
        modelTimelines: ModelTimeline[];
    }
    // (undocumented)
    export class Timeline implements RenderSchedule.TimelineProps {
        // (undocumented)
        colorTimeline?: ColorEntry[];
        // (undocumented)
        currentClip?: RenderClipVolume;
        // (undocumented)
        cuttingPlaneTimeline?: CuttingPlaneEntry[];
        // (undocumented)
        get duration(): Range1d;
        // (undocumented)
        extractTimelinesFromJSON(json: RenderSchedule.TimelineProps): void;
        // (undocumented)
        static findTimelineInterval(interval: Interval, time: number, timeline?: TimelineEntry[]): boolean;
        // (undocumented)
        getAnimationClip(time: number, interval: Interval): RenderClipVolume | undefined;
        // (undocumented)
        getAnimationTransform(time: number, interval: Interval): Transform | undefined;
        // (undocumented)
        getColorOverride(time: number, interval: Interval): RgbColor | undefined;
        // (undocumented)
        getVisibilityOverride(time: number, interval: Interval): number;
        // (undocumented)
        transformTimeline?: TransformEntry[];
        // (undocumented)
        visibilityTimeline?: VisibilityEntry[];
    }
    // (undocumented)
    export class TimelineEntry implements RenderSchedule.TimelineEntryProps {
        constructor(props: RenderSchedule.TimelineEntryProps);
        // (undocumented)
        interpolation: number;
        // (undocumented)
        time: number;
    }
    // (undocumented)
    export class TransformEntry extends TimelineEntry implements RenderSchedule.TransformEntryProps {
        constructor(props: RenderSchedule.TransformEntryProps);
        // (undocumented)
        value: RenderSchedule.TransformProps;
    }
    // (undocumented)
    export class VisibilityEntry extends TimelineEntry implements RenderSchedule.VisibilityEntryProps {
        constructor(props: RenderSchedule.VisibilityEntryProps);
        // (undocumented)
        value: number;
    }
    {};
}

// @public
export abstract class RenderSystem implements IDisposable {
    // @internal
    protected constructor(options?: RenderSystem.Options);
    // @internal (undocumented)
    collectStatistics(_stats: RenderMemory.Statistics): void;
    // @internal (undocumented)
    createBackgroundMapDrape(_drapedTree: TileTree, _mapTree: BackgroundMapTileTreeReference): RenderTextureDrape | undefined;
    // @internal
    abstract createBatch(graphic: RenderGraphic, features: PackedFeatureTable, range: ElementAlignedBox3d, tileId?: string): RenderGraphic;
    createBranch(branch: GraphicBranch, transform: Transform): RenderGraphic;
    // @internal (undocumented)
    createClipVolume(_clipVector: ClipVector): RenderClipVolume | undefined;
    // @internal (undocumented)
    abstract createGraphicBranch(branch: GraphicBranch, transform: Transform, options?: GraphicBranchOptions): RenderGraphic;
    abstract createGraphicBuilder(placement: Transform, type: GraphicType, viewport: Viewport, pickableId?: Id64String): GraphicBuilder;
    abstract createGraphicList(primitives: RenderGraphic[]): RenderGraphic;
    createGraphicOwner(ownedGraphic: RenderGraphic): RenderGraphicOwner;
    // @internal (undocumented)
    createIndexedPolylines(args: PolylineArgs, instances?: InstancedGraphicParams | Point3d): RenderGraphic | undefined;
    createMaterial(_params: RenderMaterial.Params, _imodel: IModelConnection): RenderMaterial | undefined;
    // @internal (undocumented)
    createMesh(_params: MeshParams, _instances?: InstancedGraphicParams | Point3d): RenderGraphic | undefined;
    // @internal (undocumented)
    abstract createOffscreenTarget(rect: ViewRect): RenderTarget;
    // @internal (undocumented)
    createPointCloud(_args: PointCloudArgs, _imodel: IModelConnection): RenderGraphic | undefined;
    // @internal (undocumented)
    createPointString(_params: PointStringParams, _instances?: InstancedGraphicParams | Point3d): RenderGraphic | undefined;
    // @internal (undocumented)
    createPolyline(_params: PolylineParams, _instances?: InstancedGraphicParams | Point3d): RenderGraphic | undefined;
    // @internal (undocumented)
    createSheetTile(_tile: RenderTexture, _polyfaces: IndexedPolyface[], _tileColor: ColorDef): GraphicList;
    // @internal (undocumented)
    createSheetTilePolyfaces(_corners: Point3d[], _clip?: ClipVector): IndexedPolyface[];
    createSkyBox(_params: SkyBox.CreateParams): RenderGraphic | undefined;
    // @internal (undocumented)
    abstract createTarget(canvas: HTMLCanvasElement): RenderTarget;
    // @internal
    createTextureFromCubeImages(_posX: HTMLImageElement, _negX: HTMLImageElement, _posY: HTMLImageElement, _negY: HTMLImageElement, _posZ: HTMLImageElement, _negZ: HTMLImageElement, _imodel: IModelConnection, _params: RenderTexture.Params): RenderTexture | undefined;
    createTextureFromImage(_image: HTMLImageElement, _hasAlpha: boolean, _imodel: IModelConnection | undefined, _params: RenderTexture.Params): RenderTexture | undefined;
    createTextureFromImageBuffer(_image: ImageBuffer, _imodel: IModelConnection, _params: RenderTexture.Params): RenderTexture | undefined;
    createTextureFromImageSource(source: ImageSource, imodel: IModelConnection | undefined, params: RenderTexture.Params): Promise<RenderTexture | undefined>;
    // @internal (undocumented)
    createTile(tileTexture: RenderTexture, corners: Point3d[], featureIndex?: number): RenderGraphic | undefined;
    // @internal (undocumented)
    createTriMesh(args: MeshArgs, instances?: InstancedGraphicParams | Point3d): RenderGraphic | undefined;
    // @beta
    get debugControl(): RenderSystemDebugControl | undefined;
    // @internal (undocumented)
    abstract dispose(): void;
    // @internal (undocumented)
    enableDiagnostics(_enable: RenderDiagnostics): void;
    findMaterial(_key: string, _imodel: IModelConnection): RenderMaterial | undefined;
    findTexture(_key: string, _imodel: IModelConnection): RenderTexture | undefined;
    // @beta
    getGradientTexture(_symb: Gradient.Symb, _imodel: IModelConnection): RenderTexture | undefined;
    // @internal (undocumented)
    abstract get isValid(): boolean;
    // @internal
    loadTexture(id: Id64String, iModel: IModelConnection): Promise<RenderTexture | undefined>;
    // @internal
    loadTextureImage(id: Id64String, iModel: IModelConnection): Promise<TextureImage | undefined>;
    // @internal (undocumented)
    get maxTextureSize(): number;
    // @internal (undocumented)
    onInitialized(): void;
    // @internal
    readonly options: RenderSystem.Options;
    // @internal (undocumented)
    get supportsInstancing(): boolean;
    // @internal (undocumented)
    get supportsLogZBuffer(): boolean;
}

// @public
export namespace RenderSystem {
    // @beta
    export interface Options {
        // @internal @deprecated (undocumented)
        directScreenRendering?: boolean;
        // @internal
        disabledExtensions?: WebGLExtensionName[];
        displaySolarShadows?: boolean;
        dpiAwareViewports?: boolean;
        // @internal
        filterMapDrapeTextures?: boolean;
        // @internal
        filterMapTextures?: boolean;
        logarithmicDepthBuffer?: boolean;
        // @internal
        preserveShaderSourceCode?: boolean;
    }
}

// @beta
export interface RenderSystemDebugControl {
    // @internal
    compileAllShaders(): boolean;
    drawSurfacesAsWiremesh: boolean;
    // @internal
    readonly isGLTimerSupported: boolean;
    loseContext(): boolean;
    // @internal
    resultsCallback?: GLTimerResultCallback;
}

// @internal
export abstract class RenderTarget implements IDisposable, RenderMemory.Consumer {
    // (undocumented)
    get animationBranches(): AnimationBranchStates | undefined;
    set animationBranches(_transforms: AnimationBranchStates | undefined);
    // (undocumented)
    abstract get animationFraction(): number;
    abstract set animationFraction(fraction: number);
    // (undocumented)
    changeActiveVolumeClassifierProps(_props?: SpatialClassificationProps.Classifier, _modelId?: Id64String): void;
    // (undocumented)
    abstract changeBackgroundMap(_graphics: GraphicList): void;
    // (undocumented)
    abstract changeDecorations(decorations: Decorations): void;
    // (undocumented)
    abstract changeDynamics(dynamics?: GraphicList): void;
    // (undocumented)
    abstract changeOverlayGraphics(_scene: GraphicList): void;
    // (undocumented)
    changePlanarClassifiers(_classifiers?: PlanarClassifierMap): void;
    // (undocumented)
    abstract changeRenderPlan(plan: RenderPlan): void;
    // (undocumented)
    abstract changeScene(scene: GraphicList): void;
    // (undocumented)
    changeTextureDrapes(_drapes: TextureDrapeMap | undefined): void;
    // (undocumented)
    collectStatistics(_stats: RenderMemory.Statistics): void;
    // (undocumented)
    createGraphicBuilder(type: GraphicType, viewport: Viewport, placement?: Transform, pickableId?: Id64String): GraphicBuilder;
    // (undocumented)
    createPlanarClassifier(_properties: SpatialClassificationProps.Classifier): RenderPlanarClassifier | undefined;
    // (undocumented)
    cssPixelsToDevicePixels(cssPixels: number): number;
    // (undocumented)
    get debugControl(): RenderTargetDebugControl | undefined;
    static depthFromDisplayPriority(priority: number): number;
    // (undocumented)
    get devicePixelRatio(): number;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    abstract drawFrame(sceneMilSecElapsed?: number): void;
    // (undocumented)
    static get frustumDepth2d(): number;
    // (undocumented)
    getPlanarClassifier(_id: Id64String): RenderPlanarClassifier | undefined;
    // (undocumented)
    getTextureDrape(_id: Id64String): RenderTextureDrape | undefined;
    // (undocumented)
    static get maxDisplayPriority(): number;
    // (undocumented)
    static get minDisplayPriority(): number;
    // (undocumented)
    onResized(): void;
    // (undocumented)
    overrideFeatureSymbology(_ovr: FeatureSymbology.Overrides): void;
    // (undocumented)
    pickOverlayDecoration(_pt: XAndY): CanvasDecoration | undefined;
    readImage(_rect: ViewRect, _targetSize: Point2d, _flipVertically: boolean): ImageBuffer | undefined;
    // (undocumented)
    readImageToCanvas(): HTMLCanvasElement;
    abstract readPixels(rect: ViewRect, selector: Pixel.Selector, receiver: Pixel.Receiver, excludeNonLocatable: boolean): void;
    // (undocumented)
    abstract get renderSystem(): RenderSystem;
    // (undocumented)
    reset(): void;
    // (undocumented)
    setFlashed(_elementId: Id64String, _intensity: number): void;
    // (undocumented)
    setHiliteSet(_hilited: HiliteSet): void;
    setRenderToScreen(_toScreen: boolean): HTMLCanvasElement | undefined;
    // (undocumented)
    abstract setViewRect(_rect: ViewRect, _temporary: boolean): void;
    updateSolarShadows(_context: SceneContext | undefined): void;
    // (undocumented)
    abstract updateViewRect(): boolean;
    abstract get viewRect(): ViewRect;
    // (undocumented)
    abstract get wantInvertBlackBackground(): boolean;
}

// @beta
export interface RenderTargetDebugControl {
    // @internal
    devicePixelRatioOverride?: number;
    // @internal (undocumented)
    displayDrapeFrustum: boolean;
    drawForReadPixels: boolean;
    // @alpha (undocumented)
    primitiveVisibility: PrimitiveVisibility;
    // @internal (undocumented)
    readonly shadowFrustum: Frustum | undefined;
    useLogZ: boolean;
    // @internal (undocumented)
    vcSupportIntersectingVolumes: boolean;
}

// @internal
export abstract class RenderTextureDrape implements IDisposable {
    // (undocumented)
    abstract collectGraphics(context: SceneContext): void;
    // (undocumented)
    abstract collectStatistics(stats: RenderMemory.Statistics): void;
    // (undocumented)
    abstract dispose(): void;
}

// @public
export class RotateViewTool extends ViewManip {
    constructor(vp: ScreenViewport, oneShot?: boolean, isDraggingRequired?: boolean);
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    onReinitialize(): void;
    // (undocumented)
    static toolId: string;
}

// @alpha (undocumented)
export enum RotationMode {
    // (undocumented)
    ACS = 5,
    // (undocumented)
    Context = 6,
    // (undocumented)
    Front = 2,
    // (undocumented)
    Side = 3,
    // (undocumented)
    Top = 1,
    // (undocumented)
    View = 4
}

// @internal (undocumented)
export class RoundOff {
    // (undocumented)
    active: boolean;
    // (undocumented)
    units: Set<number>;
}

// @internal (undocumented)
export interface SavedClipCache {
    // (undocumented)
    clip?: ClipVector;
    // (undocumented)
    modified: boolean;
    // (undocumented)
    name?: string;
    // (undocumented)
    shared: boolean;
}

// @alpha (undocumented)
export interface SavedClipEntry {
    // (undocumented)
    id: GuidString;
    // (undocumented)
    name?: string;
    // (undocumented)
    shared: boolean;
}

// @internal (undocumented)
export interface SavedClipProps {
    // (undocumented)
    clip: ClipVector;
    // (undocumented)
    name?: string;
}

// @internal (undocumented)
export class SavedState {
    // (undocumented)
    auxRotationPlane: number;
    // (undocumented)
    readonly axes: ThreeAxes;
    // (undocumented)
    contextRotMode: number;
    // (undocumented)
    fixedOrg: boolean;
    // (undocumented)
    ignoreDataButton: boolean;
    // (undocumented)
    ignoreFlags: AccuDrawFlags;
    // (undocumented)
    mode: CompassMode;
    // (undocumented)
    readonly origin: Point3d;
    // (undocumented)
    rotationMode: RotationMode;
    // (undocumented)
    state: CurrentState;
}

// @internal
export class SceneContext extends RenderContext {
    constructor(vp: Viewport, frustum?: Frustum);
    // (undocumented)
    addBackgroundDrapedModel(drapedTree: TileTree): RenderTextureDrape | undefined;
    // (undocumented)
    addPlanarClassifier(props: SpatialClassificationProps.Classifier, tileTree: TileTree, classifiedTree: TileTree): RenderPlanarClassifier | undefined;
    // (undocumented)
    readonly backgroundGraphics: RenderGraphic[];
    // (undocumented)
    getActiveVolumeClassifierModelId(): Id64String | undefined;
    // (undocumented)
    getActiveVolumeClassifierProps(): SpatialClassificationProps.Classifier | undefined;
    // (undocumented)
    getPlanarClassifierForModel(modelId: Id64String): RenderPlanarClassifier | undefined;
    // (undocumented)
    getTextureDrapeForModel(modelId: Id64String): RenderTextureDrape | undefined;
    // (undocumented)
    readonly graphics: RenderGraphic[];
    // (undocumented)
    hasMissingTiles: boolean;
    // (undocumented)
    insertMissingTile(tile: Tile): void;
    // (undocumented)
    readonly missingTiles: Set<Tile>;
    // (undocumented)
    readonly modelClassifiers: Map<string, string>;
    // (undocumented)
    outputGraphic(graphic: RenderGraphic): void;
    // (undocumented)
    readonly overlayGraphics: RenderGraphic[];
    // (undocumented)
    readonly planarClassifiers: Map<string, RenderPlanarClassifier>;
    // (undocumented)
    requestMissingTiles(): void;
    // (undocumented)
    setActiveVolumeClassifierModelId(modelId: Id64String | undefined): void;
    // (undocumented)
    setActiveVolumeClassifierProps(properties: SpatialClassificationProps.Classifier | undefined): void;
    // (undocumented)
    readonly textureDrapes: Map<string, RenderTextureDrape>;
    // (undocumented)
    get viewingSpace(): ViewingSpace;
    // (undocumented)
    withGraphicTypeAndFrustum(type: TileTree.GraphicType, frustum: ViewingSpace | undefined, func: () => void): void;
    // (undocumented)
    withGraphicTypeAndPlane(type: TileTree.GraphicType, plane: Plane3dByOriginAndUnitNormal | undefined, func: () => void): void;
}

// @public
export class ScreenViewport extends Viewport {
    // @internal
    protected constructor(canvas: HTMLCanvasElement, parentDiv: HTMLDivElement, target: RenderTarget);
    // @internal (undocumented)
    protected addDecorations(decorations: Decorations): void;
    // @internal (undocumented)
    protected addLogo(): void;
    // @internal (undocumented)
    addNewDiv(className: string, overflowHidden: boolean, z: number): HTMLDivElement;
    // @internal (undocumented)
    animateFrustumChange(options?: ViewAnimationOptions): void;
    // @beta
    static animation: {
        time: {
            fast: BeDuration;
            normal: BeDuration;
            slow: BeDuration;
            wheel: BeDuration;
        };
        easing: (k: number) => number;
        zoomOut: {
            enable: boolean;
            interpolation: (v: any, k: number) => number;
            heights: number[];
            positions: number[];
            margin: number;
            durationFactor: number;
        };
    };
    readonly canvas: HTMLCanvasElement;
    changeView(view: ViewState, opts?: ViewChangeOptions): void;
    clearViewUndo(): void;
    static create(parentDiv: HTMLDivElement, view: ViewState): ScreenViewport;
    readonly decorationDiv: HTMLDivElement;
    doRedo(animationTime?: BeDuration): void;
    doUndo(animationTime?: BeDuration): void;
    // @internal (undocumented)
    drawLocateCursor(context: DecorateContext, viewPt: Point3d, aperture: number, isLocateCircleOn: boolean, hit?: HitDetail): void;
    getClientRect(): ClientRect;
    get isRedoPossible(): boolean;
    get isUndoPossible(): boolean;
    // @beta
    get logo(): HTMLImageElement;
    maxUndoSteps: number;
    // @internal (undocumented)
    mouseMovementFromEvent(ev: MouseEvent): XAndY;
    // @internal (undocumented)
    mousePosFromEvent(ev: MouseEvent): XAndY;
    openToolTip(message: HTMLElement | string, location?: XAndY, options?: ToolTipOptions): void;
    readonly parentDiv: HTMLDivElement;
    // @internal (undocumented)
    pickCanvasDecoration(pt: XAndY): import("./render/System").CanvasDecoration | undefined;
    // @alpha
    pickDepthPoint(pickPoint: Point3d, radius?: number, options?: DepthPointOptions): {
        plane: Plane3dByOriginAndUnitNormal;
        source: DepthPointSource;
        sourceId?: string;
    };
    pickNearestVisibleGeometry(pickPoint: Point3d, radius?: number, allowNonLocatable?: boolean, out?: Point3d): Point3d | undefined;
    // @internal
    static removeAllChildren(el: HTMLDivElement): void;
    // @internal
    get rendersToScreen(): boolean;
    set rendersToScreen(toScreen: boolean);
    resetUndo(): void;
    saveViewUndo(): void;
    setCursor(cursor?: string): void;
    setEventController(controller?: EventController): void;
    // @internal
    static setToParentSize(div: HTMLElement): void;
    // @internal (undocumented)
    synchWithView(options?: ViewChangeOptions | boolean): void;
    readonly toolTipDiv: HTMLDivElement;
    // @internal (undocumented)
    protected validateRenderPlan(): void;
    // @internal (undocumented)
    get viewCmdTargetCenter(): Point3d | undefined;
    set viewCmdTargetCenter(center: Point3d | undefined);
    get viewRect(): ViewRect;
    readonly vpDiv: HTMLDivElement;
    }

// @public
export class ScrollViewTool extends ViewManip {
    constructor(vp: ScreenViewport, oneShot?: boolean, isDraggingRequired?: boolean);
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    onReinitialize(): void;
    // (undocumented)
    static toolId: string;
}

// @public
export class SectionDrawingModelState extends DrawingModelState {
    // @internal (undocumented)
    static get className(): string;
}

// @public
export interface SelectAddEvent {
    added: Id64Arg;
    set: SelectionSet;
    // (undocumented)
    type: SelectionSetEventType.Add;
}

// @public
export interface SelectedViewportChangedArgs {
    // (undocumented)
    current?: ScreenViewport;
    // (undocumented)
    previous?: ScreenViewport;
}

// @public
export enum SelectionMethod {
    Box = 2,
    Line = 1,
    Pick = 0
}

// @public
export enum SelectionMode {
    Add = 1,
    Remove = 2,
    Replace = 0
}

// @public
export enum SelectionProcessing {
    AddElementToSelection = 0,
    InvertElementInSelection = 2,
    RemoveElementFromSelection = 1,
    ReplaceSelectionWithElement = 3
}

// @public
export class SelectionSet {
    constructor(iModel: IModelConnection);
    add(elem: Id64Arg): boolean;
    addAndRemove(adds: Id64Arg, removes: Id64Arg): boolean;
    get elements(): Set<string>;
    emptyAll(): void;
    has(elemId?: string): boolean;
    // (undocumented)
    iModel: IModelConnection;
    invert(elem: Id64Arg): boolean;
    get isActive(): boolean;
    isSelected(elemId?: Id64String): boolean;
    readonly onChanged: BeEvent<(ev: SelectionSetEvent) => void>;
    remove(elem: Id64Arg): boolean;
    replace(elem: Id64Arg): void;
    get size(): number;
}

// @public
export type SelectionSetEvent = SelectAddEvent | SelectRemoveEvent | SelectReplaceEvent;

// @public
export enum SelectionSetEventType {
    Add = 0,
    Clear = 3,
    Remove = 1,
    Replace = 2
}

// @public
export class SelectionTool extends PrimitiveTool {
    // @beta
    applyToolSettingPropertyChange(updatedValue: ToolSettingsPropertySyncItem): boolean;
    // (undocumented)
    autoLockTarget(): void;
    // (undocumented)
    decorate(context: DecorateContext): void;
    // (undocumented)
    filterHit(hit: HitDetail, out?: LocateResponse): Promise<LocateFilterStatus>;
    // (undocumented)
    static hidden: boolean;
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    protected initSelectTool(): void;
    // (undocumented)
    protected _isSelectByPoints: boolean;
    // (undocumented)
    protected _isSuspended: boolean;
    // (undocumented)
    onCleanup(): void;
    // (undocumented)
    onDataButtonUp(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onModifierKeyTransition(_wentDown: boolean, modifier: BeModifierKeys, _event: KeyboardEvent): Promise<EventHandled>;
    // (undocumented)
    onMouseEndDrag(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onMouseMotion(ev: BeButtonEvent): Promise<void>;
    // (undocumented)
    onMouseStartDrag(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onPostInstall(): void;
    // (undocumented)
    onResetButtonUp(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onRestartTool(): void;
    // (undocumented)
    onSuspend(): void;
    // (undocumented)
    onTouchCancel(ev: BeTouchEvent): Promise<void>;
    // (undocumented)
    onTouchComplete(ev: BeTouchEvent): Promise<void>;
    // (undocumented)
    onTouchMove(ev: BeTouchEvent): Promise<void>;
    // (undocumented)
    onTouchMoveStart(ev: BeTouchEvent, startEv: BeTouchEvent): Promise<EventHandled>;
    // (undocumented)
    onUnsuspend(): void;
    // (undocumented)
    protected readonly _points: Point3d[];
    // (undocumented)
    protected processMiss(_ev: BeButtonEvent): boolean;
    // (undocumented)
    processSelection(elementId: Id64Arg, process: SelectionProcessing): Promise<boolean>;
    // (undocumented)
    requireWriteableTarget(): boolean;
    // (undocumented)
    protected selectByPointsEnd(ev: BeButtonEvent): boolean;
    // (undocumented)
    protected selectByPointsProcess(origin: Point3d, corner: Point3d, ev: BeButtonEvent, method: SelectionMethod, overlap: boolean): void;
    // (undocumented)
    protected selectByPointsStart(ev: BeButtonEvent): boolean;
    // (undocumented)
    selectDecoration(ev: BeButtonEvent, currHit?: HitDetail): Promise<EventHandled>;
    // (undocumented)
    get selectionMethod(): SelectionMethod;
    set selectionMethod(method: SelectionMethod);
    // (undocumented)
    get selectionMode(): SelectionMode;
    set selectionMode(mode: SelectionMode);
    // (undocumented)
    protected showPrompt(mode: SelectionMode, method: SelectionMethod): void;
    // (undocumented)
    static startTool(): boolean;
    // @beta
    supplyToolSettingsProperties(): ToolSettingsPropertyRecord[] | undefined;
    // (undocumented)
    static toolId: string;
    // (undocumented)
    updateSelection(elementId: Id64Arg, process: SelectionProcessing): boolean;
    // (undocumented)
    protected useOverlapSelection(ev: BeButtonEvent): boolean;
    // (undocumented)
    protected wantEditManipulators(): boolean;
    // (undocumented)
    protected wantPickableDecorations(): boolean;
    // (undocumented)
    protected wantSelectionClearOnMiss(_ev: BeButtonEvent): boolean;
    // (undocumented)
    protected wantToolSettings(): boolean;
}

// @public
export interface SelectRemoveEvent {
    removed: Id64Arg;
    set: SelectionSet;
    type: SelectionSetEventType.Remove | SelectionSetEventType.Clear;
}

// @public
export interface SelectReplaceEvent {
    added: Id64Arg;
    removed: Id64Arg;
    set: SelectionSet;
    // (undocumented)
    type: SelectionSetEventType.Replace;
}

// @alpha
export class SetupCameraTool extends PrimitiveTool {
    // (undocumented)
    applyToolSettingPropertyChange(updatedValue: ToolSettingsPropertySyncItem): boolean;
    // (undocumented)
    get cameraHeight(): number;
    set cameraHeight(option: number);
    // (undocumented)
    decorate(context: DecorateContext): void;
    // (undocumented)
    decorateSuspended(context: DecorateContext): void;
    // (undocumented)
    protected _eyePtWorld: Point3d;
    // (undocumented)
    protected getAdjustedEyePoint(): Point3d;
    // (undocumented)
    protected getAdjustedTargetPoint(): Point3d;
    // (undocumented)
    protected _haveEyePt: boolean;
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    isCompatibleViewport(vp: Viewport | undefined, isSelectedViewChange: boolean): boolean;
    // (undocumented)
    isValidLocation(_ev: BeButtonEvent, _isButtonEvent: boolean): boolean;
    // (undocumented)
    onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onKeyTransition(wentDown: boolean, keyEvent: KeyboardEvent): Promise<EventHandled>;
    // (undocumented)
    onMouseMotion(ev: BeButtonEvent): Promise<void>;
    // (undocumented)
    onPostInstall(): void;
    // (undocumented)
    onResetButtonUp(_ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onRestartTool(): void;
    // (undocumented)
    onUnsuspend(): void;
    // @beta (undocumented)
    protected provideToolAssistance(): void;
    // (undocumented)
    requireWriteableTarget(): boolean;
    // (undocumented)
    protected setupAndPromptForNextAction(): void;
    // (undocumented)
    supplyToolSettingsProperties(): ToolSettingsPropertyRecord[] | undefined;
    // (undocumented)
    get targetHeight(): number;
    set targetHeight(option: number);
    // (undocumented)
    protected _targetPtWorld: Point3d;
    // (undocumented)
    static toolId: string;
    // (undocumented)
    get useCameraHeight(): boolean;
    set useCameraHeight(option: boolean);
    // (undocumented)
    get useTargetHeight(): boolean;
    set useTargetHeight(option: boolean);
    // (undocumented)
    viewport?: ScreenViewport;
}

// @internal
export class SheetBorder {
    addToBuilder(builder: GraphicBuilder): void;
    static create(width: number, height: number, context?: DecorateContext): SheetBorder;
    // (undocumented)
    getRange(): Range2d;
    }

// @public
export class SheetModelState extends GeometricModel2dState {
    // @internal (undocumented)
    static get className(): string;
}

// @public
export class SheetViewState extends ViewState2d {
    constructor(props: ViewDefinition2dProps, iModel: IModelConnection, categories: CategorySelectorState, displayStyle: DisplayStyle2dState, sheetProps: SheetProps, attachments: Id64Array);
    // @internal (undocumented)
    get attachmentIds(): Id64Array;
    // @internal (undocumented)
    static get className(): string;
    // @internal (undocumented)
    computeFitRange(): Range3d;
    // (undocumented)
    static createFromProps(viewStateData: ViewStateProps, iModel: IModelConnection): SheetViewState;
    // @internal
    createScene(context: SceneContext): void;
    // @internal (undocumented)
    decorate(context: DecorateContext): void;
    // @internal (undocumented)
    get defaultExtentLimits(): {
        min: number;
        max: number;
    };
    // @internal
    discloseTileTrees(trees: TileTreeSet): void;
    // @internal
    load(): Promise<void>;
    // @internal
    markAttachment3dSceneIncomplete(): void;
    // @internal
    onRenderFrame(_viewport: Viewport): void;
    readonly sheetSize: Point2d;
}

// @internal
export type ShouldAbortReadGltf = (reader: GltfReader) => boolean;

// @public
export abstract class SkyBox implements SkyBoxProps {
    protected constructor(sky?: SkyBoxProps);
    static createFromJSON(json?: SkyBoxProps): SkyBox;
    display: boolean;
    // @internal (undocumented)
    abstract loadParams(_system: RenderSystem, _iModel: IModelConnection): SkyBoxParams;
    // (undocumented)
    toJSON(): SkyBoxProps;
}

// @public
export namespace SkyBox {
    export class CreateParams {
        // (undocumented)
        static createForCube(cube: RenderTexture): CreateParams;
        // (undocumented)
        static createForGradient(gradient: SkyGradient, zOffset: number): CreateParams;
        // (undocumented)
        static createForSphere(sphere: SphereParams, zOffset: number): CreateParams;
        // (undocumented)
        readonly cube?: RenderTexture;
        // (undocumented)
        readonly gradient?: SkyGradient;
        // (undocumented)
        readonly sphere?: SphereParams;
        // (undocumented)
        readonly zOffset: number;
    }
    export class SphereParams {
        constructor(texture: RenderTexture, rotation: number);
        // (undocumented)
        readonly rotation: number;
        // (undocumented)
        readonly texture: RenderTexture;
    }
}

// @internal
export type SkyBoxParams = Promise<SkyBox.CreateParams | undefined> | SkyBox.CreateParams | undefined;

// @public
export class SkyCube extends SkyBox implements SkyCubeProps {
    readonly back: Id64String;
    readonly bottom: Id64String;
    static create(front: Id64String, back: Id64String, top: Id64String, bottom: Id64String, right: Id64String, left: Id64String, display?: boolean): SkyCube | undefined;
    // @internal
    static fromJSON(skyboxJson: SkyBoxProps): SkyCube | undefined;
    readonly front: Id64String;
    readonly left: Id64String;
    // @internal (undocumented)
    loadParams(system: RenderSystem, iModel: IModelConnection): SkyBoxParams;
    readonly right: Id64String;
    // (undocumented)
    toJSON(): SkyBoxProps;
    readonly top: Id64String;
}

// @public
export class SkyGradient extends SkyBox {
    constructor(sky?: SkyBoxProps);
    readonly groundColor: ColorDef;
    readonly groundExponent: number;
    // @internal (undocumented)
    loadParams(_system: RenderSystem, iModel: IModelConnection): SkyBoxParams;
    readonly nadirColor: ColorDef;
    readonly skyColor: ColorDef;
    readonly skyExponent: number;
    // (undocumented)
    toJSON(): SkyBoxProps;
    readonly twoColor: boolean;
    readonly zenithColor: ColorDef;
}

// @public
export class SkySphere extends SkyBox {
    static fromJSON(json: SkyBoxProps): SkySphere | undefined;
    // @internal (undocumented)
    loadParams(system: RenderSystem, iModel: IModelConnection): SkyBoxParams;
    textureId: Id64String;
    // (undocumented)
    toJSON(): SkyBoxProps;
}

// @alpha
export interface SliderEditorParams extends BasePropertyEditorParams {
    intervals?: boolean;
    maximum: number;
    minimum: number;
    numButtons?: number;
    // (undocumented)
    type: PropertyEditorParamTypes.Slider;
    valueFactor?: number;
    vertical?: boolean;
}

// @public
export class SnapDetail extends HitDetail {
    constructor(from: HitDetail, snapMode?: SnapMode, heat?: SnapHeat, snapPoint?: XYZProps);
    readonly adjustedPoint: Point3d;
    clone(): SnapDetail;
    // (undocumented)
    draw(context: DecorateContext): void;
    geomType?: HitGeomType;
    // (undocumented)
    getCurvePrimitive(singleSegment?: boolean): CurvePrimitive | undefined;
    getHitType(): HitDetailType;
    getPoint(): Point3d;
    // (undocumented)
    heat: SnapHeat;
    get isHot(): boolean;
    get isPointAdjusted(): boolean;
    normal?: Vector3d;
    parentGeomType?: HitParentGeomType;
    primitive?: CurvePrimitive;
    setCurvePrimitive(primitive?: CurvePrimitive, localToWorld?: Transform, geomType?: HitGeomType): void;
    setSnapPoint(point: Point3d, heat: SnapHeat): void;
    // (undocumented)
    snapMode: SnapMode;
    readonly snapPoint: Point3d;
    sprite?: Sprite;
}

// @public (undocumented)
export enum SnapHeat {
    // (undocumented)
    InRange = 2,
    // (undocumented)
    None = 0,
    // (undocumented)
    NotInRange = 1
}

// @public (undocumented)
export enum SnapMode {
    // (undocumented)
    Bisector = 32,
    // (undocumented)
    Center = 8,
    // (undocumented)
    Intersection = 64,
    // (undocumented)
    MidPoint = 4,
    // (undocumented)
    Nearest = 1,
    // (undocumented)
    NearestKeypoint = 2,
    // (undocumented)
    Origin = 16
}

// @public (undocumented)
export enum SnapStatus {
    // (undocumented)
    Aborted = 1,
    // (undocumented)
    Disabled = 100,
    // (undocumented)
    FilteredByApp = 600,
    // (undocumented)
    FilteredByAppQuietly = 700,
    // (undocumented)
    NoElements = 2,
    // (undocumented)
    NoSnapPossible = 200,
    // (undocumented)
    NotSnappable = 300,
    // (undocumented)
    Success = 0
}

// @beta
export class SpatialClassifiers {
    [Symbol.iterator](): Iterator<SpatialClassificationProps.Classifier>;
    // @internal
    constructor(jsonContainer: SpatialClassifiersContainer);
    get active(): SpatialClassificationProps.Classifier | undefined;
    set active(active: SpatialClassificationProps.Classifier | undefined);
    get length(): number;
    push(classifier: SpatialClassificationProps.Classifier): SpatialClassificationProps.Classifier | undefined;
}

// @internal (undocumented)
export interface SpatialClassifiersContainer {
    // (undocumented)
    classifiers?: SpatialClassificationProps.Properties[];
}

// @internal (undocumented)
export abstract class SpatialClassifierTileTreeReference extends TileTreeReference {
    // (undocumented)
    abstract get classifiers(): SpatialClassifiers;
}

// @public
export class SpatialLocationModelState extends SpatialModelState {
    // @internal (undocumented)
    static get className(): string;
}

// @public
export class SpatialModelState extends GeometricModel3dState {
    constructor(props: ModelProps, iModel: IModelConnection, state?: SpatialModelState);
    // @internal (undocumented)
    get asSpatialModel(): SpatialModelState;
    // @beta
    readonly classifiers?: SpatialClassifiers;
    // @internal (undocumented)
    static get className(): string;
}

// @internal
export class SpatialModelTileTrees {
    constructor(view: SpatialViewState);
    // (undocumented)
    protected _allLoaded: boolean;
    // (undocumented)
    protected createTileTreeReference(model: GeometricModel3dState): TileTreeReference | undefined;
    // (undocumented)
    forEach(func: (treeRef: TileTreeReference) => void): void;
    // (undocumented)
    protected get _iModel(): IModelConnection;
    // (undocumented)
    markDirty(): void;
    // (undocumented)
    protected _treeRefs: Map<string, TileTreeReference>;
    // (undocumented)
    protected readonly _view: SpatialViewState;
}

// @public
export class SpatialViewState extends ViewState3d {
    constructor(props: SpatialViewDefinitionProps, iModel: IModelConnection, arg3: CategorySelectorState, displayStyle: DisplayStyle3dState, modelSelector: ModelSelectorState);
    // (undocumented)
    addViewedModel(id: Id64String): void;
    // @internal (undocumented)
    static get className(): string;
    // (undocumented)
    clearViewedModels(): void;
    // (undocumented)
    computeFitRange(): AxisAlignedBox3d;
    // (undocumented)
    createAuxCoordSystem(acsName: string): AuxCoordSystemState;
    // @beta
    static createBlank(iModel: IModelConnection, origin: XYAndZ, extents: XYAndZ, rotation?: Matrix3d): SpatialViewState;
    // (undocumented)
    static createFromProps(props: ViewStateProps, iModel: IModelConnection): SpatialViewState;
    // @internal (undocumented)
    createScene(context: SceneContext): void;
    // (undocumented)
    get defaultExtentLimits(): {
        min: number;
        max: number;
    };
    // (undocumented)
    equals(other: this): boolean;
    // (undocumented)
    forEachModel(func: (model: GeometricModelState) => void): void;
    // @internal (undocumented)
    forEachModelTreeRef(func: (treeRef: TileTreeReference) => void): void;
    // (undocumented)
    getViewedExtents(): AxisAlignedBox3d;
    // (undocumented)
    load(): Promise<void>;
    // @internal (undocumented)
    markModelSelectorChanged(): void;
    // (undocumented)
    modelSelector: ModelSelectorState;
    // (undocumented)
    removeViewedModel(id: Id64String): void;
    // (undocumented)
    toJSON(): SpatialViewDefinitionProps;
    // (undocumented)
    viewsModel(modelId: Id64String): boolean;
}

// @public
export class Sprite {
    constructor(src: ImageSource | string);
    image?: HTMLImageElement;
    get isLoaded(): boolean;
    loadPromise: Promise<HTMLImageElement>;
    get offset(): Point2d;
    readonly size: Point2d;
}

// @public
export class SpriteLocation implements CanvasDecoration {
    activate(sprite: Sprite, viewport: ScreenViewport, locationWorld: XYAndZ, alpha?: number): void;
    deactivate(): void;
    decorate(context: DecorateContext): void;
    drawDecoration(ctx: CanvasRenderingContext2D): void;
    // (undocumented)
    get isActive(): boolean;
    readonly position: Point3d;
    }

// @public
export class StandardView {
    static adjustToStandardRotation(matrix: Matrix3d): void;
    // (undocumented)
    static get back(): Matrix3d;
    // (undocumented)
    static get bottom(): Matrix3d;
    // (undocumented)
    static get front(): Matrix3d;
    static getStandardRotation(id: StandardViewId): Matrix3d;
    // (undocumented)
    static get iso(): Matrix3d;
    // (undocumented)
    static get left(): Matrix3d;
    // (undocumented)
    static get right(): Matrix3d;
    // (undocumented)
    static get rightIso(): Matrix3d;
    // (undocumented)
    static get top(): Matrix3d;
}

// @public
export enum StandardViewId {
    // (undocumented)
    Back = 5,
    // (undocumented)
    Bottom = 1,
    // (undocumented)
    Front = 4,
    // (undocumented)
    Iso = 6,
    // (undocumented)
    Left = 2,
    NotStandard = -1,
    // (undocumented)
    Right = 3,
    // (undocumented)
    RightIso = 7,
    // (undocumented)
    Top = 0
}

// @public
export class StandardViewTool extends ViewTool {
    constructor(viewport: ScreenViewport, _standardViewId: StandardViewId);
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    onPostInstall(): void;
    // (undocumented)
    static toolId: string;
}

// @public (undocumented)
export enum StartOrResume {
    // (undocumented)
    Resume = 2,
    // (undocumented)
    Start = 1
}

// @beta
export interface StructValue extends BasePropertyValue {
    // (undocumented)
    members: {
        [name: string]: PropertyRecord;
    };
    // (undocumented)
    valueFormat: PropertyValueFormat.Struct;
}

// @internal
export class SubCategoriesCache {
    constructor(imodel: IModelConnection);
    // (undocumented)
    clear(): void;
    getSubCategories(categoryId: string): Id64Set | undefined;
    getSubCategoryAppearance(subCategoryId: Id64String): SubCategoryAppearance | undefined;
    load(categoryIds: Id64Arg): SubCategoriesRequest | undefined;
    // (undocumented)
    onIModelConnectionClose(): void;
    }

// @internal
export namespace SubCategoriesCache {
    export class Queue {
        // (undocumented)
        protected _current?: QueueEntry;
        dispose(): void;
        // (undocumented)
        protected _disposed: boolean;
        // (undocumented)
        get isEmpty(): boolean;
        // (undocumented)
        protected _next?: QueueEntry;
        push(cache: SubCategoriesCache, categoryIds: Id64Arg, func: QueueFunc): void;
        // (undocumented)
        protected _request?: SubCategoriesRequest;
    }
    // (undocumented)
    export class QueueEntry {
        constructor(categoryIds: Id64Set, func: QueueFunc);
        // (undocumented)
        readonly categoryIds: Id64Set;
        // (undocumented)
        readonly funcs: QueueFunc[];
    }
    // (undocumented)
    export type QueueFunc = () => void;
    // (undocumented)
    export class Request {
        constructor(categoryIds: Set<string>, imodel: IModelConnection, maxCategoriesPerQuery?: number);
        // (undocumented)
        cancel(): void;
        // (undocumented)
        dispatch(): Promise<Result | undefined>;
        // (undocumented)
        get wasCanceled(): boolean;
    }
    // (undocumented)
    export type Result = ResultRow[];
    // (undocumented)
    export interface ResultRow {
        // (undocumented)
        appearance: SubCategoryAppearance.Props;
        // (undocumented)
        id: Id64String;
        // (undocumented)
        parentId: Id64String;
    }
}

// @internal
export interface SubCategoriesRequest {
    cancel(): void;
    readonly missingCategoryIds: Id64Set;
    readonly promise: Promise<boolean>;
}

// @beta
export interface SuppressLabelEditorParams extends BasePropertyEditorParams {
    suppressLabelPlaceholder?: boolean;
    // (undocumented)
    type: PropertyEditorParamTypes.SuppressEditorLabel;
}

// @alpha
export interface SuppressUnitLabelEditorParams extends BasePropertyEditorParams {
    // (undocumented)
    type: PropertyEditorParamTypes.SuppressUnitLabel;
}

// @beta
export class SurveyLengthDescription extends BaseQuantityDescription {
    constructor(name?: string, displayLabel?: string, iconSpec?: string);
    // (undocumented)
    get parseError(): string;
    // (undocumented)
    get quantityType(): QuantityType;
}

// @internal (undocumented)
export class SuspendedToolState {
    constructor();
    // (undocumented)
    stop(): void;
    }

// @internal (undocumented)
export abstract class Target extends RenderTarget implements RenderTargetDebugControl, WebGLDisposable {
    protected constructor(rect?: ViewRect);
    // (undocumented)
    activeVolumeClassifierModelId?: Id64String;
    // (undocumented)
    activeVolumeClassifierProps?: SpatialClassificationProps.Classifier;
    // (undocumented)
    activeVolumeClassifierTexture?: WebGLTexture;
    // (undocumented)
    addBatch(batch: Batch): void;
    // (undocumented)
    ambientOcclusionSettings: AmbientOcclusion.Settings;
    // (undocumented)
    analysisStyle?: AnalysisStyle;
    // (undocumented)
    analysisTexture?: RenderTexture;
    // (undocumented)
    get animationBranches(): AnimationBranchStates | undefined;
    set animationBranches(branches: AnimationBranchStates | undefined);
    // (undocumented)
    get animationFraction(): number;
    set animationFraction(fraction: number);
    // (undocumented)
    protected abstract _assignDC(): boolean;
    // (undocumented)
    protected abstract _beginPaint(): void;
    // (undocumented)
    beginPerfMetricFrame(sceneMilSecElapsed?: number): void;
    // (undocumented)
    beginPerfMetricRecord(operation: string): void;
    // (undocumented)
    changeActiveVolumeClassifierProps(props?: SpatialClassificationProps.Classifier, modelId?: Id64String): void;
    // (undocumented)
    changeBackgroundMap(backgroundMap: GraphicList): void;
    // (undocumented)
    changeDecorations(decs: Decorations): void;
    // (undocumented)
    changeDynamics(dynamics?: GraphicList): void;
    // (undocumented)
    changeFrustum(newFrustum: Frustum, newFraction: number, is3d: boolean): void;
    // (undocumented)
    changeOverlayGraphics(overlayGraphics: GraphicList): void;
    // (undocumented)
    changePlanarClassifiers(planarClassifiers?: PlanarClassifierMap): void;
    // (undocumented)
    changeRenderPlan(plan: RenderPlan): void;
    // (undocumented)
    changeScene(scene: GraphicList): void;
    // (undocumented)
    changeTextureDrapes(textureDrapes: TextureDrapeMap | undefined): void;
    // (undocumented)
    get clipDef(): ClipDef;
    // (undocumented)
    get clipMask(): TextureHandle | undefined;
    set clipMask(mask: TextureHandle | undefined);
    // (undocumented)
    readonly clips: Clips;
    // (undocumented)
    collectStatistics(stats: RenderMemory.Statistics): void;
    // (undocumented)
    get compositor(): SceneCompositor;
    // (undocumented)
    protected _compositor: SceneCompositor;
    // (undocumented)
    copyImageToCanvas(): HTMLCanvasElement;
    // (undocumented)
    createPlanarClassifier(properties: SpatialClassificationProps.Classifier): PlanarClassifier;
    // (undocumented)
    protected cssViewRectToDeviceViewRect(rect: ViewRect): ViewRect;
    // (undocumented)
    get currentFeatureSymbologyOverrides(): FeatureSymbology.Overrides;
    // (undocumented)
    get currentlyDrawingClassifier(): PlanarClassifier | undefined;
    // (undocumented)
    get currentPlanarClassifier(): PlanarClassifier | undefined;
    // (undocumented)
    get currentPlanarClassifierOrDrape(): PlanarClassifier | TextureDrape | undefined;
    // (undocumented)
    get currentShaderFlags(): ShaderFlags;
    // (undocumented)
    get currentTextureDrape(): TextureDrape | undefined;
    // (undocumented)
    get currentTransform(): Transform;
    // (undocumented)
    get currentViewFlags(): ViewFlags;
    // (undocumented)
    protected _dcAssigned: boolean;
    // (undocumented)
    get debugControl(): RenderTargetDebugControl;
    // (undocumented)
    protected _decorations?: Decorations;
    // (undocumented)
    readonly decorationState: BranchState;
    // (undocumented)
    displayDrapeFrustum: boolean;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    drawForReadPixels: boolean;
    // (undocumented)
    drawFrame(sceneMilSecElapsed?: number): void;
    // (undocumented)
    get drawNonLocatable(): boolean;
    // (undocumented)
    protected drawOverlayDecorations(): void;
    // (undocumented)
    drawPlanarClassifiers(): void;
    // (undocumented)
    drawSolarShadowMap(): void;
    // (undocumented)
    drawTextureDrapes(): void;
    // (undocumented)
    get dynamics(): GraphicList | undefined;
    // (undocumented)
    get edgeColor(): ColorInfo;
    // (undocumented)
    protected abstract _endPaint(): void;
    // (undocumented)
    endPerfMetricFrame(): void;
    // (undocumented)
    endPerfMetricRecord(): void;
    // (undocumented)
    protected _fbo?: FrameBuffer;
    // (undocumented)
    get flashed(): Id64.Uint32Pair | undefined;
    // (undocumented)
    get flashedId(): Id64String;
    // (undocumented)
    get flashIntensity(): number;
    // (undocumented)
    getEdgeLineCode(params: ShaderProgramParams, baseCode: number): number;
    // (undocumented)
    getEdgeOverrides(pass: RenderPass): EdgeOverrides | undefined;
    // (undocumented)
    getEdgeWeight(params: ShaderProgramParams, baseWeight: number): number;
    // (undocumented)
    getPlanarClassifier(id: Id64String): RenderPlanarClassifier | undefined;
    // (undocumented)
    getTextureDrape(id: Id64String): RenderTextureDrape | undefined;
    // (undocumented)
    getWorldDecorations(decs: GraphicList): Branch;
    // (undocumented)
    get hasClipMask(): boolean;
    // (undocumented)
    get hasClipVolume(): boolean;
    // (undocumented)
    get hiddenEdgeOverrides(): EdgeOverrides | undefined;
    // (undocumented)
    get hilites(): Hilites;
    // (undocumented)
    get hiliteSyncTarget(): SyncTarget;
    // (undocumented)
    get is2d(): boolean;
    // (undocumented)
    get is3d(): boolean;
    // (undocumented)
    get isDisposed(): boolean;
    // (undocumented)
    get isDrawingShadowMap(): boolean;
    // (undocumented)
    get isEdgeColorOverridden(): boolean;
    // (undocumented)
    get isEdgeWeightOverridden(): boolean;
    // (undocumented)
    isFadeOutActive: boolean;
    // (undocumented)
    isGeometryOutsideActiveVolume(geom: CachedGeometry): boolean;
    // (undocumented)
    isRangeOutsideActiveVolume(range: Range3d): boolean;
    // (undocumented)
    get isReadPixelsInProgress(): boolean;
    // (undocumented)
    onBatchDisposed(batch: Batch): void;
    // (undocumented)
    overrideFeatureSymbology(ovr: FeatureSymbology.Overrides): void;
    // (undocumented)
    performanceMetrics?: PerformanceMetrics;
    // (undocumented)
    plan: RenderPlan;
    // (undocumented)
    get planFraction(): number;
    // (undocumented)
    get planFrustum(): Frustum;
    // (undocumented)
    popActiveVolume(): void;
    // (undocumented)
    popBatch(): void;
    // (undocumented)
    popBranch(): void;
    // (undocumented)
    primitiveVisibility: PrimitiveVisibility;
    // (undocumented)
    pushActiveVolume(): void;
    // (undocumented)
    pushBatch(batch: Batch): void;
    // (undocumented)
    pushBranch(exec: ShaderProgramExecutor, branch: Branch): void;
    // (undocumented)
    pushState(state: BranchState): void;
    readImage(wantRectIn: ViewRect, targetSizeIn: Point2d, flipVertically: boolean): ImageBuffer | undefined;
    // (undocumented)
    protected readImagePixels(out: Uint8Array, x: number, y: number, w: number, h: number): boolean;
    // (undocumented)
    readPixels(rect: ViewRect, selector: Pixel.Selector, receiver: Pixel.Receiver, excludeNonLocatable: boolean): void;
    // (undocumented)
    get readPixelsSelector(): Pixel.Selector;
    // (undocumented)
    readonly renderRect: ViewRect;
    // (undocumented)
    get renderSystem(): System;
    // (undocumented)
    reset(): void;
    // (undocumented)
    get scene(): GraphicList;
    // (undocumented)
    setFlashed(id: Id64String, intensity: number): void;
    // (undocumented)
    setHiliteSet(hilite: HiliteSet): void;
    // (undocumented)
    get shadowFrustum(): Frustum | undefined;
    // (undocumented)
    get solarShadowMap(): SolarShadowMap;
    // (undocumented)
    get techniques(): Techniques;
    // (undocumented)
    get transparencyThreshold(): number;
    // (undocumented)
    readonly uniforms: TargetUniforms;
    // (undocumented)
    updateSolarShadows(context: SceneContext | undefined): void;
    // (undocumented)
    useLogZ: boolean;
    // (undocumented)
    vcSupportIntersectingVolumes: boolean;
    // (undocumented)
    get visibleEdgeOverrides(): EdgeOverrides | undefined;
    // (undocumented)
    get wantAmbientOcclusion(): boolean;
    // (undocumented)
    get wantInvertBlackBackground(): boolean;
    // (undocumented)
    get wantLogZ(): boolean;
    }

// @internal (undocumented)
export class TentativeOrAccuSnap {
    // (undocumented)
    static getCurrentPoint(): Point3d;
    // (undocumented)
    static getCurrentSnap(checkIsHot?: boolean): SnapDetail | undefined;
    // (undocumented)
    static getCurrentView(): ScreenViewport | undefined;
    // (undocumented)
    static get isHot(): boolean;
}

// @public (undocumented)
export class TentativePoint {
    // (undocumented)
    clear(doErase: boolean): void;
    // (undocumented)
    currSnap?: SnapDetail;
    // (undocumented)
    decorate(context: DecorateContext): void;
    getCurrSnap(): SnapDetail | undefined;
    // (undocumented)
    getHitAndList(holder: HitListHolder): SnapDetail | undefined;
    // (undocumented)
    getPoint(): Point3d;
    // (undocumented)
    isActive: boolean;
    get isSnapped(): boolean;
    // (undocumented)
    onButtonEvent(ev: BeButtonEvent): void;
    // (undocumented)
    onInitialized(): void;
    // (undocumented)
    process(ev: BeButtonEvent): void;
    // (undocumented)
    removeTentative(): void;
    // (undocumented)
    setCurrSnap(newSnap?: SnapDetail): void;
    // (undocumented)
    setHitList(list?: HitList<HitDetail>): void;
    // (undocumented)
    setPoint(point: Point3d): void;
    // (undocumented)
    showTentative(): void;
    // (undocumented)
    tpHits?: HitList<HitDetail>;
    // (undocumented)
    viewport?: ScreenViewport;
}

// @internal
export abstract class TerrainProvider implements TiledGraphicsProvider {
    // (undocumented)
    forEachTileTreeRef(viewport: Viewport, func: (ref: TileTreeReference) => void): void;
    // (undocumented)
    abstract getTileTree(viewport: Viewport): TileTreeReference | undefined;
    // (undocumented)
    onInitialized(): void;
}

// @internal
export abstract class TerrainTileLoaderBase extends MapTileLoaderBase {
    // (undocumented)
    get clipLowResolutionTiles(): boolean;
    // (undocumented)
    abstract get geometryAttributionProvider(): MapTileGeometryAttributionProvider;
    // (undocumented)
    get priority(): Tile.LoadPriority;
}

// @internal (undocumented)
export type TextureDrapeMap = Map<Id64String, RenderTextureDrape>;

// @internal
export interface TextureImage {
    format: ImageSourceFormat | undefined;
    image: HTMLImageElement | undefined;
}

// @internal (undocumented)
export class ThreeAxes {
    // (undocumented)
    clone(): ThreeAxes;
    // (undocumented)
    static createFromMatrix3d(rMatrix: Matrix3d, result?: ThreeAxes): ThreeAxes;
    // (undocumented)
    equals(other: ThreeAxes): boolean;
    // (undocumented)
    fromMatrix3d(rMatrix: Matrix3d): void;
    // (undocumented)
    setFrom(other: ThreeAxes): void;
    // (undocumented)
    toMatrix3d(out?: Matrix3d): Matrix3d;
    // (undocumented)
    readonly x: Vector3d;
    // (undocumented)
    readonly y: Vector3d;
    // (undocumented)
    readonly z: Vector3d;
}

// @internal
export class Tile implements IDisposable, RenderMemory.Consumer {
    constructor(props: Tile.Params);
    // (undocumented)
    addBoundingRectangle(builder: GraphicBuilder, color: ColorDef): void;
    // (undocumented)
    allChildrenIncluded(tiles: Tile[]): boolean;
    // (undocumented)
    protected get _anyChildNotFound(): boolean;
    // (undocumented)
    readonly center: Point3d;
    // (undocumented)
    get children(): Tile[] | undefined;
    // (undocumented)
    protected _children?: Tile[];
    // (undocumented)
    protected _childrenLastUsed: BeTimePoint;
    // (undocumented)
    protected _childrenLoadStatus: TileTree.LoadStatus;
    // (undocumented)
    collectStatistics(stats: RenderMemory.Statistics): void;
    // (undocumented)
    computeVisibility(args: Tile.DrawArgs): Tile.Visibility;
    computeWorldContentRange(): ElementAlignedBox3d;
    // (undocumented)
    contentId: string;
    // (undocumented)
    get contentRange(): ElementAlignedBox3d;
    // (undocumented)
    protected _contentRange?: ElementAlignedBox3d;
    // (undocumented)
    countDescendants(): number;
    // (undocumented)
    debugDump(): string;
    // (undocumented)
    readonly depth: number;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    drawGraphics(args: Tile.DrawArgs): void;
    // (undocumented)
    get emptySubRangeMask(): number;
    // (undocumented)
    protected _emptySubRangeMask?: number;
    // (undocumented)
    getContentClip(): ClipVector | undefined;
    // (undocumented)
    protected getLoadedRealityChildren(args: Tile.DrawArgs): boolean;
    // (undocumented)
    getRangeGraphic(context: SceneContext): RenderGraphic | undefined;
    // (undocumented)
    protected _graphic?: RenderGraphic;
    // (undocumented)
    get graphics(): RenderGraphic | undefined;
    // (undocumented)
    get hasChildren(): boolean;
    // (undocumented)
    get hasContentRange(): boolean;
    // (undocumented)
    get hasGraphics(): boolean;
    // (undocumented)
    get hasSizeMultiplier(): boolean;
    // (undocumented)
    get iModel(): IModelConnection;
    // (undocumented)
    isContentCulled(args: Tile.DrawArgs): boolean;
    // (undocumented)
    get isDisplayable(): boolean;
    // (undocumented)
    get isEmpty(): boolean;
    // (undocumented)
    get isLeaf(): boolean;
    // (undocumented)
    protected _isLeaf: boolean;
    // (undocumented)
    get isLoading(): boolean;
    // (undocumented)
    get isNotFound(): boolean;
    // (undocumented)
    get isParentDisplayable(): boolean;
    // (undocumented)
    get isQueued(): boolean;
    // (undocumented)
    get isReady(): boolean;
    // (undocumented)
    isRegionCulled(args: Tile.DrawArgs): boolean;
    // (undocumented)
    get isUndisplayableRootTile(): boolean;
    // (undocumented)
    protected loadChildren(): TileTree.LoadStatus;
    // (undocumented)
    get loader(): TileLoader;
    // (undocumented)
    get loadStatus(): Tile.LoadStatus;
    // (undocumented)
    get maximumSize(): number;
    // (undocumented)
    protected _maximumSize: number;
    // (undocumented)
    readonly parent: Tile | undefined;
    // (undocumented)
    readonly radius: number;
    // (undocumented)
    readonly range: ElementAlignedBox3d;
    // (undocumented)
    protected _rangeGraphic?: RenderGraphic;
    // (undocumented)
    protected _rangeGraphicType: Tile.DebugBoundingBoxes;
    // (undocumented)
    get request(): TileRequest | undefined;
    set request(request: TileRequest | undefined);
    // (undocumented)
    protected _request?: TileRequest;
    // (undocumented)
    readonly root: TileTree;
    // (undocumented)
    protected selectRealityChildren(context: TraversalSelectionContext, args: Tile.DrawArgs, traversalDetails: TraversalDetails): void;
    // (undocumented)
    selectRealityTiles(context: TraversalSelectionContext, args: Tile.DrawArgs, traversalDetails: TraversalDetails): void;
    // (undocumented)
    selectTiles(selected: Tile[], args: Tile.DrawArgs, numSkipped?: number): Tile.SelectParent;
    // (undocumented)
    setAbandoned(): void;
    // (undocumented)
    setContent(content: Tile.Content): void;
    // (undocumented)
    setIsReady(): void;
    // (undocumented)
    setNotFound(): void;
    // (undocumented)
    get sizeMultiplier(): number | undefined;
    // (undocumented)
    protected _sizeMultiplier?: number;
    // (undocumented)
    readonly transformToRoot?: Transform;
    // (undocumented)
    protected _transformToRoot?: Transform;
    // (undocumented)
    protected unloadChildren(olderThan?: BeTimePoint): void;
    // (undocumented)
    get yAxisUp(): boolean;
}

// @internal (undocumented)
export namespace Tile {
    export interface Content {
        contentRange?: ElementAlignedBox3d;
        emptySubRangeMask?: number;
        graphic?: RenderGraphic;
        isLeaf?: boolean;
        sizeMultiplier?: number;
    }
    export const enum DebugBoundingBoxes {
        Both = 3,
        ChildVolumes = 4,
        Content = 2,
        None = 0,
        Sphere = 5,
        Volume = 1
    }
    export class DrawArgs {
        constructor(context: SceneContext, location: Transform, root: TileTree, now: BeTimePoint, purgeOlderThan: BeTimePoint, clip?: RenderClipVolume, parentsAndChildrenExclusive?: boolean);
        // (undocumented)
        get clip(): ClipVector | undefined;
        // (undocumented)
        clipVolume?: RenderClipVolume;
        // (undocumented)
        readonly context: SceneContext;
        // (undocumented)
        drape?: RenderTextureDrape;
        // (undocumented)
        drawGraphics(): void;
        // (undocumented)
        get frustumPlanes(): FrustumPlanes;
        // (undocumented)
        getPixelSize(tile: Tile): number;
        // (undocumented)
        getTileCenter(tile: Tile): Point3d;
        // (undocumented)
        getTileRadius(tile: Tile): number;
        // (undocumented)
        readonly graphics: GraphicBranch;
        // (undocumented)
        insertMissing(tile: Tile): void;
        // (undocumented)
        readonly location: Transform;
        // (undocumented)
        markChildrenLoading(): void;
        // (undocumented)
        readonly now: BeTimePoint;
        // (undocumented)
        parentsAndChildrenExclusive: boolean;
        // (undocumented)
        planarClassifier?: RenderPlanarClassifier;
        // (undocumented)
        readonly purgeOlderThan: BeTimePoint;
        // (undocumented)
        readonly root: TileTree;
        get tileSizeModifier(): number;
        // (undocumented)
        readonly viewClip?: ClipVector;
        // (undocumented)
        viewFrustum?: ViewingSpace;
        // (undocumented)
        protected get worldToViewMap(): Map4d;
    }
    export const enum LoadPriority {
        Classifier = 50,
        Context = 40,
        Map = 1,
        Primary = 20,
        Terrain = 30
    }
    export const enum LoadStatus {
        // (undocumented)
        Abandoned = 5,
        // (undocumented)
        Loading = 2,
        // (undocumented)
        NotFound = 4,
        // (undocumented)
        NotLoaded = 0,
        // (undocumented)
        Queued = 1,
        // (undocumented)
        Ready = 3
    }
    export interface Params {
        // (undocumented)
        readonly contentId: string;
        // (undocumented)
        readonly contentRange?: ElementAlignedBox3d;
        // (undocumented)
        readonly isLeaf?: boolean;
        // (undocumented)
        readonly maximumSize: number;
        // (undocumented)
        readonly parent?: Tile;
        // (undocumented)
        readonly range: ElementAlignedBox3d;
        // (undocumented)
        readonly root: TileTree;
        // (undocumented)
        readonly sizeMultiplier?: number;
        // (undocumented)
        readonly transformToRoot?: Transform;
    }
    // (undocumented)
    export function paramsFromJSON(props: TileProps, root: TileTree, parent?: Tile): Params;
    export const enum SelectParent {
        // (undocumented)
        No = 0,
        // (undocumented)
        Yes = 1
    }
    export const enum Visibility {
        // (undocumented)
        OutsideFrustum = 0,
        // (undocumented)
        TooCoarse = 1,
        // (undocumented)
        Visible = 2
    }
}

// @alpha
export abstract class TileAdmin {
    // @internal (undocumented)
    abstract get contextPreloadParentDepth(): number;
    // @internal (undocumented)
    abstract get contextPreloadParentSkip(): number;
    // @beta
    static create(props?: TileAdmin.Props): TileAdmin;
    abstract get defaultTileSizeModifier(): number;
    abstract set defaultTileSizeModifier(modifier: number);
    // @internal (undocumented)
    abstract get disableMagnification(): boolean;
    // @internal (undocumented)
    abstract get emptyViewportSet(): TileAdmin.ViewportSet;
    // @internal (undocumented)
    abstract get enableImprovedElision(): boolean;
    // @internal (undocumented)
    abstract get enableInstancing(): boolean;
    // @internal
    abstract forgetViewport(vp: Viewport): void;
    // @internal
    abstract getMaximumMajorTileFormatVersion(formatVersion?: number): number;
    abstract getNumRequestsForViewport(vp: Viewport): number;
    // @internal
    abstract getRequestsForViewport(vp: Viewport): Set<Tile> | undefined;
    // @internal
    abstract getViewportSet(vp: Viewport, vps?: TileAdmin.ViewportSet): TileAdmin.ViewportSet;
    abstract get maxActiveRequests(): number;
    abstract set maxActiveRequests(max: number);
    // @internal (undocumented)
    abstract get maximumMajorTileFormatVersion(): number;
    // @internal (undocumented)
    abstract onActiveRequestCanceled(tile: Tile): void;
    // @internal (undocumented)
    abstract onCacheMiss(): void;
    // @internal (undocumented)
    abstract onShutDown(): void;
    // @internal (undocumented)
    abstract onTileCompleted(tile: Tile): void;
    // @internal (undocumented)
    abstract onTileFailed(tile: Tile): void;
    // @internal (undocumented)
    abstract onTilesElided(numElided: number): void;
    // @internal (undocumented)
    abstract onTileTimedOut(tile: Tile): void;
    // @internal
    abstract process(): void;
    // @internal
    abstract purgeTileTrees(iModel: IModelConnection, modelIds: Id64Array | undefined): Promise<void>;
    // @internal (undocumented)
    abstract get realityTileExpirationTime(): BeDuration;
    // @internal (undocumented)
    abstract requestTileContent(iModel: IModelConnection, treeId: string, contentId: string, isCanceled: () => boolean, guid: string | undefined): Promise<Uint8Array>;
    // @internal
    abstract requestTiles(vp: Viewport, tiles: Set<Tile>): void;
    // @internal (undocumented)
    abstract requestTileTreeProps(iModel: IModelConnection, treeId: string): Promise<TileTreeProps>;
    abstract resetStatistics(): void;
    abstract get statistics(): TileAdmin.Statistics;
    // @internal (undocumented)
    abstract get tileExpirationTime(): BeDuration;
    // @internal (undocumented)
    abstract get tileTreeExpirationTime(): BeDuration | undefined;
    // @internal (undocumented)
    abstract get useProjectExtents(): boolean;
}

// @alpha (undocumented)
export namespace TileAdmin {
    export interface Props {
        // @internal
        cancelBackendTileRequests?: boolean;
        contextPreloadParentDepth?: number;
        contextPreloadParentSkip?: number;
        defaultTileSizeModifier?: number;
        disableMagnification?: boolean;
        enableImprovedElision?: boolean;
        enableInstancing?: boolean;
        maxActiveRequests?: number;
        // @internal
        maximumMajorTileFormatVersion?: number;
        // @internal
        realityTileExpirationTime?: number;
        retryInterval?: number;
        tileExpirationTime?: number;
        tileTreeExpirationTime?: number;
        // @internal
        useProjectExtents?: boolean;
    }
    export interface Statistics {
        numActiveRequests: number;
        numCanceled: number;
        numPendingRequests: number;
        totalAbortedRequests: number;
        totalCacheMisses: number;
        totalCompletedRequests: number;
        totalDispatchedRequests: number;
        totalElidedTiles: number;
        totalEmptyTiles: number;
        totalFailedRequests: number;
        totalTimedOutRequests: number;
        totalUndisplayableTiles: number;
    }
    // @internal
    export class ViewportSet extends SortedArray<Viewport> {
        constructor(vp?: Viewport);
        // (undocumented)
        clone(out?: ViewportSet): ViewportSet;
    }
}

// @internal
export interface TiledGraphicsProvider {
    forEachTileTreeRef(viewport: Viewport, func: (ref: TileTreeReference) => void): void;
}

// @internal
export abstract class TileLoader {
    // (undocumented)
    adjustContentIdSizeMultiplier(contentId: string, _sizeMultiplier: number): string;
    // (undocumented)
    protected get _batchType(): BatchType;
    // (undocumented)
    static computeTileClosestToEyePriority(tile: Tile, viewports: Iterable<Viewport>): number;
    // (undocumented)
    computeTilePriority(tile: Tile, _viewports: Iterable<Viewport>): number;
    // (undocumented)
    get containsPointClouds(): boolean;
    // (undocumented)
    get drawAsRealityTiles(): boolean;
    // (undocumented)
    forceTileLoad(_tile: Tile): boolean;
    // (undocumented)
    getBatchIdMap(): BatchedTileIdMap | undefined;
    // (undocumented)
    abstract getChildrenProps(parent: Tile): Promise<TileProps[]>;
    // (undocumented)
    get isContentUnbounded(): boolean;
    // (undocumented)
    protected get _loadEdges(): boolean;
    // (undocumented)
    loadTileContent(tile: Tile, data: TileRequest.ResponseData, isCanceled?: () => boolean): Promise<Tile.Content>;
    // (undocumented)
    loadTileContentFromStream(tile: Tile, streamBuffer: ByteStream, isCanceled?: () => boolean): Promise<Tile.Content>;
    // (undocumented)
    abstract get maxDepth(): number;
    // (undocumented)
    onActiveRequestCanceled(_tile: Tile): void;
    // (undocumented)
    get parentsAndChildrenExclusive(): boolean;
    // (undocumented)
    get preloadRealityParentDepth(): number;
    // (undocumented)
    get preloadRealityParentSkip(): number;
    // (undocumented)
    abstract get priority(): Tile.LoadPriority;
    // (undocumented)
    processSelectedTiles(selected: Tile[], _args: Tile.DrawArgs): Tile[];
    // (undocumented)
    abstract requestTileContent(tile: Tile, isCanceled: () => boolean): Promise<TileRequest.Response>;
    // (undocumented)
    abstract tileRequiresLoading(params: Tile.Params): boolean;
    // (undocumented)
    get viewFlagOverrides(): ViewFlag.Overrides;
}

// @internal
export class TileRequest {
    constructor(tile: Tile, vp: Viewport);
    // (undocumented)
    addViewport(vp: Viewport): void;
    cancel(): void;
    dispatch(onHttpResponse: () => void): Promise<void>;
    // (undocumented)
    get isCanceled(): boolean;
    // (undocumented)
    get isQueued(): boolean;
    // (undocumented)
    get loader(): TileLoader;
    // (undocumented)
    priority: number;
    // (undocumented)
    get state(): TileRequest.State;
    readonly tile: Tile;
    // (undocumented)
    get tree(): TileTree;
    viewports: TileAdmin.ViewportSet;
}

// @internal (undocumented)
export namespace TileRequest {
    export type Response = Uint8Array | ArrayBuffer | string | ImageSource | undefined;
    export type ResponseData = Uint8Array | ImageSource;
    export const enum State {
        Completed = 3,
        Dispatched = 1,
        Failed = 4,
        Loading = 2,
        Queued = 0
    }
}

// @internal
export class TileTree implements IDisposable, RenderMemory.Consumer {
    constructor(props: TileTree.Params);
    // (undocumented)
    accumulateTransformedRange(range: Range3d, matrix: Matrix4d, frustumPlanes?: FrustumPlanes): void;
    // (undocumented)
    get clipVector(): ClipVector | undefined;
    // (undocumented)
    clipVolume?: RenderClipVolume;
    // (undocumented)
    collectStatistics(stats: RenderMemory.Statistics): void;
    // (undocumented)
    computeTileRangeForFrustum(vp: Viewport): Range3d | undefined;
    // (undocumented)
    readonly contentRange?: ElementAlignedBox3d;
    // (undocumented)
    countTiles(): number;
    // (undocumented)
    createDrawArgs(context: SceneContext): Tile.DrawArgs;
    // (undocumented)
    debugForcedDepth?: number;
    // (undocumented)
    static debugMissingTiles: boolean;
    // (undocumented)
    static debugSelectedRanges: boolean;
    // (undocumented)
    static debugSelectedTiles: boolean;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    draw(args: Tile.DrawArgs): void;
    // (undocumented)
    drawRealityTiles(args: Tile.DrawArgs): void;
    // (undocumented)
    drawScene(context: SceneContext): void;
    // (undocumented)
    expirationTime: BeDuration;
    // (undocumented)
    getTraversalChildren(depth: number): TraversalChildrenDetails;
    // (undocumented)
    readonly id: string;
    // (undocumented)
    readonly iModel: IModelConnection;
    // (undocumented)
    get is2d(): boolean;
    // (undocumented)
    readonly is3d: boolean;
    get lastSelectedTime(): BeTimePoint;
    // (undocumented)
    readonly loader: TileLoader;
    // (undocumented)
    readonly location: Transform;
    // (undocumented)
    readonly maxTilesToSkip: number;
    // (undocumented)
    readonly modelId: Id64String;
    // (undocumented)
    get range(): ElementAlignedBox3d;
    // (undocumented)
    get rootTile(): Tile;
    // (undocumented)
    protected _rootTile: Tile;
    // (undocumented)
    selectRealityTiles(args: Tile.DrawArgs, displayedDescendants: Tile[][]): Tile[];
    // (undocumented)
    selectTiles(args: Tile.DrawArgs): Tile[];
    // (undocumented)
    selectTilesForScene(context: SceneContext): Tile[];
    // (undocumented)
    traversalChildrenByDepth: TraversalChildrenDetails[];
    // (undocumented)
    readonly viewFlagOverrides: ViewFlag.Overrides;
    // (undocumented)
    readonly yAxisUp: boolean;
}

// @internal
export namespace TileTree {
    export enum GraphicType {
        BackgroundMap = 0,
        Overlay = 2,
        Scene = 1
    }
    // (undocumented)
    export enum LoadStatus {
        // (undocumented)
        Loaded = 2,
        // (undocumented)
        Loading = 1,
        // (undocumented)
        NotFound = 3,
        // (undocumented)
        NotLoaded = 0
    }
    export interface Owner {
        dispose(): void;
        load(): TileTree | undefined;
        readonly loadStatus: TileTree.LoadStatus;
        loadTree(): Promise<TileTree | undefined>;
        readonly tileTree: TileTree | undefined;
    }
    export interface Params {
        // (undocumented)
        readonly clipVector?: ClipVector;
        // (undocumented)
        readonly contentRange?: ElementAlignedBox3d;
        // (undocumented)
        readonly id: string;
        // (undocumented)
        readonly iModel: IModelConnection;
        // (undocumented)
        readonly is3d: boolean;
        // (undocumented)
        readonly loader: TileLoader;
        // (undocumented)
        readonly location: Transform;
        // (undocumented)
        readonly maxTilesToSkip?: number;
        // (undocumented)
        readonly modelId: Id64String;
        // (undocumented)
        readonly rootTile: TileProps;
        // (undocumented)
        readonly yAxisUp?: boolean;
    }
    export function paramsFromJSON(props: TileTreeProps, iModel: IModelConnection, is3d: boolean, loader: TileLoader, modelId: Id64String): Params;
    export interface Supplier {
        compareTileTreeIds(lhs: any, rhs: any): number;
        createTileTree(id: any, iModel: IModelConnection): Promise<TileTree | undefined>;
    }
}

// @internal (undocumented)
export interface TileTreeDiscloser {
    // (undocumented)
    discloseTileTrees: (trees: TileTreeSet) => void;
}

// @internal
export abstract class TileTreeReference implements RenderMemory.Consumer {
    // (undocumented)
    addPlanes(_planes: Plane3dByOriginAndUnitNormal[]): void;
    addToScene(context: SceneContext): void;
    // (undocumented)
    collectStatistics(stats: RenderMemory.Statistics): void;
    decorate(_context: DecorateContext): void;
    discloseTileTrees(trees: TileTreeSet): void;
    getToolTip(_hit: HitDetail): HTMLElement | string | undefined;
    abstract get treeOwner(): TileTree.Owner;
    unionFitRange(union: Range3d): void;
}

// @internal
export class TileTreeSet {
    // (undocumented)
    add(tree: TileTree): void;
    // (undocumented)
    disclose(discloser: TileTreeDiscloser): void;
    // (undocumented)
    get size(): number;
    // (undocumented)
    readonly trees: Set<TileTree>;
}

// @public
export class Tool {
    constructor(..._args: any[]);
    static get description(): string;
    get description(): string;
    static get englishKeyin(): string;
    static get flyover(): string;
    get flyover(): string;
    static hidden: boolean;
    static i18n: I18N;
    static iconSpec: string;
    get iconSpec(): string;
    static get keyin(): string;
    get keyin(): string;
    // @beta
    static get maxArgs(): number | undefined;
    // @beta
    static get minArgs(): number;
    static namespace: I18NNamespace;
    // @beta
    parseAndRun(..._args: string[]): boolean;
    static register(namespace?: I18NNamespace, i18n?: I18N): void;
    run(..._args: any[]): boolean;
    static toolId: string;
    get toolId(): string;
}

// @public
export class ToolAdmin {
    acsContextLock: boolean;
    acsPlaneSnapLock: boolean;
    get activeTool(): InteractiveTool | undefined;
    readonly activeToolChanged: BeEvent<(tool: Tool, start: StartOrResume) => void>;
    // @internal
    static addEvent(ev: Event, vp?: ScreenViewport): void;
    // (undocumented)
    adjustPoint(pointActive: Point3d, vp: ScreenViewport, projectToACS?: boolean, applyLocks?: boolean): void;
    // (undocumented)
    adjustPointToACS(pointActive: Point3d, vp: Viewport, perpendicular: boolean): void;
    // (undocumented)
    adjustPointToGrid(pointActive: Point3d, vp: Viewport): void;
    // (undocumented)
    adjustSnapPoint(perpendicular?: boolean): void;
    assemblyLock: boolean;
    // @internal (undocumented)
    beginDynamics(): void;
    // @internal (undocumented)
    callOnCleanup(): void;
    convertTouchEndToButtonUp(ev: BeTouchEvent, button?: BeButton): Promise<void>;
    convertTouchMoveStartToButtonDownAndMotion(startEv: BeTouchEvent, ev: BeTouchEvent, button?: BeButton): Promise<void>;
    convertTouchMoveToMotion(ev: BeTouchEvent): Promise<void>;
    convertTouchStartToButtonDown(ev: BeTouchEvent, button?: BeButton): Promise<void>;
    convertTouchTapToButtonDownAndUp(ev: BeTouchEvent, button?: BeButton): Promise<void>;
    // @internal (undocumented)
    readonly currentInputState: CurrentInputState;
    get currentTool(): InteractiveTool;
    get cursorView(): ScreenViewport | undefined;
    // @internal (undocumented)
    decorate(context: DecorateContext): void;
    // @internal
    get defaultToolArgs(): any[] | undefined;
    set defaultToolArgs(args: any[] | undefined);
    // @internal
    get defaultToolId(): string;
    set defaultToolId(toolId: string);
    doRedoOperation(): Promise<boolean>;
    doUndoOperation(): Promise<boolean>;
    // @internal (undocumented)
    endDynamics(): void;
    // @beta
    static exceptionHandler(exception: any): Promise<any>;
    // @beta
    static exceptionOptions: {
        log: boolean;
        alertBox: boolean;
        details: boolean;
        launchDebugger: boolean;
    };
    // @internal (undocumented)
    exitInputCollector(): void;
    // @internal (undocumented)
    exitViewTool(): void;
    // @internal (undocumented)
    fillEventFromCursorLocation(ev: BeButtonEvent): void;
    // @internal (undocumented)
    fillEventFromLastDataButton(ev: BeButtonEvent): void;
    protected filterViewport(vp: ScreenViewport): boolean;
    // @internal
    forgetViewport(vp: ScreenViewport): void;
    // @internal (undocumented)
    getDecorationGeometry(hit: HitDetail): GeometryStreamProps | undefined;
    getToolTip(hit: HitDetail): Promise<HTMLElement | string>;
    gridLock: boolean;
    get idleTool(): IdleTool;
    // (undocumented)
    get isLocateCircleOn(): boolean;
    // @alpha
    readonly manipulatorToolEvent: BeEvent<(tool: Tool, event: ManipulatorToolEvent) => void>;
    // (undocumented)
    markupView?: ScreenViewport;
    // @internal (undocumented)
    onInitialized(): void;
    // @internal (undocumented)
    onInstallTool(tool: InteractiveTool): boolean;
    // @internal (undocumented)
    onMouseLeave(vp: ScreenViewport): void;
    // @internal (undocumented)
    onPostInstallTool(tool: InteractiveTool): void;
    // @internal (undocumented)
    onSelectedViewportChanged(previous: ScreenViewport | undefined, current: ScreenViewport | undefined): void;
    // @internal (undocumented)
    onShutDown(): void;
    // (undocumented)
    get primitiveTool(): PrimitiveTool | undefined;
    // @internal
    processEvent(): Promise<void>;
    processWheelEvent(ev: BeWheelEvent, doUpdate: boolean): Promise<EventHandled>;
    // @internal (undocumented)
    sendButtonEvent(ev: BeButtonEvent): Promise<any>;
    // (undocumented)
    sendEndDragEvent(ev: BeButtonEvent): Promise<any>;
    // @internal (undocumented)
    setAdjustedDataPoint(ev: BeButtonEvent): void;
    // (undocumented)
    setCursor(cursor: string | undefined): void;
    // @internal (undocumented)
    setIncompatibleViewportCursor(restore: boolean): void;
    // @internal (undocumented)
    setInputCollector(newTool?: InputCollector): void;
    // (undocumented)
    setLocateCircleOn(locateOn: boolean): void;
    // (undocumented)
    setLocateCursor(enableLocate: boolean): void;
    // @internal (undocumented)
    setPrimitiveTool(newTool?: PrimitiveTool): void;
    // @internal (undocumented)
    setViewTool(newTool?: ViewTool): void;
    // @internal
    startDefaultTool(): void;
    // @internal (undocumented)
    startInputCollector(newTool: InputCollector): void;
    // @internal (undocumented)
    startPrimitiveTool(newTool?: PrimitiveTool): void;
    // @internal (undocumented)
    startViewTool(newTool: ViewTool): void;
    // @beta
    syncToolSettingsProperties(toolId: string, syncProperties: ToolSettingsPropertySyncItem[]): void;
    // @internal (undocumented)
    testDecorationHit(id: string): boolean;
    // @internal
    get toolSettingsChangeHandler(): ((toolId: string, syncProperties: ToolSettingsPropertySyncItem[]) => void) | undefined;
    set toolSettingsChangeHandler(handler: ((toolId: string, syncProperties: ToolSettingsPropertySyncItem[]) => void) | undefined);
    // @internal (undocumented)
    readonly toolSettingsState: ToolSettingsState;
    // @internal (undocumented)
    readonly toolState: ToolState;
    // @internal (undocumented)
    updateDynamics(ev?: BeButtonEvent, useLastData?: boolean, adjustPoint?: boolean): void;
    // (undocumented)
    get viewTool(): ViewTool | undefined;
    }

// @beta
export class ToolAssistance {
    static get altKey(): string;
    static get altKeyboardInfo(): ToolAssistanceKeyboardInfo;
    static readonly altSymbol: string;
    static get altSymbolKeyboardInfo(): ToolAssistanceKeyboardInfo;
    static readonly arrowKeyboardInfo: ToolAssistanceKeyboardInfo;
    static createInstruction(image: string | ToolAssistanceImage, text: string, isNew?: boolean, inputMethod?: ToolAssistanceInputMethod, keyboardInfo?: ToolAssistanceKeyboardInfo): ToolAssistanceInstruction;
    static createInstructions(mainInstruction: ToolAssistanceInstruction, sections?: ToolAssistanceSection[]): ToolAssistanceInstructions;
    static createKeyboardInfo(keys: string[], bottomKeys?: string[]): ToolAssistanceKeyboardInfo;
    static createKeyboardInstruction(keyboardInfo: ToolAssistanceKeyboardInfo, text: string, isNew?: boolean, inputMethod?: ToolAssistanceInputMethod): ToolAssistanceInstruction;
    static createModifierKeyInstruction(modifierKey: string, image: string | ToolAssistanceImage, text: string, isNew?: boolean, inputMethod?: ToolAssistanceInputMethod): ToolAssistanceInstruction;
    static createSection(instructions: ToolAssistanceInstruction[], label?: string): ToolAssistanceSection;
    static createTouchCursorInstructions(instructions: ToolAssistanceInstruction[]): boolean;
    static get ctrlKey(): string;
    static get ctrlKeyboardInfo(): ToolAssistanceKeyboardInfo;
    static readonly ctrlSymbol: string;
    static get ctrlSymbolKeyboardInfo(): ToolAssistanceKeyboardInfo;
    static readonly downSymbol: string;
    static get inputsLabel(): string;
    static readonly leftSymbol: string;
    static readonly rightSymbol: string;
    static get shiftKey(): string;
    static get shiftKeyboardInfo(): ToolAssistanceKeyboardInfo;
    static get shiftKeyboardInfoNoSymbol(): ToolAssistanceKeyboardInfo;
    static readonly shiftSymbol: string;
    static get shiftSymbolKeyboardInfo(): ToolAssistanceKeyboardInfo;
    static readonly upSymbol: string;
}

// @beta
export enum ToolAssistanceImage {
    AcceptPoint = 1,
    CursorClick = 2,
    Keyboard = 0,
    LeftClick = 3,
    LeftClickDrag = 6,
    MouseWheel = 5,
    MouseWheelClickDrag = 8,
    OneTouchDoubleTap = 10,
    OneTouchDrag = 11,
    OneTouchTap = 9,
    RightClick = 4,
    RightClickDrag = 7,
    TouchCursorDrag = 16,
    TouchCursorTap = 15,
    TwoTouchDrag = 13,
    TwoTouchPinch = 14,
    TwoTouchTap = 12
}

// @beta
export enum ToolAssistanceInputMethod {
    Both = 0,
    Mouse = 1,
    Touch = 2
}

// @beta
export interface ToolAssistanceInstruction {
    image: string | ToolAssistanceImage;
    inputMethod?: ToolAssistanceInputMethod;
    isNew?: boolean;
    keyboardInfo?: ToolAssistanceKeyboardInfo;
    text: string;
}

// @beta
export interface ToolAssistanceInstructions {
    mainInstruction: ToolAssistanceInstruction;
    sections?: ToolAssistanceSection[];
}

// @beta
export interface ToolAssistanceKeyboardInfo {
    bottomKeys?: string[];
    keys: string[];
}

// @beta
export interface ToolAssistanceSection {
    instructions: ToolAssistanceInstruction[];
    label?: string;
}

// @public (undocumented)
export type ToolList = ToolType[];

// @public
export class ToolRegistry {
    create(toolId: string, ...args: any[]): Tool | undefined;
    find(toolId: string): ToolType | undefined;
    // @internal
    findExactMatch(keyin: string): ToolType | undefined;
    // @internal
    findPartialMatches(keyin: string): FuzzySearchResults<ToolType>;
    getToolList(): ToolList;
    register(toolClass: ToolType, namespace?: I18NNamespace, i18n?: I18N): void;
    registerModule(moduleObj: any, namespace?: I18NNamespace, i18n?: I18N): void;
    run(toolId: string, ...args: any[]): boolean;
    // (undocumented)
    readonly tools: Map<string, typeof Tool>;
    unRegister(toolId: string): void;
}

// @public
export class ToolSettings {
    // @deprecated (undocumented)
    static get animationTime(): BeDuration;
    static set animationTime(val: BeDuration);
    static doubleClickTimeout: BeDuration;
    static doubleClickToleranceInches: number;
    static doubleTapTimeout: BeDuration;
    static preserveWorldUp: boolean;
    static scrollSpeed: number;
    static startDragDelay: BeDuration;
    static startDragDistanceInches: number;
    static touchMoveDelay: BeDuration;
    static touchMoveDistanceInches: number;
    static touchZoomChangeThresholdInches: number;
    static viewingInertia: {
        enabled: boolean;
        damping: number;
        duration: BeDuration;
    };
    static viewToolPickRadiusInches: number;
    static walkCameraAngle: Angle;
    static walkEnforceZUp: boolean;
    static walkRequestPointerLock: boolean;
    static walkVelocity: number;
    static wheelLineFactor: number;
    static wheelPageFactor: number;
    static wheelZoomBumpDistance: number;
    static wheelZoomRatio: number;
    static zoomSpeed: number;
}

// @beta
export class ToolSettingsPropertyItem {
    constructor(value: ToolSettingsValue, propertyName: string);
    // (undocumented)
    propertyName: string;
    // (undocumented)
    value: ToolSettingsValue;
}

// @beta
export class ToolSettingsPropertyRecord extends PropertyRecord {
    constructor(value: PropertyValue, property: PropertyDescription, editorPosition: EditorPosition, isReadonly?: boolean, lockProperty?: PropertyRecord);
    // (undocumented)
    static clone(record: ToolSettingsPropertyRecord, newValue?: ToolSettingsValue): ToolSettingsPropertyRecord;
    // (undocumented)
    editorPosition: EditorPosition;
    // (undocumented)
    lockProperty?: PropertyRecord;
}

// @beta
export class ToolSettingsPropertySyncItem extends ToolSettingsPropertyItem {
    constructor(value: ToolSettingsValue, propertyName: string, isDisabled?: boolean);
    isDisabled?: boolean;
}

// @internal
export class ToolSettingsState {
    initializeToolSettingProperties(toolId: string, tsProps: ToolSettingsPropertyItem[]): void;
    initializeToolSettingProperty(toolId: string, item: ToolSettingsPropertyItem): void;
    saveToolSettingProperties(toolId: string, tsProps: ToolSettingsPropertyItem[]): void;
    saveToolSettingProperty(toolId: string, item: ToolSettingsPropertyItem): void;
}

// @beta
export class ToolSettingsValue implements PrimitiveValue {
    constructor(value?: number | string | boolean | Date, displayValue?: string);
    // (undocumented)
    clone(): ToolSettingsValue;
    // (undocumented)
    displayValue?: string;
    // (undocumented)
    get hasDisplayValue(): boolean;
    // (undocumented)
    get isNullValue(): boolean;
    // (undocumented)
    update(newValue: ToolSettingsValue): boolean;
    // (undocumented)
    value?: number | string | boolean | Date;
    // (undocumented)
    readonly valueFormat = PropertyValueFormat.Primitive;
}

// @internal (undocumented)
export class ToolState {
    // (undocumented)
    clone(): ToolState;
    // (undocumented)
    coordLockOvr: CoordinateLockOverrides;
    // (undocumented)
    locateCircleOn: boolean;
    // (undocumented)
    setFrom(other: ToolState): void;
}

// @public
export interface ToolTipOptions {
    // (undocumented)
    duration?: BeDuration;
    // (undocumented)
    placement?: string;
}

// @internal
export interface ToolTipProvider {
    augmentToolTip(hit: HitDetail, tooltip: Promise<HTMLElement | string>): Promise<HTMLElement | string>;
}

// @public (undocumented)
export type ToolType = typeof Tool;

// @internal
export class TouchCursor implements CanvasDecoration {
    protected constructor(vp: ScreenViewport);
    // (undocumented)
    static createFromTouchTap(ev: BeTouchEvent): TouchCursor | undefined;
    // (undocumented)
    doTouchEnd(ev: BeTouchEvent): void;
    // (undocumented)
    doTouchMove(ev: BeTouchEvent): boolean;
    // (undocumented)
    doTouchMoveStart(ev: BeTouchEvent, startEv: BeTouchEvent): boolean;
    // (undocumented)
    doTouchStart(ev: BeTouchEvent): void;
    // (undocumented)
    doTouchTap(ev: BeTouchEvent): Promise<boolean>;
    // (undocumented)
    drawDecoration(ctx: CanvasRenderingContext2D): void;
    // (undocumented)
    protected drawHandle(ctx: CanvasRenderingContext2D, filled: boolean): void;
    // (undocumented)
    protected _inTouchTap: boolean;
    // (undocumented)
    isButtonHandled(ev: BeButtonEvent): boolean;
    // (undocumented)
    protected _isDragging: boolean;
    // (undocumented)
    protected isSelected(pt: XAndY): boolean;
    // (undocumented)
    protected _isSelected: boolean;
    // (undocumented)
    protected _offsetPosition: Point3d;
    // (undocumented)
    position: Point3d;
    // (undocumented)
    protected setPosition(vp: Viewport, worldLocation: Point3d): boolean;
    // (undocumented)
    protected _size: number;
    // (undocumented)
    protected _yOffset: number;
}

// @internal (undocumented)
export class TraversalChildrenDetails {
    // (undocumented)
    combine(parentDetails: TraversalDetails): void;
    // (undocumented)
    getChildDetail(index: number): TraversalDetails;
    // (undocumented)
    initialize(): void;
}

// @internal (undocumented)
export class TraversalDetails {
    // (undocumented)
    childrenLoading: boolean;
    // (undocumented)
    initialize(): void;
    // (undocumented)
    queuedChildren: Tile[];
}

// @internal (undocumented)
export class TraversalSelectionContext {
    constructor(selected: Tile[], displayedDescendants: Tile[][]);
    // (undocumented)
    displayedDescendants: Tile[][];
    // (undocumented)
    missing: Tile[];
    // (undocumented)
    preload(tile: Tile): void;
    // (undocumented)
    preloaded: Set<Tile>;
    // (undocumented)
    select(tiles: Tile[]): void;
    // (undocumented)
    selected: Tile[];
    // (undocumented)
    selectOrQueue(tile: Tile, traversalDetails: TraversalDetails): void;
}

// @alpha
export class TwoWayViewportSync {
    connect(view1: Viewport, view2: Viewport): void;
    disconnect(): void;
    }

// @internal
export enum UsesDragSelect {
    Box = 0,
    Line = 1,
    None = 2
}

// @internal
export enum UsesFence {
    Check = 0,
    None = 2,
    Required = 1
}

// @internal
export enum UsesSelection {
    Check = 0,
    None = 2,
    Required = 1
}

// @public
export interface ViewAnimationOptions {
    animationTime?: number;
    cancelOnAbort?: boolean;
    easingFunction?: EasingFunction;
}

// @public
export interface ViewChangeOptions extends ViewAnimationOptions {
    animateFrustumChange?: boolean;
    marginPercent?: MarginPercent;
    noSaveInUndo?: boolean;
}

// @alpha
export class ViewClipByElementTool extends ViewClipTool {
    constructor(clipEventHandler?: ViewClipEventHandler, _alwaysUseRange?: boolean);
    // (undocumented)
    protected _alwaysUseRange: boolean;
    // (undocumented)
    protected doClipToElements(viewport: Viewport, ids: Id64Arg, alwaysUseRange?: boolean): Promise<boolean>;
    // (undocumented)
    doClipToSelectedElements(viewport: Viewport): Promise<boolean>;
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onPostInstall(): void;
    // (undocumented)
    protected showPrompt(): void;
    // (undocumented)
    static toolId: string;
}

// @alpha
export class ViewClipByPlaneTool extends ViewClipTool {
    constructor(clipEventHandler?: ViewClipEventHandler, _clearExistingPlanes?: boolean);
    // (undocumented)
    applyToolSettingPropertyChange(updatedValue: ToolSettingsPropertySyncItem): boolean;
    // (undocumented)
    protected _clearExistingPlanes: boolean;
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    get orientation(): EditManipulator.RotationType;
    set orientation(option: EditManipulator.RotationType);
    // (undocumented)
    protected setupAndPromptForNextAction(): void;
    // (undocumented)
    protected showPrompt(): void;
    // (undocumented)
    supplyToolSettingsProperties(): ToolSettingsPropertyRecord[] | undefined;
    // (undocumented)
    static toolId: string;
}

// @alpha
export class ViewClipByRangeTool extends ViewClipTool {
    // (undocumented)
    protected _corner?: Point3d;
    // (undocumented)
    decorate(context: DecorateContext): void;
    // (undocumented)
    protected getClipRange(range: Range3d, transform: Transform, ev: BeButtonEvent): boolean;
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onMouseMotion(ev: BeButtonEvent): Promise<void>;
    // (undocumented)
    onUndoPreviousStep(): Promise<boolean>;
    // (undocumented)
    protected setupAndPromptForNextAction(): void;
    // (undocumented)
    protected showPrompt(): void;
    // (undocumented)
    static toolId: string;
}

// @alpha
export class ViewClipByShapeTool extends ViewClipTool {
    // (undocumented)
    applyToolSettingPropertyChange(updatedValue: ToolSettingsPropertySyncItem): boolean;
    // (undocumented)
    decorate(context: DecorateContext): void;
    // (undocumented)
    protected getClipPoints(ev: BeButtonEvent): Point3d[];
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    isValidLocation(ev: BeButtonEvent, isButtonEvent: boolean): boolean;
    // (undocumented)
    protected _matrix?: Matrix3d;
    // (undocumented)
    onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onKeyTransition(wentDown: boolean, keyEvent: KeyboardEvent): Promise<EventHandled>;
    // (undocumented)
    onMouseMotion(ev: BeButtonEvent): Promise<void>;
    // (undocumented)
    onUndoPreviousStep(): Promise<boolean>;
    // (undocumented)
    get orientation(): EditManipulator.RotationType;
    set orientation(option: EditManipulator.RotationType);
    // (undocumented)
    protected readonly _points: Point3d[];
    // (undocumented)
    protected setupAndPromptForNextAction(): void;
    // (undocumented)
    protected showPrompt(): void;
    // (undocumented)
    supplyToolSettingsProperties(): ToolSettingsPropertyRecord[] | undefined;
    // (undocumented)
    static toolId: string;
    // (undocumented)
    protected _zHigh?: number;
    // (undocumented)
    protected _zLow?: number;
}

// @alpha
export class ViewClipClearTool extends ViewClipTool {
    // (undocumented)
    protected doClipClear(viewport: Viewport): boolean;
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    isCompatibleViewport(vp: Viewport | undefined, isSelectedViewChange: boolean): boolean;
    // (undocumented)
    onDataButtonDown(_ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onPostInstall(): void;
    // (undocumented)
    protected showPrompt(): void;
    // (undocumented)
    static toolId: string;
}

// @alpha
export class ViewClipControlArrow {
    constructor(origin: Point3d, direction: Vector3d, sizeInches: number, fill?: ColorDef, outline?: ColorDef, name?: string);
    // (undocumented)
    direction: Vector3d;
    // (undocumented)
    fill?: ColorDef;
    // (undocumented)
    floatingOrigin?: Point3d;
    // (undocumented)
    name?: string;
    // (undocumented)
    origin: Point3d;
    // (undocumented)
    outline?: ColorDef;
    // (undocumented)
    sizeInches: number;
}

// @alpha
export class ViewClipDecoration extends EditManipulator.HandleProvider {
    constructor(_clipView: ScreenViewport, _clipEventHandler?: ViewClipEventHandler | undefined);
    // (undocumented)
    static clear(): void;
    // (undocumented)
    protected clearControls(): void;
    // (undocumented)
    protected _clip?: ClipVector;
    // (undocumented)
    protected _clipEventHandler?: ViewClipEventHandler | undefined;
    // (undocumented)
    get clipId(): string | undefined;
    // (undocumented)
    protected _clipId?: string;
    // (undocumented)
    protected _clipPlanes?: ConvexClipPlaneSet;
    // (undocumented)
    get clipPlaneSet(): ConvexClipPlaneSet | undefined;
    // (undocumented)
    protected _clipPlanesLoops?: GeometryQuery[];
    // (undocumented)
    protected _clipPlanesLoopsNoncontributing?: GeometryQuery[];
    // (undocumented)
    get clipShape(): ClipShape | undefined;
    // (undocumented)
    protected _clipShape?: ClipShape;
    // (undocumented)
    protected _clipShapeExtents?: Range1d;
    // (undocumented)
    protected _clipView: ScreenViewport;
    // (undocumented)
    protected _controlIds: string[];
    // (undocumented)
    protected _controls: ViewClipControlArrow[];
    // (undocumented)
    static create(vp: ScreenViewport, clipEventHandler?: ViewClipEventHandler): string | undefined;
    // (undocumented)
    protected createControls(): Promise<boolean>;
    // (undocumented)
    decorate(context: DecorateContext): void;
    // (undocumented)
    doClipPlaneClear(index: number): boolean;
    // (undocumented)
    doClipPlaneNegate(index: number): boolean;
    // (undocumented)
    doClipPlaneOrientView(index: number): boolean;
    // (undocumented)
    doClipShapeSetZExtents(extents: Range1d): boolean;
    // (undocumented)
    static get(vp: ScreenViewport): ViewClipDecoration | undefined;
    // (undocumented)
    getControlIndex(id: string): number;
    // (undocumented)
    getDecorationToolTip(hit: HitDetail): Promise<HTMLElement | string>;
    // (undocumented)
    isClipShapeAlignedWithWorldUp(extents?: Range1d): boolean;
    // (undocumented)
    protected modifyControls(hit: HitDetail, _ev: BeButtonEvent): boolean;
    // (undocumented)
    onManipulatorEvent(eventType: EditManipulator.EventType): void;
    // (undocumented)
    protected onRightClick(hit: HitDetail, ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    protected onTouchTap(hit: HitDetail, ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onViewClose(vp: ScreenViewport): void;
    // (undocumented)
    protected _removeViewCloseListener?: () => void;
    // (undocumented)
    protected stop(): void;
    // (undocumented)
    protected _suspendDecorator: boolean;
    // (undocumented)
    testDecorationHit(id: string): boolean;
    // (undocumented)
    static toggle(vp: ScreenViewport, clipEventHandler?: ViewClipEventHandler): string | undefined;
    // (undocumented)
    protected updateDecorationListener(_add: boolean): void;
}

// @alpha
export class ViewClipDecorationProvider implements ViewClipEventHandler {
    // (undocumented)
    static clear(): void;
    // (undocumented)
    clearDecorationOnDeselect: boolean;
    // (undocumented)
    clearOnDeselect(): boolean;
    // (undocumented)
    static create(): ViewClipDecorationProvider;
    get hasSettings(): boolean;
    // (undocumented)
    hideDecoration(): void;
    // (undocumented)
    onActivateClip(viewport: ScreenViewport, interactive: boolean): void;
    readonly onActiveClipChanged: BeEvent<(viewport: Viewport, eventType: ClipEventType, provider: ViewClipDecorationProvider) => void>;
    readonly onActiveClipRightClick: BeEvent<(hit: HitDetail, ev: BeButtonEvent, provider: ViewClipDecorationProvider) => void>;
    // (undocumented)
    onClearClip(viewport: ScreenViewport): void;
    // (undocumented)
    onModifyClip(viewport: ScreenViewport): void;
    // (undocumented)
    onNewClip(viewport: ScreenViewport): void;
    // (undocumented)
    onNewClipPlane(viewport: ScreenViewport): void;
    // (undocumented)
    onRightClick(hit: HitDetail, ev: BeButtonEvent): boolean;
    // (undocumented)
    selectDecorationOnCreate: boolean;
    // (undocumented)
    selectOnCreate(): boolean;
    get settings(): ViewClipSettingsProvider;
    // (undocumented)
    protected _settings?: ViewClipSettingsProvider;
    // (undocumented)
    showDecoration(vp: ScreenViewport): void;
    // (undocumented)
    toggleDecoration(vp: ScreenViewport): void;
}

// @alpha
export interface ViewClipEventHandler {
    // (undocumented)
    clearOnDeselect(): boolean;
    // (undocumented)
    onActivateClip(viewport: Viewport, interactive: boolean): void;
    // (undocumented)
    onClearClip(viewport: Viewport): void;
    // (undocumented)
    onModifyClip(viewport: Viewport): void;
    // (undocumented)
    onNewClip(viewport: Viewport): void;
    // (undocumented)
    onNewClipPlane(viewport: Viewport): void;
    // (undocumented)
    onRightClick(hit: HitDetail, ev: BeButtonEvent): boolean;
    // (undocumented)
    selectOnCreate(): boolean;
}

// @alpha
export abstract class ViewClipModifyTool extends EditManipulator.HandleTool {
    constructor(manipulator: EditManipulator.HandleProvider, clip: ClipVector, vp: Viewport, hitId: string, ids: string[], controls: ViewClipControlArrow[]);
    // (undocumented)
    protected accept(ev: BeButtonEvent): boolean;
    // (undocumented)
    protected _anchorIndex: number;
    // (undocumented)
    protected _clip: ClipVector;
    // (undocumented)
    protected _clipView: Viewport;
    // (undocumented)
    protected _controls: ViewClipControlArrow[];
    // (undocumented)
    protected _currentDistance: number;
    // (undocumented)
    decorate(context: DecorateContext): void;
    // (undocumented)
    protected drawAnchorOffset(context: DecorateContext, color: ColorDef, weight: number, transformFromClip?: Transform): void;
    // (undocumented)
    protected abstract drawViewClip(context: DecorateContext): void;
    // (undocumented)
    protected getOffsetValue(ev: BeButtonEvent, transformFromClip?: Transform): number | undefined;
    // (undocumented)
    protected _ids: string[];
    // (undocumented)
    protected init(): void;
    // (undocumented)
    onCleanup(): void;
    // (undocumented)
    onMouseMotion(ev: BeButtonEvent): Promise<void>;
    // (undocumented)
    protected _restoreClip: boolean;
    // (undocumented)
    protected abstract updateViewClip(ev: BeButtonEvent, isAccept: boolean): boolean;
    // (undocumented)
    protected _viewRange: Range3d;
}

// @alpha
export class ViewClipPlanesModifyTool extends ViewClipModifyTool {
    // (undocumented)
    protected drawViewClip(context: DecorateContext): void;
    // (undocumented)
    protected updateViewClip(ev: BeButtonEvent, _isAccept: boolean): boolean;
}

// @alpha
export class ViewClipSettingsProvider {
    constructor(_clipEventHandler?: ViewClipEventHandler | undefined);
    // (undocumented)
    activateSavedClip(viewport: Viewport, id: GuidString, shared: boolean, interactive?: boolean): Promise<SettingsStatus>;
    // (undocumented)
    activateSavedClipPlanes(viewport: Viewport, ids: GuidString[], shared: boolean[]): Promise<SettingsStatus>;
    // (undocumented)
    appSpecific: boolean;
    // (undocumented)
    areSavedClipPlanes(iModel: IModelConnection, ids: GuidString[], shared: boolean[]): Promise<boolean>;
    // @internal (undocumented)
    clearActiveClipId(viewport: Viewport): void;
    // @internal (undocumented)
    clearActiveClipIdAllViews(): void;
    // (undocumented)
    protected _clipEventHandler?: ViewClipEventHandler | undefined;
    // (undocumented)
    copyClip(iModel: IModelConnection, shared: boolean, existingId: GuidString, copyShared: boolean, name?: string): Promise<GuidString | undefined>;
    // @internal (undocumented)
    protected deleteCachedSetting(iModel: IModelConnection, shared: boolean, existingId: GuidString): Promise<SettingsStatus>;
    // (undocumented)
    deleteClip(iModel: IModelConnection, shared: boolean, existingId: GuidString): Promise<SettingsStatus>;
    // @internal (undocumented)
    protected deleteSetting(iModel: IModelConnection, shared: boolean, existingId: GuidString): Promise<SettingsResult>;
    // (undocumented)
    getActiveClipId(viewport: Viewport): GuidString | undefined;
    // (undocumented)
    getActiveClipStatus(viewport: Viewport): ActiveClipStatus;
    // @internal (undocumented)
    protected getAllSettings(iModel: IModelConnection, shared: boolean): Promise<SettingsMapResult>;
    // @internal (undocumented)
    protected getCachedSetting(iModel: IModelConnection, shared: boolean, existingId: GuidString): Promise<SavedClipCache>;
    // (undocumented)
    getClip(iModel: IModelConnection, shared: boolean, existingId: GuidString): Promise<ClipVector | undefined>;
    // (undocumented)
    protected getiModelId(iModel: IModelConnection): string | undefined;
    // (undocumented)
    protected getProjectId(iModel: IModelConnection): string | undefined;
    // (undocumented)
    protected getRequestContext(): Promise<AuthorizedFrontendRequestContext>;
    // @internal (undocumented)
    protected getSetting(iModel: IModelConnection, shared: boolean, existingId: GuidString): Promise<SettingsResult>;
    // (undocumented)
    getSettings(settings: SavedClipEntry[], iModel: IModelConnection, shared?: boolean): Promise<SettingsStatus>;
    // @internal (undocumented)
    modifiedActiveClip(viewport: Viewport): boolean;
    // (undocumented)
    namespace: string;
    // @internal (undocumented)
    protected newCachedSetting(iModel: IModelConnection, shared: boolean, newId: GuidString, settings: SavedClipProps): Promise<SettingsStatus>;
    // (undocumented)
    newClip(iModel: IModelConnection, shared: boolean, clip: ClipVector, name?: string): Promise<GuidString | undefined>;
    // @internal (undocumented)
    protected purgeActiveClipIdCache(): void;
    // @internal (undocumented)
    protected renameCachedSetting(iModel: IModelConnection, shared: boolean, existingId: GuidString, name: string): Promise<SettingsStatus>;
    // (undocumented)
    renameClip(iModel: IModelConnection, shared: boolean, existingId: GuidString, name: string): Promise<SettingsStatus>;
    // (undocumented)
    replaceClip(iModel: IModelConnection, shared: boolean, existingId: GuidString, clip: ClipVector): Promise<SettingsStatus>;
    // (undocumented)
    saveActiveClip(viewport: Viewport, shared: boolean, name?: string): Promise<GuidString | undefined>;
    // @internal (undocumented)
    protected saveSetting(iModel: IModelConnection, shared: boolean, existingId: GuidString, settings: SavedClipProps): Promise<SettingsResult>;
    // @internal (undocumented)
    setActiveClipId(viewport: Viewport, existingId: GuidString): void;
    // @internal (undocumented)
    protected shareCachedSetting(iModel: IModelConnection, existingId: GuidString, newShared: boolean): Promise<SettingsStatus>;
    // (undocumented)
    shareClip(iModel: IModelConnection, existingId: GuidString, newShare: boolean): Promise<SettingsStatus>;
    // @internal (undocumented)
    protected updateCachedSetting(iModel: IModelConnection, shared: boolean, existingId: GuidString, settings: SavedClipProps): Promise<SettingsStatus>;
    // @internal (undocumented)
    protected validateActiveClipId(viewport: Viewport): void;
}

// @alpha
export class ViewClipShapeModifyTool extends ViewClipModifyTool {
    // (undocumented)
    protected drawViewClip(context: DecorateContext): void;
    // (undocumented)
    protected updateViewClip(ev: BeButtonEvent, _isAccept: boolean): boolean;
}

// @alpha
export class ViewClipTool extends PrimitiveTool {
    constructor(_clipEventHandler?: ViewClipEventHandler | undefined);
    // (undocumented)
    static addClipPlanesLoops(builder: GraphicBuilder, loops: GeometryQuery[], outline: boolean): void;
    // (undocumented)
    static areClipsEqual(clipA: ClipVector, clipB: ClipVector): boolean;
    // (undocumented)
    protected _clipEventHandler?: ViewClipEventHandler | undefined;
    // (undocumented)
    static doClipClear(viewport: Viewport): boolean;
    // (undocumented)
    static doClipToConvexClipPlaneSet(viewport: Viewport, planes: ConvexClipPlaneSet): boolean;
    // (undocumented)
    static doClipToPlane(viewport: Viewport, origin: Point3d, normal: Vector3d, clearExistingPlanes: boolean): boolean;
    // (undocumented)
    static doClipToRange(viewport: Viewport, range: Range3d, transform?: Transform): boolean;
    // (undocumented)
    static doClipToShape(viewport: Viewport, xyPoints: Point3d[], transform?: Transform, zLow?: number, zHigh?: number): boolean;
    // (undocumented)
    static drawClip(context: DecorateContext, clip: ClipVector, viewExtents?: Range3d, options?: DrawClipOptions): void;
    // (undocumented)
    static drawClipPlanesLoops(context: DecorateContext, loops: GeometryQuery[], color: ColorDef, weight: number, dashed?: boolean, fill?: ColorDef, id?: string): void;
    // (undocumented)
    static drawClipShape(context: DecorateContext, shape: ClipShape, extents: Range1d, color: ColorDef, weight: number, id?: string): void;
    // (undocumented)
    static enableClipVolume(viewport: Viewport): boolean;
    // (undocumented)
    protected static enumAsOrientationMessage(str: string): any;
    // (undocumented)
    static getClipRayTransformed(origin: Point3d, direction: Vector3d, transform?: Transform): Ray3d;
    // (undocumented)
    static getClipShapeExtents(shape: ClipShape, viewRange: Range3d): Range1d;
    // (undocumented)
    static getClipShapePoints(shape: ClipShape, z: number): Point3d[];
    // (undocumented)
    protected static _getEnumAsOrientationDescription: () => PropertyDescription;
    // (undocumented)
    static getOffsetValueTransformed(offset: number, transform?: Transform): number;
    // (undocumented)
    static getPlaneInwardNormal(orientation: EditManipulator.RotationType, viewport: Viewport): Vector3d | undefined;
    // (undocumented)
    static hasClip(viewport: Viewport): boolean;
    // (undocumented)
    isCompatibleViewport(vp: Viewport | undefined, isSelectedViewChange: boolean): boolean;
    // (undocumented)
    static isSingleClipPlane(clip: ClipVector): ClipPlane | undefined;
    // (undocumented)
    static isSingleClipShape(clip: ClipVector): ClipShape | undefined;
    // (undocumented)
    static isSingleConvexClipPlaneSet(clip: ClipVector): ConvexClipPlaneSet | undefined;
    // (undocumented)
    onPostInstall(): void;
    // (undocumented)
    onResetButtonUp(_ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onRestartTool(): void;
    // (undocumented)
    onUnsuspend(): void;
    // (undocumented)
    protected static _orientationName: string;
    // (undocumented)
    requireWriteableTarget(): boolean;
    // (undocumented)
    protected setupAndPromptForNextAction(): void;
    // (undocumented)
    static setViewClip(viewport: Viewport, clip?: ClipVector): boolean;
    // (undocumented)
    protected showPrompt(): void;
}

// @internal (undocumented)
export class ViewHandleArray {
    constructor(viewTool: ViewManip);
    // (undocumented)
    add(handle: ViewingToolHandle): void;
    // (undocumented)
    get count(): number;
    // (undocumented)
    drawHandles(context: DecorateContext): void;
    // (undocumented)
    empty(): void;
    // (undocumented)
    focus: number;
    // (undocumented)
    focusDrag: boolean;
    // (undocumented)
    get focusHandle(): ViewingToolHandle | undefined;
    // (undocumented)
    focusHitHandle(): void;
    // (undocumented)
    getByIndex(index: number): ViewingToolHandle | undefined;
    // (undocumented)
    handles: ViewingToolHandle[];
    hasHandle(handleType: ViewHandleType): boolean;
    // (undocumented)
    get hitHandle(): ViewingToolHandle | undefined;
    // (undocumented)
    hitHandleIndex: number;
    // (undocumented)
    motion(ev: BeButtonEvent): void;
    // (undocumented)
    onCleanup(): void;
    // (undocumented)
    onReinitialize(): void;
    // (undocumented)
    onWheel(ev: BeWheelEvent): void;
    // (undocumented)
    setFocus(index: number): void;
    // (undocumented)
    testHit(ptScreen: Point3d, forced?: ViewHandleType): boolean;
    // (undocumented)
    viewTool: ViewManip;
}

// @internal (undocumented)
export const enum ViewHandleType {
    // (undocumented)
    Fly = 64,
    // (undocumented)
    Look = 128,
    // (undocumented)
    LookAndMove = 256,
    // (undocumented)
    None = 0,
    // (undocumented)
    Pan = 4,
    // (undocumented)
    Rotate = 1,
    // (undocumented)
    Scroll = 8,
    // (undocumented)
    TargetCenter = 2,
    // (undocumented)
    Walk = 32,
    // (undocumented)
    Zoom = 16
}

// @internal
export class ViewingSpace {
    // (undocumented)
    static createFromViewport(vp: Viewport): ViewingSpace | undefined;
    // (undocumented)
    static createFromViewportAndPlane(vp: Viewport, plane: Plane3dByOriginAndUnitNormal): ViewingSpace | undefined;
    // (undocumented)
    fromViewOrientation(from: XYZ, to?: XYZ): void;
    // (undocumented)
    frustFraction: number;
    getFrustum(sys?: CoordSystem, adjustedBox?: boolean, box?: Frustum): Frustum;
    // (undocumented)
    getPixelSizeAtPoint(inPoint?: Point3d): number;
    // (undocumented)
    getViewCorners(): Range3d;
    static nearScaleLog24: number;
    static nearScaleNonLog24: number;
    npcToView(pt: Point3d, out?: Point3d): Point3d;
    npcToViewArray(pts: Point3d[]): void;
    npcToWorld(pt: XYAndZ, out?: Point3d): Point3d;
    npcToWorldArray(pts: Point3d[]): void;
    readonly rotation: Matrix3d;
    // (undocumented)
    toViewOrientation(from: XYZ, to?: XYZ): void;
    get view(): ViewState;
    set view(view: ViewState);
    view4dToWorld(input: Point4d, out?: Point3d): Point3d;
    view4dToWorldArray(viewPts: Point4d[], worldPts: Point3d[]): void;
    readonly viewDelta: Vector3d;
    readonly viewDeltaUnexpanded: Vector3d;
    readonly viewOrigin: Point3d;
    readonly viewOriginUnexpanded: Point3d;
    viewToNpc(pt: Point3d, out?: Point3d): Point3d;
    viewToNpcArray(pts: Point3d[]): void;
    viewToWorld(input: XYAndZ, out?: Point3d): Point3d;
    viewToWorldArray(pts: Point3d[]): void;
    worldToNpc(pt: XYAndZ, out?: Point3d): Point3d;
    worldToNpcArray(pts: Point3d[]): void;
    // (undocumented)
    readonly worldToNpcMap: Map4d;
    worldToView(input: XYAndZ, out?: Point3d): Point3d;
    worldToView4d(input: XYAndZ, out?: Point4d): Point4d;
    worldToView4dArray(worldPts: Point3d[], viewPts: Point4d[]): void;
    worldToViewArray(pts: Point3d[]): void;
    // (undocumented)
    readonly worldToViewMap: Map4d;
    // (undocumented)
    readonly zClipAdjusted: boolean;
}

// @internal (undocumented)
export abstract class ViewingToolHandle {
    constructor(viewTool: ViewManip);
    // (undocumented)
    adjustDepthPoint(isValid: boolean, _vp: Viewport, _plane: Plane3dByOriginAndUnitNormal, source: DepthPointSource): boolean;
    // (undocumented)
    protected changeFocusFromDepthPoint(): void;
    // (undocumented)
    checkOneShot(): boolean;
    // (undocumented)
    protected _depthPoint?: Point3d;
    // (undocumented)
    abstract doManipulation(ev: BeButtonEvent, inDynamics: boolean): boolean;
    // (undocumented)
    drawHandle(_context: DecorateContext, _hasFocus: boolean): void;
    // (undocumented)
    abstract firstPoint(ev: BeButtonEvent): boolean;
    // (undocumented)
    focusIn(): void;
    // (undocumented)
    focusOut(): void;
    // (undocumented)
    getHandleCursor(): string;
    // (undocumented)
    abstract get handleType(): ViewHandleType;
    // (undocumented)
    protected readonly _lastPtNpc: Point3d;
    // (undocumented)
    motion(_ev: BeButtonEvent): boolean;
    // (undocumented)
    needDepthPoint(_ev: BeButtonEvent, _isPreview: boolean): boolean;
    // (undocumented)
    onCleanup(): void;
    // (undocumented)
    onKeyTransition(_wentDown: boolean, _keyEvent: KeyboardEvent): boolean;
    // (undocumented)
    onModifierKeyTransition(_wentDown: boolean, _modifier: BeModifierKeys, _event: KeyboardEvent): boolean;
    // (undocumented)
    onReinitialize(): void;
    // (undocumented)
    onTouchCancel(_ev: BeTouchEvent): boolean;
    // (undocumented)
    onTouchComplete(_ev: BeTouchEvent): boolean;
    // (undocumented)
    onTouchEnd(_ev: BeTouchEvent): boolean;
    // (undocumented)
    onTouchMove(_ev: BeTouchEvent): boolean;
    // (undocumented)
    onTouchMoveStart(_ev: BeTouchEvent, _startEv: BeTouchEvent): boolean;
    // (undocumented)
    onTouchStart(_ev: BeTouchEvent): boolean;
    // (undocumented)
    onTouchTap(_ev: BeTouchEvent): boolean;
    // (undocumented)
    onWheel(_ev: BeWheelEvent): void;
    // (undocumented)
    protected pickDepthPoint(ev: BeButtonEvent): void;
    // (undocumented)
    abstract testHandleForHit(ptScreen: Point3d, out: {
        distance: number;
        priority: ViewManipPriority;
    }): boolean;
    // (undocumented)
    viewTool: ViewManip;
}

// @public
export class ViewManager {
    addDecorator(decorator: Decorator): () => void;
    // @internal
    addToolTipProvider(provider: ToolTipProvider): () => void;
    addViewport(newVp: ScreenViewport): BentleyStatus;
    // @internal (undocumented)
    beginDynamicsMode(): void;
    clearSelectedView(): void;
    // (undocumented)
    get crossHairCursor(): string;
    // (undocumented)
    cursor: string;
    // (undocumented)
    readonly decorators: Decorator[];
    // @internal (undocumented)
    get doesHostHaveFocus(): boolean;
    dropDecorator(decorator: Decorator): void;
    // @internal
    dropToolTipProvider(provider: ToolTipProvider): void;
    dropViewport(vp: ScreenViewport, disposeOfViewport?: boolean): BentleyStatus;
    // (undocumented)
    get dynamicsCursor(): string;
    // @internal (undocumented)
    endDynamicsMode(): void;
    forEachViewport(func: (vp: ScreenViewport) => void): void;
    // @internal
    getDecorationGeometry(hit: HitDetail): GeometryStreamProps | undefined;
    // @internal
    getDecorationToolTip(hit: HitDetail): Promise<HTMLElement | string>;
    // @beta
    getElementToolTip(hit: HitDetail): Promise<HTMLElement | string>;
    getFirstOpenView(): ScreenViewport | undefined;
    // (undocumented)
    get grabbingCursor(): string;
    // (undocumented)
    get grabCursor(): string;
    // (undocumented)
    inDynamicsMode: boolean;
    invalidateDecorationsAllViews(): void;
    // @internal (undocumented)
    invalidateScenes(): void;
    // @internal (undocumented)
    invalidateViewportScenes(): void;
    // (undocumented)
    get lookCursor(): string;
    // @internal (undocumented)
    notifySelectedViewportChanged(previous: ScreenViewport | undefined, current: ScreenViewport | undefined): void;
    readonly onBeginRender: BeEvent<() => void>;
    // @internal
    onDecorationButtonEvent(hit: HitDetail, ev: BeButtonEvent): Promise<EventHandled>;
    readonly onFinishRender: BeEvent<() => void>;
    // @internal (undocumented)
    onInitialized(): void;
    // @internal (undocumented)
    onNewTilesReady(): void;
    readonly onSelectedViewportChanged: BeUiEvent<SelectedViewportChangedArgs>;
    // @internal (undocumented)
    onSelectionSetChanged(_iModel: IModelConnection): void;
    // @internal (undocumented)
    onShutDown(): void;
    readonly onViewClose: BeUiEvent<ScreenViewport>;
    readonly onViewOpen: BeUiEvent<ScreenViewport>;
    readonly onViewResume: BeUiEvent<ScreenViewport>;
    readonly onViewSuspend: BeUiEvent<ScreenViewport>;
    // @internal
    purgeTileTrees(olderThan: BeTimePoint): void;
    // @internal
    refreshForModifiedModels(modelIds: Id64Arg | undefined): void;
    // @internal
    renderLoop(): void;
    // (undocumented)
    get rotateCursor(): string;
    // @internal (undocumented)
    get sceneInvalidated(): boolean;
    get selectedView(): ScreenViewport | undefined;
    setSelectedView(vp: ScreenViewport | undefined): BentleyStatus;
    setViewCursor(cursor?: string): void;
    // @internal (undocumented)
    readonly toolTipProviders: ToolTipProvider[];
    // @internal (undocumented)
    validateViewportScenes(): void;
    // (undocumented)
    get walkCursor(): string;
    // (undocumented)
    get zoomCursor(): string;
}

// @public
export abstract class ViewManip extends ViewTool {
    constructor(viewport: ScreenViewport | undefined, handleMask: number, oneShot: boolean, isDraggingRequired?: boolean);
    // (undocumented)
    changeViewport(vp?: ScreenViewport): void;
    // @internal (undocumented)
    clearDepthPoint(): boolean;
    // (undocumented)
    decorate(context: DecorateContext): void;
    // @internal (undocumented)
    protected _depthPreview?: {
        testPoint: Point3d;
        pickRadius: number;
        plane: Plane3dByOriginAndUnitNormal;
        source: DepthPointSource;
        isDefaultDepth: boolean;
        sourceId?: string;
    };
    // (undocumented)
    enforceZUp(pivotPoint: Point3d): boolean;
    // (undocumented)
    static fitView(viewport: ScreenViewport, animateFrustumChange: boolean, marginPercent?: MarginPercent): void;
    // @internal (undocumented)
    forcedHandle: ViewHandleType;
    // (undocumented)
    frustumValid: boolean;
    // (undocumented)
    static getDefaultTargetPointWorld(vp: Viewport): Point3d;
    // @internal (undocumented)
    getDepthPointGeometryId(): string | undefined;
    // (undocumented)
    static getFocusPlaneNpc(vp: Viewport): number;
    // (undocumented)
    handleMask: number;
    // (undocumented)
    inHandleModify: boolean;
    // (undocumented)
    isDragging: boolean;
    // (undocumented)
    isDraggingRequired: boolean;
    isPointVisible(testPt: Point3d): boolean;
    // (undocumented)
    get isZUp(): boolean;
    // (undocumented)
    lensAngleMatches(angle: Angle, tolerance: number): boolean;
    // (undocumented)
    nPts: number;
    // (undocumented)
    onCleanup(): void;
    // (undocumented)
    onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onDataButtonUp(_ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    oneShot: boolean;
    // (undocumented)
    onKeyTransition(wentDown: boolean, keyEvent: KeyboardEvent): Promise<EventHandled>;
    // (undocumented)
    onModifierKeyTransition(wentDown: boolean, modifier: BeModifierKeys, event: KeyboardEvent): Promise<EventHandled>;
    // (undocumented)
    onMouseEndDrag(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onMouseMotion(ev: BeButtonEvent): Promise<void>;
    // (undocumented)
    onMouseStartDrag(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onMouseWheel(inputEv: BeWheelEvent): Promise<EventHandled>;
    // (undocumented)
    onPostInstall(): void;
    // (undocumented)
    onReinitialize(): void;
    // (undocumented)
    onTouchCancel(ev: BeTouchEvent): Promise<void>;
    // (undocumented)
    onTouchComplete(ev: BeTouchEvent): Promise<void>;
    // (undocumented)
    onTouchEnd(ev: BeTouchEvent): Promise<void>;
    // (undocumented)
    onTouchMove(ev: BeTouchEvent): Promise<void>;
    // (undocumented)
    onTouchMoveStart(ev: BeTouchEvent, startEv: BeTouchEvent): Promise<EventHandled>;
    // (undocumented)
    onTouchStart(ev: BeTouchEvent): Promise<void>;
    // (undocumented)
    onTouchTap(ev: BeTouchEvent): Promise<EventHandled>;
    // @internal (undocumented)
    pickDepthPoint(ev: BeButtonEvent, isPreview?: boolean): Point3d | undefined;
    // @internal (undocumented)
    previewDepthPoint(context: DecorateContext): void;
    // (undocumented)
    processFirstPoint(ev: BeButtonEvent): boolean;
    // (undocumented)
    processPoint(ev: BeButtonEvent, inDynamics: boolean): boolean;
    // @beta (undocumented)
    provideToolAssistance(mainInstrKey: string, additionalInstr?: ToolAssistanceInstruction[]): void;
    // (undocumented)
    setCameraLensAngle(lensAngle: Angle, retainEyePoint: boolean): ViewStatus;
    setTargetCenterWorld(pt: Point3d, lockTarget: boolean, saveTarget: boolean): void;
    // @internal (undocumented)
    startHandleDrag(ev: BeButtonEvent, forcedHandle?: ViewHandleType): Promise<EventHandled>;
    // (undocumented)
    targetCenterLocked: boolean;
    // (undocumented)
    targetCenterValid: boolean;
    // (undocumented)
    readonly targetCenterWorld: Point3d;
    // (undocumented)
    updateTargetCenter(): void;
    // @internal (undocumented)
    viewHandles: ViewHandleArray;
    // (undocumented)
    static zoomToAlwaysDrawnExclusive(viewport: ScreenViewport, animateFrustumChange: boolean, marginPercent?: MarginPercent): Promise<boolean>;
}

// @public
export abstract class Viewport implements IDisposable {
    // @internal
    protected constructor(target: RenderTarget);
    // @internal (undocumented)
    protected addDecorations(_decorations: Decorations): void;
    // @internal
    addModelSubCategoryVisibilityOverrides(fs: FeatureSymbology.Overrides, ovrs: Id64.Uint32Map<Id64.Uint32Set>): void;
    // @internal (undocumented)
    addTiledGraphicsProvider(provider: TiledGraphicsProvider): void;
    addViewedModels(models: Id64Arg): Promise<void>;
    get alwaysDrawn(): Id64Set | undefined;
    // @internal (undocumented)
    get analysisStyle(): AnalysisStyle | undefined;
    // @internal
    applyViewState(val: ViewState): void;
    // (undocumented)
    get auxCoordSystem(): AuxCoordSystemState;
    // @internal (undocumented)
    get backgroundMapPlane(): Plane3dByOriginAndUnitNormal | undefined;
    // @beta
    get backgroundMapSettings(): BackgroundMapSettings;
    set backgroundMapSettings(settings: BackgroundMapSettings);
    // @beta
    changeBackgroundMapProps(props: BackgroundMapProps): void;
    changeCategoryDisplay(categories: Id64Arg, display: boolean, enableAllSubCategories?: boolean): void;
    // @internal (undocumented)
    changeDynamics(dynamics: GraphicList | undefined): void;
    // @internal (undocumented)
    protected _changeFlags: ChangeFlags;
    changeModelDisplay(models: Id64Arg, display: boolean): boolean;
    // @alpha
    changeSubCategoryDisplay(subCategoryId: Id64String, display: boolean): void;
    changeView(view: ViewState, _opts?: ViewChangeOptions): void;
    changeViewedModel2d(baseModelId: Id64String, options?: ChangeViewedModel2dOptions & ViewChangeOptions): Promise<void>;
    changeViewedModels(modelIds: Id64Arg): boolean;
    clearAlwaysDrawn(): void;
    clearNeverDrawn(): void;
    // @internal (undocumented)
    collectStatistics(stats: RenderMemory.Statistics): void;
    // @internal (undocumented)
    computeViewRange(): Range3d;
    get continuousRendering(): boolean;
    set continuousRendering(contRend: boolean);
    // @internal (undocumented)
    get controllerValid(): boolean;
    // @internal (undocumented)
    protected _controllerValid: boolean;
    // @internal (undocumented)
    createSceneContext(): SceneContext;
    // @beta
    cssPixelsToDevicePixels(cssPixels: number): number;
    // @internal
    get debugBoundingBoxes(): Tile.DebugBoundingBoxes;
    set debugBoundingBoxes(boxes: Tile.DebugBoundingBoxes);
    // @internal (undocumented)
    protected _decorationsValid: boolean;
    determineVisibleDepthRange(rect?: ViewRect, result?: DepthRangeNpc): DepthRangeNpc | undefined;
    // @beta
    get devicePixelRatio(): number;
    // @internal
    discloseTileTrees(trees: TileTreeSet): void;
    get displayStyle(): DisplayStyleState;
    set displayStyle(style: DisplayStyleState);
    // (undocumented)
    dispose(): void;
    dropSubCategoryOverride(id: Id64String): void;
    // @internal (undocumented)
    dropTiledGraphicsProvider(provider: TiledGraphicsProvider): void;
    // @beta
    get emphasisSettings(): Hilite.Settings;
    set emphasisSettings(settings: Hilite.Settings);
    get featureOverrideProvider(): FeatureOverrideProvider | undefined;
    set featureOverrideProvider(provider: FeatureOverrideProvider | undefined);
    // @internal
    flashDuration: number;
    // @internal
    flashIntensity: number;
    // @internal
    flashUpdateTime?: BeTimePoint;
    // @internal (undocumented)
    protected forEachTiledGraphicsProviderTree(func: (ref: TileTreeReference) => void): void;
    // @internal (undocumented)
    forEachTileTreeRef(func: (ref: TileTreeReference) => void): void;
    // @internal
    get freezeScene(): boolean;
    set freezeScene(freeze: boolean);
    // @internal (undocumented)
    fromViewOrientation(from: XYZ, to?: XYZ): void;
    // @internal (undocumented)
    get frustFraction(): number;
    // (undocumented)
    getAuxCoordOrigin(result?: Point3d): Point3d;
    // (undocumented)
    getAuxCoordRotation(result?: Matrix3d): Matrix3d;
    getContrastToBackgroundColor(): ColorDef;
    // @internal (undocumented)
    getDisplayedPlanes(): Plane3dByOriginAndUnitNormal[];
    getFrustum(sys?: CoordSystem, adjustedBox?: boolean, box?: Frustum): Frustum;
    // @beta
    getPixelDataNpcPoint(pixels: Pixel.Buffer, x: number, y: number, out?: Point3d): Point3d | undefined;
    // @beta
    getPixelDataWorldPoint(pixels: Pixel.Buffer, x: number, y: number, out?: Point3d): Point3d | undefined;
    getPixelSizeAtPoint(point?: Point3d): number;
    // @internal (undocumented)
    getSubCategories(categoryId: Id64String): Id64Set | undefined;
    getSubCategoryAppearance(id: Id64String): SubCategoryAppearance;
    getSubCategoryOverride(id: Id64String): SubCategoryOverride | undefined;
    // @internal (undocumented)
    getToolTip(hit: HitDetail): HTMLElement | string;
    getWorldFrustum(box?: Frustum): Frustum;
    // @internal (undocumented)
    hasTiledGraphicsProvider(provider: TiledGraphicsProvider): boolean;
    get hilite(): Hilite.Settings;
    set hilite(hilite: Hilite.Settings);
    get iModel(): IModelConnection;
    // @internal (undocumented)
    invalidateController(): void;
    // @beta
    invalidateDecorations(): void;
    // @internal (undocumented)
    invalidateRenderPlan(): void;
    // @internal (undocumented)
    invalidateScene(): void;
    // @internal (undocumented)
    protected _inViewChangedEvent: boolean;
    get isAlwaysDrawnExclusive(): boolean;
    // @internal (undocumented)
    get isAspectRatioLocked(): boolean;
    get isCameraOn(): boolean;
    // @internal (undocumented)
    get isContextRotationRequired(): boolean;
    get isDisposed(): boolean;
    get isFadeOutActive(): boolean;
    set isFadeOutActive(active: boolean);
    get isGridOn(): boolean;
    // @internal (undocumented)
    get isPointAdjustmentRequired(): boolean;
    // @internal (undocumented)
    get isSnapAdjustmentRequired(): boolean;
    isSubCategoryVisible(id: Id64String): boolean;
    // @internal
    lastFlashedElem?: string;
    // @internal (undocumented)
    markSelectionSetDirty(): void;
    get neverDrawn(): Id64Set | undefined;
    npcToView(pt: Point3d, out?: Point3d): Point3d;
    npcToViewArray(pts: Point3d[]): void;
    npcToWorld(pt: XYAndZ, out?: Point3d): Point3d;
    npcToWorldArray(pts: Point3d[]): void;
    numReadyTiles: number;
    get numRequestedTiles(): number;
    numSelectedTiles: number;
    // @beta
    readonly onAlwaysDrawnChanged: BeEvent<(vp: Viewport) => void>;
    // @beta
    readonly onChangeView: BeEvent<(vp: Viewport, previousViewState: ViewState) => void>;
    // @beta
    readonly onDisplayStyleChanged: BeEvent<(vp: Viewport) => void>;
    // @beta
    readonly onFeatureOverrideProviderChanged: BeEvent<(vp: Viewport) => void>;
    // @beta
    readonly onFeatureOverridesChanged: BeEvent<(vp: Viewport) => void>;
    // @beta
    readonly onNeverDrawnChanged: BeEvent<(vp: Viewport) => void>;
    readonly onRender: BeEvent<(vp: Viewport) => void>;
    readonly onViewChanged: BeEvent<(vp: Viewport) => void>;
    // @beta
    readonly onViewedCategoriesChanged: BeEvent<(vp: Viewport) => void>;
    // @beta
    readonly onViewedCategoriesPerModelChanged: BeEvent<(vp: Viewport) => void>;
    // @beta
    readonly onViewedModelsChanged: BeEvent<(vp: Viewport) => void>;
    // @beta
    readonly onViewportChanged: BeEvent<(vp: Viewport, changed: ChangeFlags) => void>;
    // @beta
    readonly onViewUndoRedo: BeEvent<(vp: Viewport, event: ViewUndoEvent) => void>;
    overrideSubCategory(id: Id64String, ovr: SubCategoryOverride): void;
    // @alpha
    get perModelCategoryVisibility(): PerModelCategoryVisibility.Overrides;
    pixelsFromInches(inches: number): number;
    // @internal (undocumented)
    get pixelsPerInch(): number;
    // @internal (undocumented)
    pointToGrid(point: Point3d): void;
    readImage(rect?: ViewRect, targetSize?: Point2d, flipVertically?: boolean): ImageBuffer | undefined;
    // @internal
    readImageToCanvas(): HTMLCanvasElement;
    // @beta
    readPixels(rect: ViewRect, selector: Pixel.Selector, receiver: Pixel.Receiver, excludeNonLocatable?: boolean): void;
    // @internal
    refreshForModifiedModels(modelIds: Id64Arg | undefined): void;
    // @internal (undocumented)
    renderFrame(): void;
    // @internal (undocumented)
    get renderPlanValid(): boolean;
    // @internal (undocumented)
    protected _renderPlanValid: boolean;
    replaceViewedModels(modelIds: Id64Arg): Promise<void>;
    get rotation(): Matrix3d;
    // @internal (undocumented)
    protected _sceneValid: boolean;
    // @internal (undocumented)
    get scheduleScriptFraction(): number;
    set scheduleScriptFraction(fraction: number);
    // @internal (undocumented)
    protected _scheduleScriptFractionValid: boolean;
    // @internal (undocumented)
    get scheduleTime(): number;
    scroll(screenDist: XAndY, options?: ViewChangeOptions): void;
    setAlwaysDrawn(ids: Id64Set, exclusive?: boolean): void;
    // @beta
    setAnimator(animator?: Animator): void;
    setFeatureOverrideProviderChanged(): void;
    // @internal
    setFlashed(id: string | undefined, duration: number): void;
    setNeverDrawn(ids: Id64Set): void;
    // @internal (undocumented)
    setRedrawPending(): void;
    // @internal (undocumented)
    setRenderPlanValid(): void;
    setStandardRotation(id: StandardViewId): void;
    // @alpha
    setTileSizeModifier(modifier: number | undefined): void;
    setupFromView(pose?: ViewPose): ViewStatus;
    setupViewFromFrustum(inFrustum: Frustum): boolean;
    // @internal (undocumented)
    setValidScene(): void;
    // @internal (undocumented)
    setViewedCategoriesPerModelChanged(): void;
    // @internal (undocumented)
    readonly subcategories: SubCategoriesCache.Queue;
    synchWithView(_options?: ViewChangeOptions | boolean): void;
    // @internal (undocumented)
    get target(): RenderTarget;
    // @alpha
    get tileSizeModifier(): number;
    // @internal (undocumented)
    toViewOrientation(from: XYZ, to?: XYZ): void;
    turnCameraOn(lensAngle?: Angle): ViewStatus;
    static undoDelay: BeDuration;
    protected updateChangeFlags(newView: ViewState): void;
    // @internal (undocumented)
    protected validateRenderPlan(): void;
    get view(): ViewState;
    view4dToWorld(input: Point4d, out?: Point3d): Point3d;
    view4dToWorldArray(viewPts: Point4d[], worldPts: Point3d[]): void;
    get viewDelta(): Vector3d;
    get viewFlags(): ViewFlags;
    set viewFlags(viewFlags: ViewFlags);
    // @internal (undocumented)
    get viewingSpace(): ViewingSpace;
    // @internal
    get viewportId(): number;
    // @internal (undocumented)
    protected readonly _viewRange: ViewRect;
    abstract get viewRect(): ViewRect;
    viewsModel(modelId: Id64String): boolean;
    viewToNpc(pt: Point3d, out?: Point3d): Point3d;
    viewToNpcArray(pts: Point3d[]): void;
    viewToWorld(input: XYAndZ, out?: Point3d): Point3d;
    viewToWorldArray(pts: Point3d[]): void;
    worldToNpc(pt: XYAndZ, out?: Point3d): Point3d;
    worldToNpcArray(pts: Point3d[]): void;
    worldToView(input: XYAndZ, out?: Point3d): Point3d;
    worldToView4d(input: XYAndZ, out?: Point4d): Point4d;
    worldToView4dArray(worldPts: Point3d[], viewPts: Point4d[]): void;
    worldToViewArray(pts: Point3d[]): void;
    get worldToViewMap(): Map4d;
    zoom(newCenter: Point3d | undefined, factor: number, options?: ViewChangeOptions): void;
    zoomToElementProps(elementProps: ElementProps[], options?: ViewChangeOptions & ZoomToOptions): void;
    zoomToElements(ids: Id64Arg, options?: ViewChangeOptions & ZoomToOptions): Promise<void>;
    zoomToPlacementProps(placementProps: PlacementProps[], options?: ViewChangeOptions & ZoomToOptions): void;
    zoomToVolume(volume: LowAndHighXYZ | LowAndHighXY, options?: ViewChangeOptions): void;
}

// @public
export abstract class ViewPose {
    constructor(cameraOn: boolean);
    // (undocumented)
    cameraOn: boolean;
    // (undocumented)
    get center(): Point3d;
    // (undocumented)
    abstract equal(other: ViewPose): boolean;
    // (undocumented)
    abstract equalState(view: ViewState): boolean;
    // (undocumented)
    abstract extents: Vector3d;
    // (undocumented)
    abstract origin: Point3d;
    // (undocumented)
    abstract rotation: Matrix3d;
    // (undocumented)
    get target(): Point3d;
    // (undocumented)
    undoTime?: BeTimePoint;
    // (undocumented)
    get zVec(): Vector3d;
}

// @internal (undocumented)
export class ViewPose2d extends ViewPose {
    constructor(view: ViewState2d);
    // (undocumented)
    readonly angle: Angle;
    // (undocumented)
    readonly delta: Point2d;
    // (undocumented)
    equal(other: ViewPose2d): boolean;
    // (undocumented)
    equalState(view: ViewState2d): boolean;
    // (undocumented)
    get extents(): Vector3d;
    // (undocumented)
    get origin(): Point3d;
    // (undocumented)
    readonly origin2: Point2d;
    // (undocumented)
    get rotation(): Matrix3d;
}

// @internal (undocumented)
export class ViewPose3d extends ViewPose {
    constructor(view: ViewState3d);
    // (undocumented)
    readonly camera: Camera;
    // (undocumented)
    equal(other: ViewPose3d): boolean;
    // (undocumented)
    equalState(view: ViewState3d): boolean;
    // (undocumented)
    readonly extents: Vector3d;
    // (undocumented)
    readonly origin: Point3d;
    // (undocumented)
    readonly rotation: Matrix3d;
    // (undocumented)
    get target(): Point3d;
}

// @public
export class ViewRect {
    constructor(left?: number, top?: number, right?: number, bottom?: number);
    get area(): number;
    get aspect(): number;
    get bottom(): number;
    set bottom(val: number);
    clone(result?: ViewRect): ViewRect;
    computeOverlap(other: ViewRect, out?: ViewRect): ViewRect | undefined;
    containsPoint(point: XAndY): boolean;
    equals(other: ViewRect): boolean;
    // (undocumented)
    extend(other: ViewRect): void;
    get height(): number;
    set height(height: number);
    init(left: number, top: number, right: number, bottom: number): void;
    initFromPoints(topLeft: XAndY, bottomRight: XAndY): void;
    initFromRange(input: LowAndHighXY): void;
    inset(deltaX: number, deltaY: number): void;
    insetByPercent(percent: number): void;
    insetUniform(offset: number): void;
    isContained(other: ViewRect): boolean;
    get isNull(): boolean;
    get isValid(): boolean;
    get left(): number;
    set left(val: number);
    overlaps(other: ViewRect): boolean;
    get right(): number;
    set right(val: number);
    scaleAboutCenter(xScale: number, yScale: number): void;
    setFrom(other: ViewRect): void;
    get top(): number;
    set top(val: number);
    get width(): number;
    set width(width: number);
}

// @public
export class ViewRedoTool extends ViewTool {
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    onPostInstall(): void;
    // (undocumented)
    static toolId: string;
}

// @public
export abstract class ViewState extends ElementState {
    // @internal
    protected constructor(props: ViewDefinitionProps, iModel: IModelConnection, categoryOrClone: CategorySelectorState, displayStyle: DisplayStyleState);
    abstract allow3dManipulations(): boolean;
    get analysisStyle(): AnalysisStyle | undefined;
    // @internal (undocumented)
    abstract applyPose(props: ViewPose): this;
    // @internal (undocumented)
    get areAllTileTreesLoaded(): boolean;
    get auxiliaryCoordinateSystem(): AuxCoordSystemState;
    get backgroundColor(): ColorDef;
    // (undocumented)
    calculateFocusCorners(): Point3d[];
    calculateFrustum(result?: Frustum): Frustum | undefined;
    categorySelector: CategorySelectorState;
    // @internal (undocumented)
    static get className(): string;
    abstract computeFitRange(): Range3d;
    // @internal (undocumented)
    computeWorldToNpc(viewRot?: Matrix3d, inOrigin?: Point3d, delta?: Vector3d, enforceFrontToBackRatio?: boolean): {
        map: Map4d | undefined;
        frustFraction: number;
    };
    // @internal (undocumented)
    abstract createAuxCoordSystem(acsName: string): AuxCoordSystemState;
    static createFromProps(_props: ViewStateProps, _iModel: IModelConnection): ViewState | undefined;
    // @internal (undocumented)
    createScene(context: SceneContext): void;
    // @internal
    decorate(context: DecorateContext): void;
    abstract get defaultExtentLimits(): ExtentLimits;
    // (undocumented)
    description?: string;
    // @internal
    discloseTileTrees(trees: TileTreeSet): void;
    displayStyle: DisplayStyleState;
    // @internal (undocumented)
    drawGrid(context: DecorateContext): void;
    equals(other: this): boolean;
    get extentLimits(): ExtentLimits;
    set extentLimits(limits: ExtentLimits);
    // @internal
    fixAspectRatio(windowAspect: number): void;
    abstract forEachModel(func: (model: GeometricModelState) => void): void;
    // @internal
    abstract forEachModelTreeRef(func: (treeRef: TileTreeReference) => void): void;
    // @internal (undocumented)
    forEachTileTreeRef(func: (treeRef: TileTreeReference) => void): void;
    getAspectRatio(): number;
    getAspectRatioSkew(): number;
    getAuxiliaryCoordinateSystemId(): Id64String;
    getCenter(result?: Point3d): Point3d;
    // @internal
    getDetail(name: string): any;
    // (undocumented)
    getDetails(): any;
    abstract getExtents(): Vector3d;
    getGridOrientation(): GridOrientationType;
    getGridSettings(vp: Viewport, origin: Point3d, rMatrix: Matrix3d, orientation: GridOrientationType): void;
    // (undocumented)
    getGridSpacing(): XAndY;
    // (undocumented)
    getGridsPerRef(): number;
    abstract getOrigin(): Point3d;
    abstract getRotation(): Matrix3d;
    // @internal (undocumented)
    static getStandardViewMatrix(id: StandardViewId): Matrix3d;
    getSubCategoryOverride(id: Id64String): SubCategoryOverride | undefined;
    getTargetPoint(result?: Point3d): Point3d;
    getViewClip(): ClipVector | undefined;
    abstract getViewedExtents(): AxisAlignedBox3d;
    getXVector(result?: Vector3d): Vector3d;
    getYVector(result?: Vector3d): Vector3d;
    getZVector(result?: Vector3d): Vector3d;
    // @internal
    hasSameCoordinates(other: ViewState): boolean;
    is2d(): this is ViewState2d;
    is3d(): this is ViewState3d;
    isCameraEnabled(): this is ViewState3d;
    isDrawingView(): this is DrawingViewState;
    // (undocumented)
    isPrivate?: boolean;
    isSpatialView(): this is SpatialViewState;
    // @internal (undocumented)
    isSubCategoryVisible(id: Id64String): boolean;
    load(): Promise<void>;
    lookAtViewAlignedVolume(volume: Range3d, aspect?: number, margin?: MarginPercent): void;
    lookAtVolume(volume: LowAndHighXYZ | LowAndHighXY, aspect?: number, margin?: MarginPercent): void;
    // @internal (undocumented)
    static maxSkew: number;
    get name(): string;
    // @internal
    peekDetail(name: string): any;
    // @internal
    refreshForModifiedModels(modelIds: Id64Arg | undefined): boolean;
    // @internal
    removeDetail(name: string): void;
    resetExtentLimits(): void;
    // @internal (undocumented)
    abstract savePose(): ViewPose;
    // @internal
    get scheduleScript(): RenderScheduleState.Script | undefined;
    setAspectRatioSkew(val: number): void;
    setAuxiliaryCoordinateSystem(acs?: AuxCoordSystemState): void;
    setCategorySelector(categories: CategorySelectorState): void;
    setCenter(center: Point3d): void;
    // @internal
    setDetail(name: string, value: any): void;
    // (undocumented)
    setDisplayStyle(style: DisplayStyleState): void;
    abstract setExtents(viewDelta: Vector3d): void;
    setGridSettings(orientation: GridOrientationType, spacing: Point2d, gridsPerRef: number): void;
    abstract setOrigin(viewOrg: XYAndZ): void;
    abstract setRotation(viewRot: Matrix3d): void;
    setRotationAboutPoint(rotation: Matrix3d, point?: Point3d): void;
    setStandardRotation(id: StandardViewId): void;
    setupFromFrustum(inFrustum: Frustum): ViewStatus;
    setViewClip(clip?: ClipVector): void;
    // @internal (undocumented)
    showFrustumErrorMessage(status: ViewStatus): void;
    // (undocumented)
    toJSON(): ViewDefinitionProps;
    // @internal (undocumented)
    validateViewDelta(delta: Vector3d, messageNeeded?: boolean): ViewStatus;
    get viewFlags(): ViewFlags;
    viewsCategory(id: Id64String): boolean;
    abstract viewsModel(modelId: Id64String): boolean;
}

// @public
export abstract class ViewState2d extends ViewState {
    constructor(props: ViewDefinition2dProps, iModel: IModelConnection, categories: CategorySelectorState, displayStyle: DisplayStyle2dState);
    // (undocumented)
    allow3dManipulations(): boolean;
    // (undocumented)
    readonly angle: Angle;
    // @internal (undocumented)
    applyPose(val: ViewPose2d): this;
    // (undocumented)
    readonly baseModelId: Id64String;
    // @internal (undocumented)
    static get className(): string;
    // (undocumented)
    computeFitRange(): Range3d;
    // (undocumented)
    createAuxCoordSystem(acsName: string): AuxCoordSystemState;
    // (undocumented)
    readonly delta: Point2d;
    // (undocumented)
    forEachModel(func: (model: GeometricModelState) => void): void;
    // @internal (undocumented)
    forEachModelTreeRef(func: (ref: TileTreeReference) => void): void;
    // (undocumented)
    getExtents(): Vector3d;
    // (undocumented)
    getOrigin(): Point3d;
    // (undocumented)
    getRotation(): Matrix3d;
    // (undocumented)
    getViewedExtents(): AxisAlignedBox3d;
    getViewedModel(): GeometricModel2dState | undefined;
    // (undocumented)
    load(): Promise<void>;
    // (undocumented)
    onRenderFrame(_viewport: Viewport): void;
    // (undocumented)
    readonly origin: Point2d;
    // @internal (undocumented)
    savePose(): ViewPose;
    // (undocumented)
    setExtents(delta: XAndY): void;
    // (undocumented)
    setOrigin(origin: XAndY): void;
    // (undocumented)
    setRotation(rot: Matrix3d): void;
    // @internal (undocumented)
    protected get _tileTreeRef(): TileTreeReference | undefined;
    // (undocumented)
    toJSON(): ViewDefinition2dProps;
    // @internal (undocumented)
    protected _treeRef?: TileTreeReference;
    // (undocumented)
    viewsModel(modelId: Id64String): boolean;
}

// @public
export abstract class ViewState3d extends ViewState {
    constructor(props: ViewDefinition3dProps, iModel: IModelConnection, categories: CategorySelectorState, displayStyle: DisplayStyle3dState);
    // (undocumented)
    allow3dManipulations(): boolean;
    // @internal (undocumented)
    applyPose(val: ViewPose3d): this;
    calcLensAngle(): Angle;
    // (undocumented)
    protected static calculateMaxDepth(delta: Vector3d, zVec: Vector3d): number;
    readonly camera: Camera;
    protected _cameraOn: boolean;
    centerEyePoint(backDistance?: number): void;
    centerFocusDistance(): void;
    // @internal
    changeFocusDistance(newDist: number): ViewStatus;
    // @internal
    changeFocusFromPoint(pt: Point3d): ViewStatus;
    // @internal (undocumented)
    static get className(): string;
    // (undocumented)
    createAuxCoordSystem(acsName: string): AuxCoordSystemState;
    // (undocumented)
    decorate(context: DecorateContext): void;
    // @internal (undocumented)
    protected drawGroundPlane(context: DecorateContext): void;
    // @internal (undocumented)
    protected drawSkyBox(context: DecorateContext): void;
    // @internal (undocumented)
    protected enableCamera(): void;
    readonly extents: Vector3d;
    forceMinFrontDist: number;
    getBackDistance(): number;
    // (undocumented)
    getDisplayStyle3d(): DisplayStyle3dState;
    // (undocumented)
    getExtents(): Vector3d;
    getEyePoint(): Point3d;
    getFocusDistance(): number;
    getFrontDistance(): number;
    getGroundElevation(): number;
    getGroundExtents(vp?: Viewport): AxisAlignedBox3d;
    getLensAngle(): Angle;
    // (undocumented)
    getOrigin(): Point3d;
    // (undocumented)
    getRotation(): Matrix3d;
    getTargetPoint(result?: Point3d): Point3d;
    // (undocumented)
    get isCameraOn(): boolean;
    get isCameraValid(): boolean;
    // (undocumented)
    isEyePointAbove(elevation: number): boolean;
    lookAt(eyePoint: XYAndZ, targetPoint: XYAndZ, upVector: Vector3d, newExtents?: XAndY, frontDistance?: number, backDistance?: number): ViewStatus;
    lookAtUsingLensAngle(eyePoint: Point3d, targetPoint: Point3d, upVector: Vector3d, fov: Angle, frontDistance?: number, backDistance?: number): ViewStatus;
    // (undocumented)
    minimumFrontDistance(): number;
    moveCameraLocal(distance: Vector3d): ViewStatus;
    moveCameraWorld(distance: Vector3d): ViewStatus;
    // (undocumented)
    onRenderFrame(_viewport: Viewport): void;
    readonly origin: Point3d;
    rotateCameraLocal(angle: Angle, axis: Vector3d, aboutPt?: Point3d): ViewStatus;
    rotateCameraWorld(angle: Angle, axis: Vector3d, aboutPt?: Point3d): ViewStatus;
    readonly rotation: Matrix3d;
    // @internal (undocumented)
    savePose(): ViewPose;
    // (undocumented)
    setExtents(extents: XYAndZ): void;
    setEyePoint(pt: XYAndZ): void;
    setFocusDistance(dist: number): void;
    setLensAngle(angle: Angle): void;
    // (undocumented)
    setOrigin(origin: XYAndZ): void;
    // (undocumented)
    setRotation(rot: Matrix3d): void;
    // (undocumented)
    setupFromFrustum(frustum: Frustum): ViewStatus;
    // (undocumented)
    supportsCamera(): boolean;
    // (undocumented)
    toJSON(): ViewDefinition3dProps;
    turnCameraOff(): void;
    verifyFocusPlane(): void;
}

// @public
export enum ViewStatus {
    // (undocumented)
    AlreadyAttached = 2,
    // (undocumented)
    DrawFailure = 4,
    // (undocumented)
    InvalidLens = 14,
    // (undocumented)
    InvalidTargetPoint = 13,
    // (undocumented)
    InvalidUpVector = 12,
    // (undocumented)
    InvalidViewport = 15,
    // (undocumented)
    InvalidWindow = 7,
    // (undocumented)
    MaxDisplayDepth = 11,
    // (undocumented)
    MaxWindow = 9,
    // (undocumented)
    MaxZoom = 10,
    // (undocumented)
    MinWindow = 8,
    // (undocumented)
    ModelNotFound = 6,
    // (undocumented)
    NotAttached = 3,
    // (undocumented)
    NotResized = 5,
    // (undocumented)
    Success = 0,
    // (undocumented)
    ViewNotInitialized = 1
}

// @public
export class ViewToggleCameraTool extends ViewTool {
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    onInstall(): boolean;
    // (undocumented)
    onPostInstall(): void;
    // (undocumented)
    static toolId: string;
}

// @public
export abstract class ViewTool extends InteractiveTool {
    constructor(viewport?: ScreenViewport | undefined);
    // (undocumented)
    beginDynamicUpdate(): void;
    // (undocumented)
    endDynamicUpdate(): void;
    exitTool(): void;
    // (undocumented)
    inDynamicUpdate: boolean;
    // (undocumented)
    onResetButtonUp(_ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    run(..._args: any[]): boolean;
    // (undocumented)
    static showPrompt(prompt: string): void;
    // (undocumented)
    static translate(val: string): any;
    // (undocumented)
    viewport?: ScreenViewport | undefined;
}

// @beta
export enum ViewUndoEvent {
    // (undocumented)
    Redo = 1,
    // (undocumented)
    Undo = 0
}

// @public
export class ViewUndoTool extends ViewTool {
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    onPostInstall(): void;
    // (undocumented)
    static toolId: string;
}

// @public
export class WalkViewTool extends ViewManip {
    constructor(vp: ScreenViewport, oneShot?: boolean, isDraggingRequired?: boolean);
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    onReinitialize(): void;
    // @beta (undocumented)
    provideToolAssistance(mainInstrKey: string): void;
    // (undocumented)
    static toolId: string;
}

// @internal (undocumented)
export type WebGLExtensionName = "WEBGL_draw_buffers" | "OES_element_index_uint" | "OES_texture_float" | "OES_texture_float_linear" | "OES_texture_half_float" | "OES_texture_half_float_linear" | "EXT_texture_filter_anisotropic" | "WEBGL_depth_texture" | "EXT_color_buffer_float" | "EXT_shader_texture_lod" | "ANGLE_instanced_arrays" | "OES_vertex_array_object" | "WEBGL_lose_context" | "EXT_frag_depth" | "EXT_disjoint_timer_query";

// @beta
export enum WebGLFeature {
    DepthTexture = "depth texture",
    FloatRendering = "float rendering",
    FragDepth = "fragment depth",
    Instancing = "instancing",
    MinimalTextureUnits = "minimal texture units",
    MrtPick = "mrt pick",
    MrtTransparency = "mrt transparency",
    ShadowMaps = "shadow maps",
    UintElementIndex = "uint element index"
}

// @beta
export interface WebGLRenderCompatibilityInfo {
    contextErrorMessage?: string;
    missingOptionalFeatures: WebGLFeature[];
    missingRequiredFeatures: WebGLFeature[];
    status: WebGLRenderCompatibilityStatus;
    unmaskedRenderer?: string;
    unmaskedVendor?: string;
    userAgent: string;
}

// @beta
export enum WebGLRenderCompatibilityStatus {
    AllOkay = 0,
    CannotCreateContext = 4,
    MajorPerformanceCaveat = 2,
    MissingOptionalFeatures = 1,
    MissingRequiredFeatures = 3
}

// @internal (undocumented)
export class WebMapTileLoader extends MapTileLoaderBase {
    constructor(_imageryProvider: ImageryProvider, iModel: IModelConnection, modelId: Id64String, groundBias: number, mapTilingScheme: MapTilingScheme, _filterTextures: boolean, heightRange?: Range1d);
    // (undocumented)
    get geometryAttributionProvider(): MapTileGeometryAttributionProvider | undefined;
    set geometryAttributionProvider(provider: MapTileGeometryAttributionProvider | undefined);
    // (undocumented)
    get imageryProvider(): ImageryProvider;
    // (undocumented)
    loadTileContent(tile: Tile, data: TileRequest.ResponseData, isCanceled?: () => boolean): Promise<Tile.Content>;
    // (undocumented)
    get maxDepth(): number;
    // (undocumented)
    get parentsAndChildrenExclusive(): boolean;
    // (undocumented)
    requestTileContent(tile: Tile, _isCanceled: () => boolean): Promise<TileRequest.Response>;
}

// @internal (undocumented)
export class WebMapTileProps implements TileProps {
    constructor(thisId: string, level: number, corners: Point3d[], zLow: number, zHigh: number);
    // (undocumented)
    readonly contentId: string;
    // (undocumented)
    readonly contentRange?: Range3dProps;
    // (undocumented)
    readonly corners: Point3d[];
    // (undocumented)
    readonly isLeaf: boolean;
    // (undocumented)
    readonly maximumSize: number;
    // (undocumented)
    readonly range: Range3dProps;
    }

// @internal (undocumented)
export class WebMapTileTreeProps implements TileTreeProps {
    constructor(groundBias: number, modelId: Id64String, heightRange?: Range1d, maxTilesToSkip?: number);
    id: string;
    location: TransformProps;
    // (undocumented)
    maxTilesToSkip: number;
    rootTile: TileProps;
    // (undocumented)
    yAxisUp: boolean;
}

// @internal
export class WheelEventProcessor {
    // (undocumented)
    static process(ev: BeWheelEvent, doUpdate: boolean): Promise<void>;
}

// @public
export class WindowAreaTool extends ViewTool {
    // (undocumented)
    decorate(context: DecorateContext): void;
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onMouseMotion(ev: BeButtonEvent): Promise<void>;
    // (undocumented)
    onPostInstall(): void;
    // (undocumented)
    onReinitialize(): void;
    // (undocumented)
    onResetButtonUp(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onTouchCancel(ev: BeTouchEvent): Promise<void>;
    // (undocumented)
    onTouchComplete(ev: BeTouchEvent): Promise<void>;
    // (undocumented)
    onTouchMove(ev: BeTouchEvent): Promise<void>;
    // (undocumented)
    onTouchMoveStart(ev: BeTouchEvent, startEv: BeTouchEvent): Promise<EventHandled>;
    // (undocumented)
    onTouchTap(ev: BeTouchEvent): Promise<EventHandled>;
    // @beta (undocumented)
    provideToolAssistance(): void;
    // (undocumented)
    static toolId: string;
}

// @public
export interface ZoomToOptions {
    placementRelativeId?: StandardViewId;
    standardViewId?: StandardViewId;
    viewRotation?: Matrix3d;
}

// @public
export class ZoomViewTool extends ViewManip {
    constructor(vp: ScreenViewport, oneShot?: boolean, isDraggingRequired?: boolean);
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    onReinitialize(): void;
    // (undocumented)
    static toolId: string;
}


// (No @packageDocumentation comment for this package)

```
